{"pages":[],"posts":[{"title":"Angular 深入淺出三十天：表單與測試 Day01 - 前言","text":"何謂表單？維基百科是這樣說的： 表單是一種帶有空格可用於書寫以及能選擇和勾選相似內容的文件。 表單可用於填寫聲明、請求、命令、支票、稅單。 網頁表單可以將使用者輸入的資料，傳送到伺服器進行處理。因為網際網路的使用者會操作核取方塊、無線電鈕或文字欄位來填寫網頁上的表格，所以網頁表單的形式類似檔案或資料庫。 網頁表單可應用線上上的電子商務：以信用卡訂購產品、要求貨運，或可用於檢索資料（例如，搜尋引擎上搜尋）。 以上文字與圖片皆來自於維基百科（表單與網頁表單）的搜尋結果。 自古以來，表單一直都是各大商業系統裡舉足輕重的一部分，舉凡會員註冊、商品寄送、稅務申請、市場調查等，各式各樣大大小小的表單連結你我的生活，其中更甚者，光以表單這個服務就是足以讓一間公司賴以為生。 Angular 的表單製作方法在 Angular 裡，製作表單的方法主要分成以下兩種方式： Template Driven Forms Reactive Forms Template Driven FormsTemplate Driven Forms 的方式很接近前端原始寫法，資料的驗證與限制都是使用 HTML 原生的表單機制，只是再額外加上 Angular 的資料綁定機制與範本語法來處理，只要知道有 HTML 與 Angular 的基礎即可使用，淺顯易懂、學習成本低，對前端新手來說較為簡單且熟悉。 但隨著表單的複雜度增加，後續維護難度也會越來越高，且不易於測試與重用性較差，所以一般用於較為簡單的情境。 Reactive FormsReactive Forms 的方式是直接用資料來創建與操作表單，較為抽象且需要對 RxJS 有基本的認知，有很多相對程式新手來說較困難、較不習慣的觀念要熟悉，學習成本較高。 但因其擴充性、重用性與可測試性都很好，且就算表單的複雜度增加，後續維護的難易度也不會多高，如果表單功能是你的應用程式裡很關鍵、重要的一塊，抑或是需要處理較為複雜、動態處理的表單，那麼我相當推薦使用此方式。 何謂測試？測試，是軟體工程裡很重要的一環，簡單地說就是用程式來驗證程式/系統/軟體的實際執行結果是否與預期執行結果相符。 試想，我們平常在開發功能時，如何知道我們所寫出來的程式其運作結果符合我們心中所想、符合功能需求抑或者使用者需求？ 我猜想，大部分開發者的流程應該是這樣： 開發 測試 除錯 不斷重複 1 ~ 3 直到完成開發 這樣的開發流程當然沒什麼太大的問題，不過俗話說得好：「人非聖賢，孰能無過。」，我們自己在測試時，非常容易就會因為各種無心、有心的關係，漏掉一些測試的案例；又或者跟別人開發時，我們不能保證別人都跟我們一樣在寫完程式之後都會乖乖測試，所以常常會造成改 A 壞 B ，甚至會有不符合需求的情況。 那如果我們將測試的步驟交給電腦來幫我們做會怎麼樣？ 我的程式啟蒙老師說過一句話：「電腦很聽話，你讓它往東它不會往西，如果程式碼有錯就一定是你的錯，不會是電腦的錯」，所以如果把測試這件事情讓電腦來做，你有幾個案例它就會測幾個案例，你要它測幾遍他就測幾遍，而且執行起來的速度比我們手動還要快太多太多，一旦有錯馬上就會知道，如此一來，就不會發生改 A 壞 B 的情況，使我們的程式碼品質變得更好。 關於前端的測試類型，我個人認為主要有以下三種： 單元測試 (Unit Testing) 整合測試 (Integration Testing) E2E 測試 (End-to-end Testing) 單元測試 (Unit Testing)測試單個類別的 function 其執行結果是否符合我們的預期。 整合測試 (Integration Testing)測試兩個以上的類別實體之間的互動是否符合我們的預期。 E2E 測試 (End-to-end Testing)模擬使用者的操作行為來測試一個完整的 story ，驗證其是否符合我們的預期。 想知道更多細節的話，可以參考保哥的文章：一次搞懂單元測試、整合測試、端對端測試之間的差異 關於本系列文我有幸參與過一些系統的製作，因此對於如何在 Angular 製作表單還算小有心得，雖然官網已經有相關的文件，網路上的資源更是多不勝數，但系統性地學習表單製作的文章與課程相對較少，再加上一般程式初學者對於 「測試」 這件事情普遍都只是 「聽說」 ，可能連看都沒看過，更不用提實作了。正好我也在這個部分小有研究，也慣於撰寫測試甚至樂於推廣，所以我會在這個系列文裡把這兩個單元結合，希望可以幫到大家。 需要注意的是，本系列文不適合完全不會 Angular 的朋友，如果是您是初學者、抑或是想學習 Angular 的朋友，可以先看看我的 Angular 深入淺出三十天，直到對於 Angular 的資料綁訂機制與範本語法有相當程度地了解之後，再來閱讀此系列文會比較好。 本系列文將從 Angular 裡最簡單的表單製作方式開始分享，章節安排具體會分成三個階段： 第一個階段此階段我會個別使用 Template Driven Forms 與 Reactive Forms 來分別實作靜態與動態的兩種表單，並且為這兩種表單撰寫單元測試與整合測試，最後再從幾個面向來比較這兩種開發表單的方式的優缺。 這個階段會有較大量的實作，主要是為希望大家能透過實作來了解並深刻體會這兩種表單開發方式的優缺，同時也能了解並熟悉撰寫測試的方式，篇幅大約是整個鐵人賽的一半左右。 第二個階段此階段我會介紹一些 E2E 自動化測試工具，並著重在於 Cypress 這個自動化測試工具上，並且使用它來為我們在第一個階段所撰寫的表單來撰寫 E2E 測試。 經過了前面的大量實作，這階段的篇幅不會太長，因為很多測試觀念上的分享在第一個階段就已經分享給大家，這階段主要是讓大家了解並熟悉 Cypress 與 E2E 測試的開發。 第三個階段最後一個階段主要會分享一些進階的 Reactive Forms 表單開發技巧、進階的測試撰寫技巧、測試驅動開發的技巧等較為進階的分享，希望對大家能夠有更進一步的幫助。 友情連結這次我是跟朋友一起組隊參賽的，透過團隊的壓力更能督促我自己一定要順利完賽（壓力山大），如果以下這些文章對你有幫助，也希望大家可以花點時間閱讀： NestJS 帶你飛！ 花30天做個Android小專案 Python 爬蟲這樣學，一定是大拇指拉！ 做一個面試官無法拒絕的sideproject，當一個全能的前端 特別友情貴賓 VVVVVIP 熱情強力推薦： 從 JavaScript 角度學 Python","link":"/2021/09/16/angular-30days-form-and-test-01/"},{"title":"Angular 深入淺出三十天：表單與測試 Day03 - Reactive Forms 實作 - 以登入為例","text":"今天要來用 Reactive Forms 的方式實作一個簡單的登入系統，撇開 UI 不談，具體的功能需求規格跟昨天差不多，如下所示： 帳號 格式為 Email Address，相關規則請參考維基百科，此處則直接使用正規表示法 /^\\b[\\w\\.-]+@[\\w\\.-]+\\.\\w{2,4}\\b$/gi 來檢驗，驗證有誤時需在欄位後方顯示錯誤訊息：格式有誤，請重新輸入 此欄位必填，驗證有誤時需需在欄位後方顯示錯誤訊息：此欄位必填 密碼 長度最短不得低於 8 碼，驗證有誤時需需在欄位後方顯示錯誤訊息：密碼長度最短不得低於8碼 長度最長不得超過 16碼，驗證有誤時需需在欄位後方顯示錯誤訊息：密碼長度最長不得超過16碼 此欄位必填，驗證有誤時需需在欄位後方顯示錯誤訊息：此欄位必填 以上驗證皆需在使用者輸入時動態檢查 任一驗證有誤時，登入按鈕皆呈現不可被點選之狀態。 規格需求看清楚之後，我們就來開始實作吧！ 實作時大家可以自己開一個專案來練習，抑或是用 Stackblitz 開一個 Angular 的專案來練習，我就不再贅述囉！ 如果正在閱讀此篇文章的你還不知道要怎麼開始一個 Angular 專案的話，請先閱讀我的 Angular 深入淺出三十天後再來閱讀此系列文章會比較恰當噢！ 實作開始首先我們先準備好基本的 HTML ： 12345678910111213&lt;form&gt; &lt;p&gt; &lt;label for=\"account\"&gt;帳號：&lt;/label&gt; &lt;input type=\"email\" id=\"account\"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;密碼：&lt;/label&gt; &lt;input type=\"password\" id=\"password\"&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=\"submit\"&gt;登入&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 未經美化的畫面應該會長這樣： 接著到 app.module.ts 裡 import FormsModule 與 ReactiveFormsModule ： 12345678910111213141516import { NgModule } from '@angular/core';import { BrowserModule } from '@angular/platform-browser';import { FormsModule, ReactiveFormsModule } from '@angular/forms';import { AppComponent } from './app.component';@NgModule({ imports: [ BrowserModule, FormsModule, ReactiveFormsModule ], declarations: [AppComponent], bootstrap: [AppComponent]})export class AppModule { } 然後將要綁在 Template 的屬性跟方法都準備好： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374export class LoginComponent implements OnInit { // 綁定在表單上 formGroup: FormGroup; /** * 用以取得帳號欄位的表單控制項 */ get accountControl(): FormControl { return this.formGroup.get('account') as FormControl; } /** * 用以取得密碼欄位的表單控制項 */ get passwordControl(): FormControl { return this.formGroup.get('password') as FormControl; } /** * 透過 DI 取得 FromBuilder 物件，用以建立表單 */ constructor(private formBuilder: FormBuilder) {} /** * 當 Component 初始化的時候初始化表單 */ ngOnInit(): void { this.formGroup = this.formBuilder.group({ account: [ '', [ Validators.required, Validators.pattern(/^\\b[\\w\\.-]+@[\\w\\.-]+\\.\\w{2,4}\\b$/gi) ] ], password: [ '', [ Validators.required, Validators.minLength(8), Validators.maxLength(16) ] ] }); } // 綁定在表單上，當使用者按下登入按鈕時會觸發此函式 login(): void { // do login... } /** * 透過該欄位的表單控制項來取得該欄位的錯誤訊息 * * @param {FormControl} formControl 欲取得錯誤訊息的欄位的表單控制項 (by Angular) */ getErrorMessage(formControl: FormControl): string { let errorMessage: string; if (!formControl.errors || formControl.pristine) { errorMessage = ''; } else if (formControl.errors.required) { errorMessage = '此欄位必填'; } else if (formControl.errors.pattern) { errorMessage = '格式有誤，請重新輸入'; } else if (formControl.errors.minlength) { errorMessage = '密碼長度最短不得低於8碼'; } else if (formControl.errors.maxlength) { errorMessage = '密碼長度最長不得超過16碼'; } return errorMessage; }} 就可以將這些屬性和方法跟 Template 綁定在一起： 1234567891011121314151617181920212223&lt;form [formGroup]=\"formGroup\" (ngSubmit)=\"login()\"&gt; &lt;p&gt; &lt;label for=\"account\"&gt;帳號：&lt;/label&gt; &lt;input type=\"email\" id=\"account\" [formControl]=\"accountControl\" /&gt; &lt;span class=\"error-message\"&gt;{{ getErrorMessage(accountControl) }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;密碼：&lt;/label&gt; &lt;input type=\"password\" id=\"password\" [formControl]=\"passwordControl\" /&gt; &lt;span class=\"error-message\"&gt;{{ getErrorMessage(passwordControl) }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=\"submit\" [disabled]=\"formGroup.invalid\"&gt;登入&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 到目前為止的程式碼你看懂了多少呢？對於剛接觸 Angular 的表單的朋友來說，今天的資訊量可能會比較大，容我稍微說明一下： Reactive Forms 的概念是將表單用程式的方式產生。以這個需求來說，這個表單底下會有兩個欄位 account 與 password ，如果將其用 JSON 來表示的話，應該會長這樣： 1234{ \"account\": \"\", \"password\": \"\"} 從資料面來看， {} 代表表單, &quot;account&quot;: &quot;&quot; 與 &quot;password&quot;: &quot;&quot; 則是裡面的兩個欄位。 而再將其轉換成 Reactive Forms 的概念的話， {} 代表的是 FormGroup ，&quot;account&quot;: &quot;&quot; 與 &quot;password&quot;: &quot;&quot; 則代表的是 FormControl。 所以在程式碼中我們可以看到我們宣告 formGroup: FromGroup; 並且在 template 中將其綁定在表單上： 123&lt;form [formGroup]=\"formGroup\"&gt; &lt;!-- ... --&gt;&lt;/form&gt; 並且把表單控制項綁定在對應的 input 欄位上： 12345678910111213&lt;!-- 帳號欄位 --&gt;&lt;input type=\"email\" id=\"account\" [formControl]=\"accountControl\"/&gt;&lt;!-- 密碼欄位 --&gt;&lt;input type=\"password\" id=\"password\" [formControl]=\"passwordControl\"/&gt; 然後在 ngOnInit 裡透過 FormBuilder 來初始化表單： 123456ngOnInit(): void { this.formGroup = this.formBuilder.group({ account: '我是該欄位的初始值', password: '我是該欄位的初始值' });} 如此一來，就可以在初始化過後，跟我們的 template 正確綁定了。 而如果當該欄位需要驗證時，就要在初始化時將格式調整成： 123456ngOnInit(): void { this.formGroup = this.formBuilder.group({ account: ['我是該欄位的初始值', /* 驗證器的擺放位置 */], password: ['我是該欄位的初始值', /* 驗證器的擺放位置 */], });} 如果只有一個要驗證的項目則可以直接放入： 123456ngOnInit(): void { this.formGroup = this.formBuilder.group({ account: ['我是該欄位的初始值', Validators.required], password: ['我是該欄位的初始值', Validators.required], });} 如果有多個要驗證的項目，就用 [] 將多個驗證項包起來再放入： 12345678910111213141516171819ngOnInit(): void { this.formGroup = this.formBuilder.group({ account: [ '我是該欄位的初始值', [ Validators.required, Validators.pattern(/^\\b[\\w\\.-]+@[\\w\\.-]+\\.\\w{2,4}\\b$/gi) ] ], password: [ '我是該欄位的初始值', [ Validators.required, Validators.minLength(8), Validators.maxLength(16) ] ], });} 在這裡我們可以發現，上一篇使用 Template Driven Forms 實作時，是用 HTML 原生的屬性來驗證，而今天使用 Reactive Forms 實作時，則是用程式來驗證，如此一來，可以降低表單與 template 之間的依賴性，使得其更易於維護、重用與測試。 Validators 是 Angular 幫我們製作的驗證器，裡面有很多常用驗證器，詳細請參考官方文件 當然我們也可以自己客製驗證器，只要符合 ValidatorFn 的類型即可 關於錯誤訊息基本上可以沿用上一篇的程式，只不過原本是傳入 FormControl 的 errors 來判斷，但現在是傳入整個 FormControl ，為什麼呢？ 因為如果只有傳入 FormControl 的 errors 的話，你會發現表單初始化完之後，就會有錯誤訊息顯示在畫面上： 這是因為當我們的表單初始化完之後，驗證器就會開始運作，所以的確那個兩個欄位是有那個錯誤沒錯，但其實這不是我們想要的行為，因為使用者根本就還沒有開始填表單，我們想要的是當使用者開始填表單之後，才會顯示對應的錯誤訊息，所以我們改傳入整個 FormControl ，它其中有幾個很好用的屬性可以使用： pristine ─ 如果此屬性為 true ，代表該欄位是乾淨，沒有被輸入過值；反之則代表有被輸入過值，與 dirty 成反比。 touched ─ 如果此屬性為 true，代表該欄位曾經被碰（該欄位曾經被使用滑鼠 focus 過）；反之則代表該欄位完全沒被碰過。 dirty ─ 如果此屬性為 true ，代表該欄位曾經被輸入過值，已經髒掉了；反之則代表該欄位是乾淨，沒有被輸入過值，與 pristine 成反比。 想知道更多可以參考官方文件： FormControl 與其抽象類別 AbstractControl 所以我們只要加上當該欄位是乾淨的，就不回傳錯誤訊息的判斷就可以了，像是這樣： 1234567getErrorMessage(formControl: FormControl): string { let errorMessage: string; if (!formControl.errors || formControl.pristine) { errorMessage = ''; } // 其他省略...} 最終結果： 本日小結對於第一次接觸 Reactive Forms 的朋友們，今天的資訊量會比較多，但重點大致上可歸納成以下四點： 學習如何將表單用程式的方式寫出來，心法：「資料即表單，表單即資料」。 學習如何使用表單物件 FormBuilder 、 FormGroup 與 FormControl 。 學習如何使用 Validators 來驗證使用者所輸入的值。 學習如何將表單物件與 Template 綁定。 此外，千萬記得要 import FormsModule 與 ReactiveFormsModule 才可以使用噢！ 我一樣會將今日的實作程式碼放在 Stackblitz 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，也都非常歡迎留言給我讓我知道噢！","link":"/2021/09/18/angular-30days-form-and-test-03/"},{"title":"Angular 深入淺出三十天：表單與測試 Day04 - 開始撰寫測試之前必須要知道的二三事","text":"在開始撰寫測試之前，先帶大家來了解一下 Angular 預設使用的測試框架 ─ Karma 。 Karma 的原名是 Testacular ， Google 在 2012 年的時候將其開源， 2013 年時將其改名為 Karma ，它是基於 Jasmine 與 Selenium 所開發出來的 JavaScript 測試執行過程管理工具（Test Runner）。 一般我們會使用它來撰寫單元測試與整合測試，測試的檔案名稱通常會命名為 xxx.spec.ts ，而只要是使用 Angular CLI 所建立的檔案，在預設的情況下都會連帶產生該檔案，像是： xxx.component.spec.ts 、 xxx.service.spec.ts 。 當我們想要執行測試程式時，只要使用指令 npm test or yarn test or ng test ，就可以看到它的執行結果： 當 Karma 執行起來後，只要我們不停掉它的 server 且不關掉它的視窗，只要我們有修改我們的測試並存檔後，它就會偵測到我們的變動並再重新跑一次測試，是個很方便且強大的功能。 關於執行測試時的更多參數，請參考Angular 官方 API 文件 想了解更多的話，可參考網路文章：JavaScript 測試工具之 Karma-Jasmine 的安裝和使用詳解與 Karma 官方文件 測試的檔案內容上述提到，在 Angular 裡的測試檔案一般我們會將其命名為 xxx.spec.ts ，而檔案內容大致上會長這樣： 或是這樣： 從中我們可以發現，它是一種巢狀式的結構，外層會是一個名字叫 describe 的函式，內層則有許多名為 it 的函式，這些函式各是什麼意思呢？ itit 指的是 測試案例（Test case），通常會在 describe 函式的裡面，使用方式如下所示： 123it('說明文字', () =&gt; { // test content}); 第一個參數是該測試案例的說明文字，讓我們在閱讀時可以很清楚、直接地知道這個測試案例會有什麼結果，通常建議以 should 做開頭，整體閱讀起來較為順暢，例如： 123it('should be created', () =&gt; { // test content}); 或者像是： 123it('should have as title \"Angular\"', () =&gt; { // test content}); 第二個參數是一個函式，裡面就是該測試案例所要執行的程式碼，也就是我們實際上要測試的內容。 describedescribe 指的是 測試集合（Test suite），主要是用於將測試案例分組、分類，類似資料夾的概念，這樣我們在閱讀程式碼的時候與其測試結果時，才會比較好閱讀 使用方式如下所示： 123describe('說明文字', () =&gt; { // test cases}); 跟 it 一樣，第一個參數是該測試集合的說明文字，讓我們在閱讀時可以很清楚、直接地知道這個測試集合的主要測試目標，例如： 123456789101112describe('LoginComponent', () =&gt; { describe('Component logic', () =&gt; { describe('login', () =&gt; { // test cases }); }); describe('Template logic', () =&gt; { describe('When login button be clicked', () =&gt; { // test cases }); });}); 第二個參數是一個函式，裡面是該測試集合所要執行的測試案例。 describe 除了分類、分組的功能外，他還有一個很重要的特性 ─ 作用域（Scoping） 。 作用域（Scoping）在寫測試案例的時候，我們可能會遇到某些情況是在需要事先做一些配置，又或者是驗證完之後需要把某些狀態還原，如果將這些事情寫在每一個 it 裡又覺得很囉嗦且不好維護，這時候我們就會使用以下這些函式來幫我們： beforeAll ─ 在執行所有的測試案例之前，會先執行這裡面的程式碼。 beforeEach ─ 在執行每一個測試案例之前，會先執行這裡面的程式碼。 afterAll ─ 在執行完所有的測試案例之後，會再執行這裡面的程式碼。 afterEach ─ 在執行完每一個測試案例之後，會再執行這裡面的程式碼。 舉個例子，如果我們有個測試集合長這樣： 12345678910111213141516171819202122232425describe('Test Suite', () =&gt; { beforeAll(() =&gt; { console.log('beforeAll'); }); beforeEach(() =&gt; { console.log('beforeEach'); }); it('test case - 1', () =&gt; { console.log('test case - 1'); }); it('test case - 2', () =&gt; { console.log('test case - 2'); }); afterEach(() =&gt; { console.log('afterEach'); }); afterAll(() =&gt; { console.log('afterAll'); });}); 它的執行結果會是這樣： 12345678// beforeAll// beforeEach// test case - 1// afterEach// beforeEach// test case - 2// afterEach// afterAll 從上述結果中可以看出，在一個測試集合裡會先執行的是 beforeAll 裡的程式，接著會是 beforeEach ，然後才會是測試案例；而在測試案例之後，則會先執行 afterEach 才會輪到下一個測試案例之前的 beforeEach，再接著下一個測試案例，之後一樣會是那個測試案例之後的 afterEach 。直到最後沒有測試案例時，就執行 afterAll 裡面的程式，結束這個測試集合。 有比較理解了嗎？如果有的話，我們來試試比較複雜一點的巢狀結構： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051describe('Test Suite - 1', () =&gt; { beforeAll(() =&gt; { console.log('beforeAll - 1'); }); beforeEach(() =&gt; { console.log('beforeEach - 1'); }); it('test case - 1', () =&gt; { console.log('test case - 1'); }); it('test case - 2', () =&gt; { console.log('test case - 2'); }); describe('Test Suite - 2', () =&gt; { beforeAll(() =&gt; { console.log('beforeAll - 2'); }); beforeEach(() =&gt; { console.log('beforeEach - 2'); }); it('test case - 3', () =&gt; { console.log('test case - 3'); }); it('test case - 4', () =&gt; { console.log('test case - 4'); }); afterEach(() =&gt; { console.log('afterEach - 2'); }); afterAll(() =&gt; { console.log('afterAll - 2'); }); }); afterEach(() =&gt; { console.log('afterEach - 1'); }); afterAll(() =&gt; { console.log('afterAll - 1'); });}); 它的執行結果會是這樣： 12345678910111213141516171819202122232425// beforeAll - 1// beforeEach - 1// test case - 1// afterEach - 1// beforeEach - 1// test case - 2// afterEach - 1// beforeAll - 2// beforeEach - 1// beforeEach - 2// test case - 3// afterEach - 2// afterEach - 1// beforeEach - 1// beforeEach - 2// test case - 4// afterEach - 2// afterEach - 1// afterAll - 2// afterAll - 1 為讓大家比較好閱讀，我將每個測試案例稍微隔開方便大家觀察其中規律。 雖然這個例子比較複雜，但邏輯上來說跟上一個例子一樣：在開始測試某測試集合裡面的測試案例之前，會先執行該測試集合的 beforeAll ，接著是每一個測試案例的 beforeEach ，然後執行測試案例，執行完測試案例後就是 afterEach 。 比較特別需要注意的就是當要開始執行 test case - 3 之前，會先執行的是 Test Suite - 2 的 beforeAll 。原因就像上面提過的：「在開始測試某測試集合裡面的測試案例之前，會先執行該測試集合的 beforeAll 」， test case - 3 是 Test Suite - 2 裡面的測試案例，所以在開始測試 test case - 3 之前，自然會先執行該測試集合裡的 beforeAll ，接著是父層測試集合裡的 beforeEach ，才會輪到 Test Suite - 2 裡面的 beforeEach 。 這個概念在大多數的前端測試框架裡是差不多的，學一次基本適用在大多數的測試框架裡， CP 值非常之高。 雖然上述的測試執行過程看似有序，但實際上我們不能依賴這種有序，原因跟如何撰寫出優秀的測試有關，不過相信今天的內容應該已經夠燒腦了，所以明天再跟大家分享如何撰寫出優秀的測試吧！ 本日小結今天的文章內容主要是要讓大家在開始撰寫測試之前，先對 Angular 的測試框架、測試檔案的內容結構有個初步的理解，如此一來有兩個好處： 後續不用再解釋，文章內容可以比較精簡 有需要時可以回來複習 此外，今天的重點主要是以下三點： 認識 Angular 預設所使用的測試框架。 了解測試檔案的內容結構。 理解作用域（Scoping） 的邏輯。 尤其是關於作用域（Scoping） 的部份，這在後續撰寫測試時，會非常常使用，所以如果有任何的問題或是回饋，請務必留言給我讓我知道噢！","link":"/2021/09/19/angular-30days-form-and-test-04/"},{"title":"Angular 深入淺出三十天：表單與測試 Day05 - 如何寫出優秀的測試？","text":"昨天介紹了開始撰寫測試之前必須要知道的二三事之後，想必大家已經對如何開始撰寫測試有了一些概念，但測試不是「有拜有保佑」，有寫就好。所以我們除了要知道如何開始撰寫測試之外，也要知道如何寫出優秀的測試。 什麼是優秀的測試？我認為要優秀的測試會具備以下三個特質： 值得信賴 易於維護 可讀性高 值得信賴雖說我們寫測試的目的是為了證明我們的程式碼沒有問題，但不代表我們的測試程式碼值得信賴。 換句話說，如果我們寫出的測試有問題，怎麼證明我們的程式碼沒問題？因此，如何撰寫出令人值得信賴的程式碼就是一個很重要的課題。 易於維護測試跟我們的程式碼同樣需要維護，而通常這會是很多人之所以「沒辦法」寫測試的原因，每當需求有變動且時間緊迫、資源短缺的情況下，測試就會被拋棄。 但如果我們能夠撰寫出易於維護的測試，就算時間緊迫、資源短缺，也能夠持續讓測試保護我們的程式碼。 可讀性高優秀的測試程式碼，是可以當成說明書來看的。透過閱讀測試程式碼，我們可以很快地了解被測試的程式具備了哪些功能、要怎麼使用。而且如果測試有問題，我們也能夠可以用最短的時間發現問題的根源。 甚至可以這麼說：一旦測試程式失去了可讀性，也不用想它能夠多易於維護與多值得信賴了。 因此，要如何讓我們的測試具備上述三個特質呢？ 撰寫值得信賴的測試我認為要撰寫出值得信賴的測試要從以下幾個方向著手： 避免在測試中裡寫邏輯 每次只測試一個關注點 Code review 避免在測試中裡寫邏輯我們寫測試是用來驗證我們程式中的邏輯是否正確，一旦我們在寫測試的時候也有邏輯，那是不是還要寫其他的程式來驗證我們的測試？在測試裡，我們不關心過程，只要結果，所以我們不需要在測試裡面寫邏輯，任何的 switch 、 if-else 、 for/while loop 、 try-catch 甚至是四則運算都不應該出現在測試裡，直接把結果寫上去即可。 每次只測試一個關注點很多時候在我們的程式裡同時做很多事情，這些事情就是我們要測試、驗證的關注點。 以我們前面撰寫過的程式碼來舉例： 1234accountValueChange(accountControl: FormControl): void { this.account = accountControl.value; this.validationCheck(accountControl.errors, 'account');} 這個函式做了兩件事情： 將 accountControl 的值指定給 account 。 用 accountControl 的 errors 來判斷要將什麼樣子的錯誤訊息指定給 accountErrorMessage 。 程式碼請參考第二天的文章：Template Driven Forms 實作 - 以登入為例 如果我們將這兩件事情的驗證都寫在同一個測試案例裡，當測試執行時，一旦第一件事情有錯，就不會再驗證第二件事情。 如此一來，我們怎麼知道第二件事情到底是對還是錯？ 所以當我們在測試這個函式時，就至少要用兩個測試案例來驗證上述做的兩件事情，以保證我們的測試案例有確實測試到每一件事情。 Code review有的時候我們自己一個人悶著頭寫，很容易沉浸在自己的世界、無法發現自己的錯誤，這時候我們就需要別人來幫忙我們用更客觀一點的角度來發現我們的不足。 其實幫你 Code review 的人不用一定是比你厲害的人，古語有云：「三人必有我師焉」，每個人都是獨特的，很多時候你沒發現的錯誤、你沒想到的問題、你沒有過的想法，都可以在這時候互相交流，就算幫你 Code review 的人比你差，這也是一個教他的好時機。 撰寫易於維護的測試要撰寫出易於維護的測試也一樣可以從以下幾個方向著手： 只測試公開的方法 測試也需要重構 測試隔離 比較物件 只測試公開的方法一般來說，我們會將方法宣告為 private 或是 protected 時，一定是基於很多設計上或安全上的考量，所以我們也只會測試公開的方法。而且宣告為 private 或是 protected 的方法一定不會單獨存在，它們一定會被某個公開方法呼叫（如果沒有就表示這個方法根本就沒人在使用，可以刪掉了），所以當我們測試公開方法時，一定會測到那個被呼叫到的 private 或是 protected 的方法。 這時一定會有人問說：「那我真的很想要測試那個宣告為 private 或是 protected 的方法的話要怎麼辦？」。 如果真的很想要測試那個宣告為 private 或是 protected 的方法，我們可以： 直接將該方法改為公開方法 將該方法抽到新的類別裡 把方法改成靜態方法 我個人比較偏好第二種跟第三種，因為這樣可以讓抽出來的這些方法可以被共用，在後續維護上也比較彈性。 測試也需要重構正如本文一開始所說的，程式碼需要維護，測試也需要維護；同樣地，程式碼需要重構，測試也需要。 不過測試的重構跟一般程式碼重構的重點稍稍有點不一樣，雖然大體上一樣是要減少重複的程式碼，但前面小節有提到「不要在測試裡寫邏輯」，以及後續會提到「動作與驗證要分開」以提升可讀性，所以在重構時要特別注意。 測試隔離想想看，你的測試有沒有以下的情況： 需要以某種順序執行 會在測試案例裡呼叫其他的測試案例 沒有重設共用的屬性、資料或者是狀態 如果你的測試有以上任何一種情況，都表示你沒有做好測試隔離。 測試隔離這名字聽起來很專業，其實講白話一點就是讓每個測試案例都是獨立的，不跟其他的測試案例有依賴、或是順序上的關係。每一個測試案例都要能單獨運作，每一個測試案例都要從初始化開始，一直到驗證完、清除或是還原狀態為止，如此才不會影響到其他的測試案例。 撰寫可讀性高的測試那到底要怎麼樣撰寫可讀性高的測試呢？其實大致上就跟我們開發的時候所要求的差不多，畢竟開發者寫的程式碼並不是給電腦看的，而是給人看的。 所以除了 Clean Code 一書裡提到的部分之外，對測試來說還需要注意以下兩點： 測試案例與測試集合的命名 把驗證和操作分開 測試案例與測試集合的命名好的測試案例與測試集合的命名，可以讓我們在讀測試程式碼或是測試結果時達到事半功倍的效果。舉例來說，如果我們要測試登入系統的帳號欄位，一個不好的測試案例與測試集合的命名可能會是這樣子的： 1234567891011describe('LoginComponent', () =&gt; { it('Test account input - positive', () =&gt; { // ... }); it('Test account input - negative', () =&gt; { // ... });}); 雖然可以知道這兩個測試是一個是驗證正向的情境，另一個是驗證負向的情境，但實際上還要去細看測試案例裡面程式碼在寫什麼才會知道當下這個測試案例驗證的是什麼樣的情境，可讀性較差。 而好的測試案例與測試集合的命名可能會是這樣子的： 12345678910111213141516171819202122describe('LoginComponent', () =&gt; { describe('accountValueChange', () =&gt; { it('should set value into property \"account\"', () =&gt; { // ... }); it('should assign the error message \"此欄位必填\" to property \"accountErrorMessage\" when the value is the empty string', () =&gt; { // ... }); it('should assign the error message \"格式有誤，請重新輸入\" to property \"accountErrorMessage\" when the value is not the correct pattern', () =&gt; { // ... }); it('should assign the empty string to property \"accountErrorMessage\" when the value is the correct pattern', () =&gt; { // ... }); });}); 有沒有覺得這樣比較好讀呢？ 語言當然不一定要用英文啦，用中文也行，看團隊、主管或者是公司的規範。 把驗證和操作分開為了可讀性，讓別人可以很好閱讀且很快速地理解我們所寫的內容，所以我們不會為了節省程式碼的空間，而把程式碼都擠在一起，導致看的人還要去動腦思考，降低效率。 例如我們要驗證登入系統的帳號欄位在值改變時，有沒有將 input 欄位的值指派給 Component 的屬性 account ，所以我們有程式碼可能會這樣子寫： 12345it('should assign the value to property \"account\"', () =&gt; { const accountControl = new FormControl('abc123@mail.com'); component.accountValueChange(accountControl); expect(component.account).toBe(accountControl.value);}); 乍看之下其實沒什麼太大的問題，也不是很難的程式碼，但如果這樣寫會更好一點： 123456it('should assign the value to property \"account\"', () =&gt; { const account = 'abc123@mail.com'; const accountControl = new FormControl(account); component.accountValueChange(accountControl); expect(component.account).toBe(account);}); 又或者是這樣： 123456it('should assign the value to property \"account\"', () =&gt; { const accountControl = new FormControl('abc123@mail.com'); component.accountValueChange(accountControl); const account = accountControl.value; expect(component.account).toBe(account);}); 簡單來說就是一步一步來，將動作跟驗證分開，減少一些閱讀時的負擔，會讓整個程式碼更好閱讀。 此外，在撰寫測試時，有個 3A 原則的方式非常推薦大家使用。 3A 原則這是在測試的世界裡，非常著名的方法。可以說是只要照著這個方法寫，滿簡單就能寫出不錯的測試。 而這個 3A 分別指的是： Arrange - 準備物件或者是進行必要的前置作業。 Act - 實際執行、操作物件。 Assert - 進行結果驗證 以上面的程式碼為例， 3A 是這樣分的： 123456789it('should assign the value to property \"account\"', () =&gt; { // Arrange const account = 'abc123@mail.com'; const accountControl = new FormControl(account); // Act component.accountValueChange(accountControl); // Assert expect(component.account).toBe(account);}); 這樣看起來是不是更好讀了呢？ 雖然已經說了那麼多，但當程式已經實作好之後再來補測試其實是還滿辛苦的，因此有一種開發方式叫做測試驅動開發。 測試驅動開發測試驅動開發，也就是所謂的 TDD (Test-driven development) 。 這個方式有一個流程，如下圖所示： 一開始要先寫測試不實作程式碼，這時測試會是紅燈的狀態 只實作足以讓測試通過的程式碼，這時測試就會通過變成綠燈 當反覆這樣子做了幾次之後，實作的程式碼變多了可能會需要重構 重構完之後，如果測試變成了紅燈，我們就再調整實作使其變成綠燈 重複循環這個過程 這樣子的作法有滿多好處的，像是： 測試跟開發同步進行，有多少測試就寫多少程式碼 由於測試先行，所以寫出來的程式碼都很好被測試 由於有測試保護，在不斷重構的過程中並不會出現改 A 壞 B 的情況 由於會不斷地重構，所以寫出來的程式碼會很好維護 雖然聽起來很簡單、好處很多，但在這流程中還是要注意以下三點： 絕不跳過重構 儘快變綠 出錯後放慢腳步 此外，我建議大家在寫按照這個方式開發時，注意以下幾件事情： 編寫測試時就僅僅關注測試，不想去如何實現 先以調用方的角度來調用這塊代碼，並且從調用方的角度說出所期望的結果 在編寫某個功能的代碼之前先編寫測試代碼，然後只編寫使測試通過的功能代碼 所有的實現都是測試「逼」出來的，所有的實現代碼都是為了讓測試通過而編寫的 本日小結今天的重點主要是分享何謂優秀的測試與如何撰寫出優秀的測試這兩點上，後面所分享測試驅動開發是提供一種更好寫測試的開發方法給大家參考。 雖然我已經將如何寫測試、如何寫出好的測試都分享給大家了，但羅馬不是一天造成的，沒有人一開始就能寫得出很好的測試。唯有不斷地練習與學習，才能越寫越輕鬆、越寫越快樂。 總之，坐而言不如起而行，撰寫測試對於專業的軟體工程師來說絕對是一件利大於弊的事情，因此，從今天就開始寫測試吧！ 此外，非常推薦大家閱讀書籍：「單元測試的藝術」，裡面對於「什麼是優秀的測試」與「如何撰寫優秀的測試」的部份會講得更加詳細與完整。 對於我今天所分享的部份，如果我有講錯或是大家有任何想要補充的部分，都非常歡迎留言在下面或訊息我讓我知道噢！","link":"/2021/09/20/angular-30days-form-and-test-05/"},{"title":"Angular 深入淺出三十天：表單與測試 Day02 - Template Driven Forms 實作 - 以登入為例","text":"今天要來用 Template Driven Forms 的方式實作一個簡單的登入系統，撇開 UI 不談，具體的功能需求規格如下： 帳號 格式為 Email Address，相關規則請參考維基百科，此處則直接使用正規表示法 /^\\b[\\w\\.-]+@[\\w\\.-]+\\.\\w{2,4}\\b$/gi 來檢驗，驗證有誤時需在欄位後方顯示錯誤訊息：格式有誤，請重新輸入 此欄位必填，驗證有誤時需需在欄位後方顯示錯誤訊息：此欄位必填 密碼 長度最短不得低於 8 碼，驗證有誤時需需在欄位後方顯示錯誤訊息：密碼長度最短不得低於8碼 長度最長不得超過 16碼 此欄位必填，驗證有誤時需需在欄位後方顯示錯誤訊息：此欄位必填 以上驗證皆需在使用者輸入時動態檢查 任一驗證有誤時，登入按鈕皆呈現不可被點選之狀態。 規格需求看清楚之後，我們就來開始實作吧！ 實作時大家可以自己開一個專案來練習，抑或是用 Stackblitz 開一個 Angular 的專案來練習，我就不再贅述囉！ 如果正在閱讀此篇文章的你還不知道要怎麼開始一個 Angular 專案的話，請先閱讀我的 Angular 深入淺出三十天後再來閱讀此系列文章會比較恰當噢！ 實作開始首先我們先準備好基本的 HTML ： 12345678910111213&lt;form&gt; &lt;p&gt; &lt;label for=\"account\"&gt;帳號：&lt;/label&gt; &lt;input type=\"email\" name=\"account\" id=\"account\"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;密碼：&lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"password\"&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=\"submit\"&gt;登入&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 未經美化的畫面應該會長這樣： 接著到 app.module.ts 裡 import FormsModule ： 123456789101112131415import { NgModule } from '@angular/core';import { BrowserModule } from '@angular/platform-browser';import { FormsModule } from '@angular/forms';import { AppComponent } from './app.component';@NgModule({ imports: [ BrowserModule, FormsModule ], declarations: [AppComponent], bootstrap: [AppComponent]})export class AppModule { } 然後將要綁在 Template 的屬性跟方法都準備好： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283export class AppComponent { // 綁定在帳號欄位上 account = ''; // 綁定在密碼欄位上 password = ''; // 帳號欄位的錯誤訊息 accountErrorMessage = ''; // 密碼欄位的錯誤訊息 passwordErrorMessage = ''; /** * 綁定在帳號欄位上，當使用者改變登入帳號時，會觸發此函式，並取得對應的錯誤訊息 * * @param {string} account * @param {ValidationErrors} errors */ accountValueChange(account: string, errors: ValidationErrors): void { this.account = account; this.validationCheck(errors, 'account'); } /** * 綁定在密碼欄位上，當使用者改變密碼時會觸發此函式 * * @param {string} password * @param {ValidationErrors} errors */ passwordValueChange(password: string, errors: ValidationErrors): void { this.password = password; this.validationCheck(errors, 'password'); } // 綁定在表單上，當使用者按下登入按鈕時會觸發此函式 login(): void { // do login... } /** * 透過欄位裡的 ValidationErrors 來設定該欄位的錯誤訊息 * * @param {ValidationErrors} errors 欲驗證的欄位的錯誤 (by Angular) * @param {'account' | 'password'} fieldName 欄位名稱 */ private validationCheck( errors: ValidationErrors, fieldName: 'account' | 'password' ): void { let errorMessage: string; if (!errors) { errorMessage = ''; } else if (errors.required) { errorMessage = '此欄位必填'; } else if (errors.pattern) { errorMessage = '格式有誤，請重新輸入'; } else if (errors.minlength) { errorMessage = '密碼長度最短不得低於8碼'; } this.setErrorMessage(fieldName, errorMessage); } /** * 設定指定欄位的錯誤訊息 * * @param {'account' | 'password'} fieldName 欲設定錯誤訊息的欄位名稱 * @param {string} errorMessage 欲設定的錯誤訊息 */ private setErrorMessage( fieldName: 'account' | 'password', errorMessage: string ): void { if (fieldName === 'account') { this.accountErrorMessage = errorMessage; } else { this.passwordErrorMessage = errorMessage; } }} 就可以將這些屬性和方法跟 Template 綁定在一起： 12345678910111213141516171819202122232425262728293031323334&lt;form #form=\"ngForm\" (ngSubmit)=\"login()\"&gt; &lt;p&gt; &lt;label for=\"account\"&gt;帳號：&lt;/label&gt; &lt;input type=\"email\" name=\"account\" id=\"account\" required pattern=\"\\b[\\w\\.-]+@[\\w\\.-]+\\.\\w{2,4}\\b\" #accountNgModel=\"ngModel\" [ngModel]=\"account\" (ngModelChange)=\"accountValueChange(accountNgModel.value, accountNgModel.errors)\" /&gt; &lt;span class=\"error-message\"&gt;{{ accountErrorMessage }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;密碼：&lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" required #passwordNgModel=\"ngModel\" [minlength]=\"8\" [maxlength]=\"16\" [ngModel]=\"password\" (ngModelChange)=\"passwordValueChange(passwordNgModel.value, passwordNgModel.errors)\" /&gt; &lt;span class=\"error-message\"&gt;{{ passwordErrorMessage }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=\"submit\" [disabled]=\"form.invalid\"&gt;登入&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 到目前為止的程式碼你看懂了多少呢？容我稍微說明一下： 首先是關於必填檢核，只要 &lt;input ...&gt; 欄位裡加上 HTML 原生的屬性 ─ required 即可。 帳號欄位的格式檢查則是使用原生的屬性 ─ pattern ，這個屬性可以直接使用正規表示法的方式來檢查使用者所輸入的值是否符合我們所訂定的格式。不過要注意的是，頭尾不需要特別加上 /^$/ ，所以整串表示法只需要用到中間的部份 ─ \\b[\\w\\.-]+@[\\w\\.-]+\\.\\w{2,4}\\b 。 對這個屬性較不熟悉的朋友可以參照 MDN 的說明文件。 字數長度的檢核也是使用原生的屬性 ─ minlength 與 maxlength 。這部份有兩個地方需要特別留意： 字數長度的檢核不會管你的字元是半型還是全型、是英文還是中文，每個字元都是一樣以一個長度來計算，如果有特別需求就不能使用這個方式處理。 HTML 的原生屬性 ─ maxlength 是會阻擋使用者輸入的，當需求是要檢核長度但不能阻擋使用者輸入的話，就不能使用這個方式。 很多人剛學會用 Angular 的朋友，在使用 ngModel 時都會忘記這兩件事情: 引入 FormsModule input 要有 name 屬性 使用範本語法 #accountNgModel=&quot;ngModel&quot; 、 #passwordNgModel=&quot;ngModel&quot; 來取得型別為 NgModel 的物件，因為我們可以從中取得該欄位的 value 與 errors ，前者指定給其相關屬性，後者用以判斷該欄位的錯誤，以設定相對應的錯誤訊息。 單純使用 #accountNgModel 與 #accountNgModel=&quot;ngModel&quot; 的差別在於前者取得的是單純的 HTMLInputElement 物件。 使用範本語法 #form=&quot;ngForm&quot; 來取得型別為 NgForm 的表單物件。 單純使用 #form 與 #form=&quot;ngForm&quot; 的差別在於前者取得的是單純的 HTMLFormElement 物件。 最後，則是將登入按鈕加上 [disabled]=&quot;form.invalid&quot; 的綁定，讓按鈕在表單無效時，無法按下登入按鈕。 至此，我們就完成今天的目標囉！是不是很簡單呢？！ 最後的結果應該要像這樣： 本日小結剛開始學習 Angular 的朋友，通常都會因為不熟悉 Angular 的語法而導致明明很簡單的功能卻要弄得很複雜。 今天的學習重點主要有以下三點： 學習如何使用 Angular 的範本語法取得 Angular 已經包裝好的物件，例如 #accountNgModel=&quot;ngModel&quot; 與 #form=&quot;ngForm&quot; 。 學習使用表單物件 NgModel 、 NgForm。 善用 NgModel 裡的 ValidationErrors 取得相應的錯誤訊息。 我會將今日的實作程式碼放在 Stackblitz 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，也都非常歡迎留言給我讓我知道噢！ 錯誤回報更新 2021-09-19 22:54:50 ，感謝熱心讀者「程凱大」指正錯誤，已移除所有的 FormControl ，原因是因為在 Template Driven Forms 的範圍裡， NgModel 本身已有我們所需之屬性，是我自己豬頭捨近求遠，再次衷心感謝。","link":"/2021/09/17/angular-30days-form-and-test-02/"},{"title":"Angular 深入淺出三十天：表單與測試 Day06 - 單元測試實作 - 登入系統 by Template Driven Forms","text":"今天我們要來為我們用 Template Driven Forms 所撰寫的登入系統寫單元測試，如果還沒有相關程式碼的朋友，趕快前往閱讀第二天的文章： Template Driven Forms 實作 - 以登入為例。 此外，由於使用 Stackblitz 來寫測試比較麻煩一點，所以我建議大家都使用 ng new 建立新的專案，因為 Angular 都幫開發者處理好了，使用 Angular 的開發者就是這麼幸福。 所以在開始之前，如果當初是用 Stackblitz 練習的話，要先將程式碼複製到專案裡，詳細步驟我就不再贅述囉！ 小提醒，將程式碼複製到專案裡之後，記得先使用 ng serve 的指令將其啟動起來看看是不是可以正常運作噢！ 此外，如果是用 Angular v12 以上的同學，預設的 typescript 會是 strict mode 的狀態，也就是說型別檢查會比較嚴格一點，所以如果看到很多紅色毛毛蟲不用太擔心。 如果有任何問題，我預言會有 80% 的朋友是忘記在 module 裡 import FormsModule ，哈哈！ 實作開始上述前置作業做完之後，我們就可以先打開 app.component.spec.ts，你應該會看到 Angular CLI 幫我們產生的程式碼： 我們先把除了 should create the app 之外的測試案例刪掉，刪完應該要長這樣： 123456789101112131415161718import { TestBed } from '@angular/core/testing';import { AppComponent } from './app.component';describe('AppComponent', () =&gt; { beforeEach(async () =&gt; { await TestBed.configureTestingModule({ declarations: [ AppComponent ], }).compileComponents(); }); it('should create the app', () =&gt; { const fixture = TestBed.createComponent(AppComponent); const app = fixture.componentInstance; expect(app).toBeTruthy(); });}); 至此我稍微說明一下，在 beforeEach 裡我們可以看到有段滿特別的程式碼： 12345TestBed.configureTestingModule({ declarations: [ AppComponent ],}).compileComponents(); 這段程式碼是在配置我們測試集合的環境，就像我們在寫 Angular 的時候一樣， Component 會需要一個模組，而 TestBed 是 Angular 幫我們預先寫好給測試用的一個類型，透過 configureTestingModule 來模擬真實使用情境，最後用 compileComponents 將其實際執行。 這段配置在 Angular 基本上會是必備的，並且我們還會需要依據 Component 其實際情況來調整該配置，例如我們現在就因為我們的表單需要的關係，要在這裡引入 FormsModule ： 1234567891011121314151617import { TestBed } from '@angular/core/testing';import { FormsModule } from '@angular/forms';import { AppComponent } from './app.component';describe('AppComponent', () =&gt; { beforeEach(async () =&gt; { await TestBed.configureTestingModule({ declarations: [AppComponent], imports: [FormsModule] }).compileComponents(); }); it('should create the app', () =&gt; { // ... });}); 接著使用 ng test 的指令將測試程式啟動起來，應該會可以通過我們的第一個測試案例 should create the app： 通過這個測試基本上意謂著我們要測試的 Component 的配置沒有什麼太大的問題，因為他要可以被正常建立實體才能通過，至此我們就可以開始來撰寫單元測試了。 欲測試的單元選擇在第一天時我有提到，單元測試主要是要用來驗證單個類別的函式其實際執行結果是否符合我們預期的執行結果。 所以我們先打開 app.component.ts 來看一下目前的程式碼： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081export class AppComponent { // 綁定在帳號欄位上 account = ''; // 綁定在密碼欄位上 password = ''; // 帳號欄位的錯誤訊息 accountErrorMessage = ''; // 密碼欄位的錯誤訊息 passwordErrorMessage = ''; /** * 綁定在帳號欄位上，當使用者改變帳號時會觸發此函式 * * @param {string} account * @param {ValidationErrors} errors */ accountValueChange(account: string, errors: ValidationErrors | null): void { this.account = account; this.validationCheck(errors, 'account'); } /** * 綁定在密碼欄位上，當使用者改變密碼時會觸發此函式 * * @param {string} password * @param {ValidationErrors} errors */ passwordValueChange(password: string, errors: ValidationErrors | null): void { this.password = password; this.validationCheck(errors, 'password'); } // 綁定在表單上，當使用者按下登入按鈕時會觸發此函式 login(): void { // do login... } /** * 透過欄位裡的 ValidationErrors 來設定該欄位的錯誤訊息 * * @param {ValidationErrors | null} errors 欲驗證的欄位的錯誤 (by Angular) * @param {'account' | 'password'} fieldName 欄位名稱 */ private validationCheck( errors: ValidationErrors | null, fieldName: 'account' | 'password' ): void { let errorMessage: string; if (!errors) { errorMessage = ''; } else if (errors.required) { errorMessage = '此欄位必填'; } else if (errors.pattern) { errorMessage = '格式有誤，請重新輸入'; } else if (errors.minlength) { errorMessage = '密碼長度最短不得低於8碼'; } this.setErrorMessage(fieldName, errorMessage); } /** * 設定指定欄位的錯誤訊息 * * @param {'account' | 'password'} fieldName 欲設定錯誤訊息的欄位名稱 * @param {string} errorMessage 欲設定的錯誤訊息 */ private setErrorMessage( fieldName: 'account' | 'password', errorMessage: string ): void { if (fieldName === 'account') { this.accountErrorMessage = errorMessage; } else { this.passwordErrorMessage = errorMessage; } }} 以目前的程式碼來看，這個 Component 的函式有以下這些： accountValueChange passwordValueChange login validationCheck setErrorMessage 這五個函式裡，其中 login 沒寫什麼先不測， validationCheck 與 setErrorMessage 是 private 的也不用測，所以我們主要要測試 accountValueChange 與 passwordValueChange 這兩個函式。 測試單元 - accountValueChange既然如此，我們先加一個 describe ，表明在這裡面的測試案例都是在測 accountValueChange 這個函式： 1234567describe('AppComponent', () =&gt; { // ... describe('accountValueChange', () =&gt; { // 這裡面的測試案例都是要測這個函式 });}); 然後我們來統整一下這個 accountValueChange 的函式裡會遇到的情況： 會將傳入的 account 的值賦值給 AppComponent 的屬性 account 。 如果傳入的 errors 有 required 欄位，則會將錯誤訊息 此欄位必填 賦值給 AppComponent 的屬性 accountErrorMessage 。 如果傳入的 errors 有 pattern 欄位，則會將錯誤訊息 格式有誤，請重新輸入 賦值給 AppComponent 的屬性 accountErrorMessage 。 如果傳入的 errors 是 null ，則會將 AppComponent 的屬性 accountErrorMessage 設為空字串。 統整完之後，就可以將上述情況寫成測試案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849describe('accountValueChange', () =&gt; { it('should set value into property \"account\"', () =&gt; { // Arrange const account = 'abc123@mail.com'; const errors = null; // Act component.accountValueChange(account, errors); // Assert expect(component.account).toBe(account); }); it('should set the required error message into property \"accountErrorMessage\" when the value is empty string', () =&gt; { // Arrange const account = ''; const errors = { required: true }; const accountErrorMessage = '此欄位必填'; // Act component.accountValueChange(account, errors); // Assert expect(component.accountErrorMessage).toBe(accountErrorMessage); }); it('should set the pattern error message into property \"accountErrorMessage\" when the value is not the correct pattern', () =&gt; { // Arrange const account = 'abc123'; const errors = { pattern: { actualValue: 'abc123', requiredPattern: '^\\\\b[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\\\\.\\\\w{2,4}\\\\b$' } }; const accountErrorMessage = '格式有誤，請重新輸入'; // Act component.accountValueChange(account, errors); // Assert expect(component.accountErrorMessage).toBe(accountErrorMessage); }); it('should set empty string into property \"accountErrorMessage\" when the value is the correct pattern', () =&gt; { // Arrange const account = 'abc123@mail.com'; const errors = null; const accountErrorMessage = ''; // Act component.accountValueChange(account, errors); // Assert expect(component.accountErrorMessage).toBe(accountErrorMessage); });}); 測試結果： 測試單元 - passwordValueChange接下來，我們繼續來撰寫測試案例來測試 passwordValueChange 函式，一樣先加一個 describe ，表明在這裡面的測試案例都是在測 passwordValueChange 函式： 1234567describe('AppComponent', () =&gt; { // ... describe('passwordValueChange', () =&gt; { // 這裡面的測試案例都是要測這個函式 });}); 然後我們來統整一下這個 passwordValueChange 的函式裡會遇到的情況： 會將傳入的 password 的值賦值給 AppComponent 的屬性 password 。 如果傳入的 errors 有 required 欄位，則會將錯誤訊息 此欄位必填 賦值給 AppComponent 的屬性 passwordErrorMessage 。 如果傳入的 errors 有 minlength 欄位，則會將錯誤訊息 密碼長度最短不得低於8碼 賦值給 AppComponent 的屬性 passwordErrorMessage 。 如果傳入的 errors 是 null ，則會將 AppComponent 的屬性 passwordErrorMessage 設為空字串。 統整完之後其實可以發現，這跟剛剛我們測 accountValueChange 的時候很像，所以我們只要複製一下 accountValueChange 的測試案例再稍微改一下就可以用了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950describe('passwordValueChange', () =&gt; { it('should set value into property \"password\"', () =&gt; { // Arrange const password = 'abc123'; const errors = null; // Act component.passwordValueChange(password, errors); // Assert expect(component.password).toBe(password); }); it('should set the required error message into property \"passwordErrorMessage\" when the value is empty string', () =&gt; { // Arrange const password = ''; const errors = { required: true }; const passwordErrorMessage = '此欄位必填'; // Act component.passwordValueChange(password, errors); // Assert expect(component.passwordErrorMessage).toBe(passwordErrorMessage); }); it('should set the pattern error message into property \"passwordErrorMessage\" when the value is not the correct pattern', () =&gt; { // Arrange const password = 'abc123'; const errors = { minlength: { actualLength: 7, requiredLength: 8 } }; const passwordErrorMessage = '密碼長度最短不得低於8碼'; // Act component.passwordValueChange(password, errors); // Assert expect(component.passwordErrorMessage).toBe(passwordErrorMessage); }); it('should set empty string into property \"passwordErrorMessage\" when the value is the correct pattern', () =&gt; { // Arrange const password = 'abcd1234'; const errors = null; const passwordErrorMessage = ''; // Act component.passwordValueChange(password, errors); // Assert expect(component.passwordErrorMessage).toBe(passwordErrorMessage); });}); 測試結果： 至此，我們就完成了單元測試的部份囉！是不是感覺其實很簡單，並沒有想像中的難呢？！俗話說：「萬事起頭難」，只要我們已經跨出第一步，後面就會越來越簡單噢！ 今天的文章就到這邊，大家稍微沉澱、吸收一下，明天我們接著撰寫整合測試的部份。 本日小結再次提醒大家，單元測試要驗證的是某一函式在不同情況下的執行結果是否符合預期，並且記得要盡量做到我在如何寫出優秀的測試？文中所提到的部份。 今天的程式碼比較多，且應該會有很多朋友初次接觸到測試所以可能腦筋會比較轉不過來，這時可以先回頭看看我第四天與第五天的文章，複習一下核心概念與測試語法，相信一定會有所幫助。 我會將今日的實作程式碼放在 Github - Branch: day6 供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，也都非常歡迎留言給我讓我知道噢！","link":"/2021/09/21/angular-30days-form-and-test-06/"},{"title":"Angular 深入淺出三十天：表單與測試 Day07 - 整合測試實作 - 登入系統 by Template Driven Forms","text":"昨天幫我們用 Template Driven Forms 所撰寫的登入系統寫完單元測試之後，今天則是要來為它寫整合測試。 大家還記得整合測試的目標是要測什麼嗎？我幫大家複習一下： 整合測試的測試目標是要測試兩個或是兩個以上的類別之間的互動是否符合我們的預期。 再更直接一點地說，整合測試就是在測互動關係，其他的事情我們都不在乎，因為其他的事情基本上都會在單元測試的部份裡測。 這時候可能會有人覺得奇怪，我們現在就只有一個 Component ，並沒有符合「兩個或是兩個以上的類別」，這樣是要怎麼測試？ 沒錯，雖然我們現在並沒有「兩個或是兩個以上的類別」，但是前端比較不一樣的地方是前端會有畫面，使用者實際上是看著畫面來跟我們的程式互動的。 用我們用做的登入系統來說，雖然很簡單、很陽春，但如果沒有畫面、沒有那些輸入欄位，使用者也沒辦法使用。 所以今天寫整合測試的目的就是要來來驗證我們所做的登入系統的畫面，有沒有如我們所預期地和我們的程式碼互動。 實作開始首先我們先增加一個 describe 的區塊，有關於整合測試的程式碼接下來都會放在這裡面： 12345678910111213141516171819202122232425import { TestBed } from '@angular/core/testing';import { AppComponent } from './app.component';describe('AppComponent', () =&gt; { let component: AppComponent; beforeEach(async () =&gt; { await TestBed.configureTestingModule({ declarations: [AppComponent], imports: [FormsModule] }).compileComponents(); const fixture = TestBed.createComponent(AppComponent); component = fixture.componentInstance; }); describe('Unit testing', () =&gt; { // 昨天寫的單元測試... }); describe('Integration testing', () =&gt; { // 今天要寫的整合測試 });}); 一般我們不會特別將單元測試跟整合測試的程式碼分開檔案來寫，只會用測試集合將其區隔。 由於今天的整合測試跟畫面會比較有相關，所以我們打開 app.component.html 來看一下目前的程式碼： 1234567891011121314151617181920212223242526272829303132333435363738&lt;form #form=\"ngForm\" (ngSubmit)=\"login()\"&gt; &lt;p&gt; &lt;label for=\"account\"&gt;帳號：&lt;/label&gt; &lt;input type=\"email\" name=\"account\" id=\"account\" required pattern=\"\\b[\\w\\.-]+@[\\w\\.-]+\\.\\w{2,4}\\b\" #accountNgModel=\"ngModel\" [ngModel]=\"account\" (ngModelChange)=\" accountValueChange(accountNgModel.value, accountNgModel.errors) \" /&gt; &lt;span class=\"error-message\"&gt;{{ accountErrorMessage }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;密碼：&lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" required #passwordNgModel=\"ngModel\" [minlength]=\"8\" [maxlength]=\"16\" [ngModel]=\"password\" (ngModelChange)=\" passwordValueChange(passwordNgModel.value, passwordNgModel.errors) \" /&gt; &lt;span class=\"error-message\"&gt;{{ passwordErrorMessage }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=\"submit\" [disabled]=\"form.invalid\"&gt;登入&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 大家有看出來要測什麼了嗎？我來幫大家整理一下要測的項目： 帳號欄位 屬性 type 的值要是 email 屬性 name 的值要是 account 屬性 pattern 的值要是 \\b[\\w\\.-]+@[\\w\\.-]+\\.\\w{2,4}\\b 要有屬性 required 要將 Component 的屬性 account 的值綁定到此欄位上 此欄位的值如果有變動，要能觸發函式 accountValueChange 密碼欄位 屬性 type 的值要是 password 屬性 name 的值要是 password 屬性 minlength 的值要是 8 屬性 maxlength 的值要是 16 要有屬性 required 要將 Component 的屬性 password 的值綁定到此欄位上 此欄位的值如果有變動，要能觸發函式 passwordValueChange 錯誤訊息 要將 Component 的屬性 accountErrorMessage 的值綁定到畫面上 要將 Component 的屬性 passwordErrorMessage 的值綁定到畫面上 登入按鈕 屬性 type 的值要是 submit 當表單是無效的狀態時，要有屬性 disabled 當表單是有效的狀態時，沒有屬性 disabled 當表單是有效狀態時，按下登入按鈕要能觸發函式 login 把要測的項目都列出來之後，有沒有覺得要測的項目很多阿？哈哈！ 不過上面這些我個人列的項目有些其實並不屬於整合測試的範圍，但我個人會在這時候一起測，因為這樣可以省下一些重複的程式碼，而我自己也習慣在寫測試的時候分成 Component/Template 兩塊，而不是單元測試/整合測試，這樣的命名會比較符合實際上在做的事情。 那要怎麼測畫面呢？ 在 beforeEach 裡有個 fixture ，我們在測單元測試的時候，是從這裡取得 Component 的實體。而現在要測畫面，一樣是從 fixture 裡取得 Angular 渲染出來的畫面： 1234567891011121314151617181920212223242526272829303132333435363738import { ComponentFixture, TestBed } from '@angular/core/testing';import { AppComponent } from './app.component';describe('AppComponent', () =&gt; { let component: AppComponent; // 將 fixture 抽出來 let fixture: ComponentFixture&lt;AppComponent&gt;; beforeEach(async () =&gt; { await TestBed.configureTestingModule({ declarations: [AppComponent], imports: [FormsModule] }).compileComponents(); fixture = TestBed.createComponent(AppComponent); component = fixture.componentInstance; }); describe('Unit testing', () =&gt; { // 昨天寫的單元測試... }); describe('Integration testing', () =&gt; { let compiledComponent: HTMLElement; beforeEach(() =&gt; { // 此行的意思是讓 Angular 幫我們將畫面的元素都渲染出來 fixture.detectChanges(); // 取得渲染完之後的元素 compiledComponent = fixture.nativeElement; }); });}); 拿到渲染完的元素之後，接下來要做的事情應該是每個前端工程師都應該要很熟悉的 DOM 操作。 不知道什麼是 DOM 的朋友可能是走錯棚了噢！ 沒錯，在撰寫測試以驗證畫面上的元素時，就是用大家都滾瓜爛熟的 DOM 操作來撰寫，以帳號欄位為例： 12345678910111213141516describe('Integration testing', () =&gt; { let compiledComponent: HTMLElement; beforeEach(() =&gt; { fixture.detectChanges(); compiledComponent = fixture.nativeElement; }); describe('Account input field', () =&gt; { let accountInputElement: HTMLInputElement; beforeEach(() =&gt; { accountInputElement = compiledComponent.querySelector('#account'); }); });}); 如果你的專案有開啟嚴格模式的話（ Angular v12 之後預設開啟），可能會在 accountInputElement 底下看到紅色毛毛蟲： 這是因為 TypeScript 在跟你說，這裡有可能會找不到元素，所以型別有可能會是 null 。 如果我們很有自信它一定找的到、絕對不會是 null 的話，可以在該行結尾加 ! ，像這樣： accountInputElement = compiledComponent.querySelector('#account')! ，就不會有紅色毛毛蟲囉。 帳號欄位的驗證複習一下帳號欄位的驗證項目： 屬性 type 的值要是 email 屬性 name 的值要是 account 屬性 pattern 的值要是 \\b[\\w\\.-]+@[\\w\\.-]+\\.\\w{2,4}\\b 要有屬性 required 要將 Component 的屬性 account 的值綁定到此欄位上 此欄位的值如果有變動，要能觸發函式 accountValueChange 接下來就把帳號欄位要驗證的項目寫成測試案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758describe('Account input field', () =&gt; { let accountInputElement: HTMLInputElement; beforeEach(() =&gt; { accountInputElement = compiledComponent.querySelector('#account')!; }); it('should have attribute \"type\" and the value is \"email\"', () =&gt; { // Arrange const attributeName = 'type'; const attributeValue = 'email'; // Assert expect(accountInputElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"name\" and the value is \"account\"', () =&gt; { // Arrange const attributeName = 'name'; const attributeValue = 'account'; // Assert expect(accountInputElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"pattern\" and the value is \"\\b[\\w\\.-]+@[\\w\\.-]+\\.\\w{2,4}\\b\"', () =&gt; { // Arrange const attributeName = 'pattern'; const attributeValue = '\\\\b[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\\\\.\\\\w{2,4}\\\\b'; // Assert expect(accountInputElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"required\"', () =&gt; { // Arrange const attributeName = 'required'; // Assert expect(accountInputElement.hasAttribute(attributeName)).toBe(true); }); it('should binding the value of property \"account\"', () =&gt; { // Arrange const account = 'whatever'; // Act component.account = account; fixture.detectChanges(); // Assert expect(accountInputElement.getAttribute('ng-reflect-model')).toBe(account); }); it('should trigger function \"accountValueChange\" when the value be changed', () =&gt; { // Arrange spyOn(component, 'accountValueChange'); // Act accountInputElement.value = 'whatever'; accountInputElement.dispatchEvent(new Event('ngModelChange')); // Assert expect(component.accountValueChange).toHaveBeenCalled(); });}); 測試結果： 在這些測試案例裡，比較特別需要說明的是： should trigger function &quot;accountValueChange&quot; when the value be changed 這個測試案例，怎麼說呢？ 大家應該都有發現在這個測試案例裡，有使用一個叫做 spyOn 的函式，這個函式的第一個參數是一個物件，第二個參數是這個物件裡的函式的名字。 這個函式的用意是，它會把該物件裡我們所指定的函式替換成一個叫做 Spy 的物件，讓後續如果有人執行該函式時，實際執行的會是我們替換掉的 Spy 物件，而不是原本我們寫的那個函式，這樣才能在後續去驗證該函式是否已經被呼叫過，甚至還可以知道被呼叫的次數、被呼叫時所傳入的參數等等。 這個方式是大家在寫測試時所慣用的手法。在這個測試案例裡，我們只在意該函式是不是有被觸發，不在意該函式的實際執行結果，因為該函式的實際執行結果已經在寫單元測試的時候驗證過了，而整合測試的部份所在意的是互動行為。 關於測試的替身，可以參考此篇網路文章：Unit Test 中的替身：搞不清楚的Dummy 、Stub、Spy、Mock、Fake 不過這個測試案例其實有個美中不足的地方，因為嚴格來說我們必須要驗證在該函式被呼叫的時候有傳入 accountNgModel.value 與 accountNgModel.errors ，但因為這個物件是透過 Angular 的範本語法去產生出來的，如果要抓到它需要在 Component 裡新增一個屬性，並使用 Angular 的裝飾器 @ViewChild() 來幫我們把這個物件抓出來： 1234export class AppComponent { @ViewChild('accountNgModel') accountNgModelRef!: NgModel; // ...} 如此就能改用 toHaveBeenCalledWith 來驗證： 12345678910it('should trigger function \"accountValueChange\" when the value be changed', () =&gt; { // Arrange spyOn(component, 'accountValueChange'); const accountNgModel = component.accountNgModelRef; // Act accountInputElement.value = 'whatever'; accountInputElement.dispatchEvent(new Event('ngModelChange')); // Assert expect(component.accountValueChange).toHaveBeenCalledWith(accountNgModel.value, accountNgModel.errors);}); 除了這個測試案例大家可能會不習慣之外，其他的測試看起來滿簡單的對吧？！ 密碼欄位的驗證帳號欄位的測試寫完之後，再來就輪到密碼欄位的部分囉！ 複習一下密碼欄位的驗證項目： 屬性 type 的值要是 password 屬性 name 的值要是 password 屬性 minlength 的值要是 8 屬性 maxlength 的值要是 16 要有屬性 required 要將 Component 的屬性 password 的值綁定到此欄位上 此欄位的值如果有變動，要能觸發函式 passwordValueChange 測試程式碼如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667describe('Password input field', () =&gt; { let passwordInputElement: HTMLInputElement; beforeEach(() =&gt; { passwordInputElement = compiledComponent.querySelector('#password')!; }); it('should have attribute \"type\" and the value is \"password\"', () =&gt; { // Arrange const attributeName = 'type'; const attributeValue = 'password'; // Assert expect(passwordInputElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"name\" and the value is \"password\"', () =&gt; { // Arrange const attributeName = 'name'; const attributeValue = 'password'; // Assert expect(passwordInputElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"minlength\" and the value is \"8\"', () =&gt; { // Arrange const attributeName = 'minlength'; const attributeValue = '8'; // Assert expect(passwordInputElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"maxlength\" and the value is \"16\"', () =&gt; { // Arrange const attributeName = 'maxlength'; const attributeValue = '16'; // Assert expect(passwordInputElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"required\"', () =&gt; { // Arrange const attributeName = 'required'; // Assert expect(passwordInputElement.hasAttribute(attributeName)).toBe(true); }); it('should binding the value of property \"password\"', () =&gt; { // Arrange const password = 'whatever'; // Act component.password = password; fixture.detectChanges(); // Assert expect(passwordInputElement.getAttribute('ng-reflect-model')).toBe(password); }); it('should trigger function \"passwordValueChange\" when the value be changed', () =&gt; { // Arrange spyOn(component, 'passwordValueChange'); const passwordNgModel = component.passwordNgModelRef; // Act passwordInputElement.value = 'whatever'; passwordInputElement.dispatchEvent(new Event('ngModelChange')); // Assert expect(component.passwordValueChange).toHaveBeenCalledWith(passwordNgModel.value, passwordNgModel.errors); });}); 密碼欄位的部份基本上跟帳號欄位差不多，只有一兩個屬性不一樣而已。 測試結果： 錯誤訊息的驗證錯誤訊息的驗證也非常簡單，真要說個比較難的地方，大概就是對於 CSS Selector 的熟悉程度吧！ 錯誤訊息要驗證的項目是： 要將 Component 的屬性 accountErrorMessage 的值綁定到畫面上 要將 Component 的屬性 passwordErrorMessage 的值綁定到畫面上 測試程式碼如下： 1234567891011121314151617181920212223describe('Error Message', () =&gt; { it('should binding the value of property \"accountErrorMessage\" in the template', () =&gt; { // Arrange const errorMessage = 'account error'; const targetElement = compiledComponent.querySelector('#account + .error-message'); // Act component.accountErrorMessage = errorMessage; fixture.detectChanges(); // Assert expect(targetElement?.textContent).toBe(errorMessage); }); it('should binding the value of property \"passwordErrorMessage\" in the template', () =&gt; { // Arrange const errorMessage = 'password error'; const targetElement = compiledComponent.querySelector('#password + .error-message'); // Act component.passwordErrorMessage = errorMessage; fixture.detectChanges(); // Assert expect(targetElement?.textContent).toBe(errorMessage); });}); 如果你對於 CSS Selector 真的不熟，就在要驗的元素上增加你可以找到的 ID 、類別或者是屬性吧！ 測試結果： 登入按鈕的驗證最後是登入按鈕的驗證，它的驗證項目是： 屬性 type 的值要是 submit 當表單是無效的狀態時，要有屬性 disabled 當表單是有效的狀態時，沒有屬性 disabled 當表單是有效狀態時，按下登入按鈕要能觸發函式 login 程式碼如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546describe('Login button', () =&gt; { let buttonElement: HTMLButtonElement; beforeEach(() =&gt; { buttonElement = compiledComponent.querySelector('button')!; }); it('should have attribute \"type\" and the value is \"submit\"', () =&gt; { // Arrange const attributeName = 'type'; const attributeValue = 'submit'; // Assert expect(buttonElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"disabled\" when the form\\'s status is invalid', () =&gt; { // Arrange const attributeName = 'disabled'; // Assert expect(buttonElement.hasAttribute(attributeName)).toBe(true); }); describe('When the form\\'s status is valid', () =&gt; { beforeEach(() =&gt; { component.account = 'abc@email.com'; component.password = '12345678'; fixture.detectChanges(); }); it('should not have attribute \"disabled\"', () =&gt; { // Arrange const attributeName = 'disabled'; // Assert expect(buttonElement.hasAttribute(attributeName)).toBe(false); }); it('should trigger function \"login\" when being clicked', () =&gt; { // Arrange spyOn(component, 'login'); // Act buttonElement.click(); // Assert expect(component.login).toHaveBeenCalled(); }); });}); 測試結果： 咦？怎麼會有 Error 咧？我自己在第一次遇到這個狀況也是有點傻眼，於是我深入調查了之後發現： 原來是因為 Karma 渲染出來的元素跟 Angular 渲染出來的元素狀態不一樣，Karma 渲染出來的 form 元素跟沒有正確吃到底下的表單欄位： 關於這個問題，我會再發 issue 詢問官方，如果後續有任何消息，我會再更新此篇文章讓大家知道。 至於目前這個案例，我們可以先在 it 的前面加上一個 x ，代表我們要 ignore 這個案例的意思，像這樣： 123456xit('should have attribute \"disabled\" when the form\\'s status is invalid', () =&gt; { // Arrange const attributeName = 'disabled'; // Assert expect(buttonElement.hasAttribute(attributeName)).toBe(true);}); 測試結果： 至此，我們就完成了整合測試的部份囉！雖然剛好遇到奇怪的問題，但學習如何排除異常也是非常重要的一部分噢！ 今天的文章就到這邊，明天我們要為用 Reactive Forms 所撰寫的登入表單來撰寫單元測試，不過我其實昨天其實就教過大家怎麼寫單元測試，在看我的文章之前，建議大家先自己寫寫看再參考我的文章，相信一定會有更多的收穫！ 本日小結再次提醒大家，在寫整合測試時，需要測試的是兩個類別實體之間在各種情況下的互動行為是否符合我們的預期，跟單元測試要測試的重點是很不一樣的。 除此之外，就算我們是在寫整合測試不是單元測試，但依然要盡量做到我在如何寫出優秀的測試？文中所提到的部份噢！ 我會將今日的實作程式碼放在 Github - Branch: day7 供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，也都非常歡迎留言給我讓我知道噢！","link":"/2021/09/22/angular-30days-form-and-test-07/"},{"title":"Angular 深入淺出三十天：表單與測試 Day08 - 單元測試實作 - 登入系統 by Reactive Forms","text":"今天我們要來為我們用 Reactive Forms 所撰寫的登入系統寫單元測試，如果還沒有相關程式碼的朋友，趕快前往閱讀第三天的文章： Reactive Forms 實作 - 以登入為例。 實作開始前置作業基本上都跟第六天的文章：單元測試實作 - 登入系統 by Template Driven Forms 相同，今天就不會再贅述，大家如果忘記怎麼做可以先回去複習一下。 目前的程式碼： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849export class AppComponent { formGroup: FormGroup | undefined; get accountControl(): FormControl { return this.formGroup!.get('account') as FormControl; } get passwordControl(): FormControl { return this.formGroup!.get('password') as FormControl; } constructor(private formBuilder: FormBuilder) {} ngOnInit(): void { this.formGroup = this.formBuilder.group({ account: [ '', [ Validators.required, Validators.pattern(/^\\b[\\w\\.-]+@[\\w\\.-]+\\.\\w{2,4}\\b$/gi) ] ], password: [ '', [Validators.required, Validators.minLength(8), Validators.maxLength(16)] ] }); } getErrorMessage(formControl: FormControl): string { let errorMessage = ''; if (!formControl.errors || formControl.pristine) { errorMessage = ''; } else if (formControl.errors.required) { errorMessage = '此欄位必填'; } else if (formControl.errors.pattern) { errorMessage = '格式有誤，請重新輸入'; } else if (formControl.errors.minlength) { errorMessage = '密碼長度最短不得低於8碼'; } else if (formControl.errors.maxlength) { errorMessage = '密碼長度最長不得超過16碼'; } return errorMessage; } login(): void { // do login... }} 以目前的程式碼來看，基本上我們只要驗 getErrorMessage 這個函式，不過我們其實也能驗 ngOnInit 這個 Angular Component Lifecycle Hook 的執行結果，畢竟它也是個函式，我們一樣可以寫測試去驗證這個函式的執行結果是否符合我們的預期。 關於 Angular Component Lifecycle Hook ，如果想知道更多可以閱讀官方文件： Component Lifecycle hooks 測試單元 - getErrorMessage我們一樣先加一個 describe ，表明在這裡面的測試案例都是在測 getErrorMessage 這個函式： 1234567describe('AppComponent', () =&gt; { // ... describe('getErrorMessage', () =&gt; { // 這裡面的測試案例都是要測這個函式 });}); 接著統整一下這個 getErrorMessage 的函式裡會遇到的情況： 如果傳入的 formControl 裡沒有任何 error ，則會取得空字串。 如果傳入的 formControl 的屬性 pristine 的值為 true ，則會取得空字串。 如果傳入的 formControl 裡有必填的錯誤： required ，則會取得錯誤訊息 此欄位必填。 如果傳入的 formControl 裡有格式的錯誤： pattern ，則會取得錯誤訊息 格式有誤，請重新輸入。 如果傳入的 formControl 裡有最小長度的錯誤： minlength ，則會取得錯誤訊息 密碼長度最短不得低於8碼。 如果傳入的 formControl 裡有最大長度的錯誤： maxlength ，則會取得錯誤訊息 密碼長度最長不得超過16碼。 統整完之後，就可以將上述情況寫成測試案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465describe('getErrorMessage', () =&gt; { it('should get empty string when the value is correct', () =&gt; { // Arrange const formControl = new FormControl(''); const expectedMessage = ''; // Act const message = component.getErrorMessage(formControl); // Assert expect(message).toBe(expectedMessage); }); it('should get empty string when the value is empty string but the form control is pristine', () =&gt; { // Arrange const formControl = new FormControl('', [Validators.required]); const expectedMessage = ''; // Act const message = component.getErrorMessage(formControl); // Assert expect(message).toBe(expectedMessage); }); it('should get \"此欄位必填\" when the value is empty string but the form control', () =&gt; { // Arrange const formControl = new FormControl('', [Validators.required]); const expectedMessage = '此欄位必填'; // Act formControl.markAsDirty(); const message = component.getErrorMessage(formControl); // Assert expect(message).toBe(expectedMessage); }); it('should get \"格式有誤，請重新輸入\" when the value is empty string but the form control', () =&gt; { // Arrange const formControl = new FormControl('whatever', [Validators.pattern('/^\\b[\\w\\.-]+@[\\w\\.-]+\\.\\w{2,4}\\b$/gi')]); const expectedMessage = '格式有誤，請重新輸入'; // Act formControl.markAsDirty(); const message = component.getErrorMessage(formControl); // Assert expect(message).toBe(expectedMessage); }); it('should get \"密碼長度最短不得低於8碼\" when the value is empty string but the form control', () =&gt; { // Arrange const formControl = new FormControl('abc', [Validators.minLength(8)]); const expectedMessage = '密碼長度最短不得低於8碼'; // Act formControl.markAsDirty(); const message = component.getErrorMessage(formControl); // Assert expect(message).toBe(expectedMessage); }); it('should get \"密碼長度最長不得超過16碼\" when the value is empty string but the form control', () =&gt; { // Arrange const formControl = new FormControl('12345678901234567', [Validators.maxLength(16)]); const expectedMessage = '密碼長度最長不得超過16碼'; // Act formControl.markAsDirty(); const message = component.getErrorMessage(formControl); // Assert expect(message).toBe(expectedMessage); });}); 從上面的程式碼中可以看出，我這次寫單元測試的策略是：讓每個案例自己配置足以驗證該案例的 formControl 與其必須的 Validators 即可。 也就是說，當我需要驗證 此欄位必填 的錯誤訊息時，我只需要配置 Validators.required 給 formControl ；當我需要驗證 密碼長度最短不得低於8碼 的錯誤訊息時，我只需要配置 Validators.minlength(8) 給 formControl ，依此類推。 會這樣寫是因為我們只需要專注在什麼樣子的 errors 會得到什麼樣子的錯誤訊息上面，當然大家也可以每次都幫 formControl 配置最完整的 Validators ，這兩個方法我覺得都可以。 此外，由於我們這次有判斷 formControl 的狀態： pristine ，因此在寫測試的時候要特別留意，記得要先 markAsDirty 之後才能測試噢！ 上一次寫單元測試的文章： 單元測試實作 - 登入系統 by Template Driven Forms。 測試結果： 測試單元 - ngOnInit再來是 ngOnInit 的部份， ngOnInit 要驗證的項目跟 formGroup 滿相關，所以我打算用 formGroup 當測試集合的名稱，具體要驗證的項目有： 在 ngOnInit 執行之前， formGroup 是 undefined 的狀況。 在 ngOnInit 執行之後， formGroup 是類型為 FormGroup 的實體。 formGroup 裡要有兩個 FormControl 。 accountFormControl 要有必填的驗證 要有 Email 格式的驗證 passwordFormControl 要有必填的驗證 要有字串最小長度為 8 的驗證 要有字串最大長度為 16 的驗證 程式碼如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172describe('formGroup', () =&gt; { it('should be undefined before init', () =&gt; { // Assert expect(component.formGroup).toBeFalsy(); }); describe('after ngInit', () =&gt; { beforeEach(() =&gt; { fixture.detectChanges(); }); it('should be instance of FormGroup', () =&gt; { // Assert expect(component.formGroup).toBeInstanceOf(FormGroup); }); it('should have 2 form controls', () =&gt; { // Arrange const formControls = component.formGroup!.controls; const controlLength = Object.keys(formControls).length; // Assert expect(controlLength).toBe(2); }); describe('accountFormControl', () =&gt; { it('should have the required validator', () =&gt; { // Arrange const error = component.accountControl.errors!; // Assert expect(error.required).toBe(true); }); it('should have the email pattern validator', () =&gt; { // Arrange component.accountControl.setValue('abc'); const error = component.accountControl.errors!; const expectedPattern = '/^\\\\b[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\\\\.\\\\w{2,4}\\\\b$/gi'; // Assert expect(error.pattern.requiredPattern).toBe(expectedPattern); }); }); describe('passwordFormControl', () =&gt; { it('should have the required validator', () =&gt; { // Arrange const error = component.accountControl.errors!; // Assert expect(error.required).toBe(true); }); it('should have the min-length validator', () =&gt; { // Arrange component.passwordControl.setValue('abc'); const error = component.passwordControl.errors!; // Assert expect(error.minlength.requiredLength).toBe(8); }); it('should have the max-length validator', () =&gt; { // Arrange component.passwordControl.setValue('12345678901234567'); const error = component.passwordControl.errors!; // Assert expect(error.maxlength.requiredLength).toBe(16); }); }); });}); 此處比較特別的地方是，我在 after ngInit 的 beforeEach 裡是用 fixture.detectChanges() 來觸發 ngOnInit() ，而不是使用 component.ngOnInit() 的方式來觸發，這是因為我認為我們在寫的是 Angular ，而這個 Lifecycle Hook 又是 Angular 的東西，所以使用 Angular 的機制來觸發會比直接使用該函式觸發來的好。 當然也是可以直接使用 component.ngOnInit() 來觸發，在測試的驗證結果上其實不會有什麼不同，所以用哪個方式其實都可以。 測試結果： 本日小結已經寫了兩次的測試，相信大家對於測試的熟悉度已經有顯著地提昇，而今天的重點主要會是在使用 FormControl markAsDirty 來改變欄位的狀態，以及了解 fixture.detectChanges 與 ngOnInit 的關係，未來在寫測試的時候，這兩點也是非常需要多加留意的。 今日的實作程式碼一樣會放在 Github - Branch: day8 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，也都非常歡迎留言給我讓我知道噢！","link":"/2021/09/23/angular-30days-form-and-test-08/"},{"title":"Angular 深入淺出三十天：表單與測試 Day10 - Template Driven Forms 實作 - 動態表單初體驗","text":"今天要來用 Template Driven Forms 的方式實作一個很簡易的動態表單，使用上有點像是保險業者的系統，可以新增多名被保人，也可以編輯與刪除被保人。 具體的規格需求如下： 被保險人的欄位： 姓名（文字輸入框） 最少需要填寫兩個字，如驗證有誤則顯示錯誤訊息姓名至少需兩個字以上 最多只能填寫十個字 性別（單選） 選項：男性、女性 年齡（下拉選單） 選項： 18 歲、 20 歲、 70 歲、 75 歲 以上欄位皆為必填，如驗證有誤則顯示錯誤訊息此欄位為必填 以上驗證皆需在使用者輸入時動態檢查 按下新增被保險人按鈕可以新增被保險人 按下刪除被保險人按鈕可以刪除被保險人 任一驗證有誤時，送出按鈕皆呈現不可被點選之狀態 沒有被保險人時，送出按鈕皆呈現不可被點選之狀態 規格需求看清楚之後，我們就來開始實作吧！ 開始實作首先我們先準備好基本的 HTML ： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;被保人&lt;/legend&gt; &lt;p&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" name=\"name\" id=\"name\" required maxlength=\"10\" minlength=\"2\" /&gt; &lt;span class=\"error-message\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 性別： &lt;input type=\"radio\" name=\"gender\" id=\"male\" value=\"male\"&gt; &lt;label for=\"male\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" name=\"gender\" id=\"female\" value=\"female\"&gt; &lt;label for=\"female\"&gt;女&lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"age\"&gt;年齡：&lt;/label&gt; &lt;select name=\"age\" id=\"age\" required&gt; &lt;option value=\"\"&gt;請選擇&lt;/option&gt; &lt;option value=\"18\"&gt;18歲&lt;/option&gt; &lt;option value=\"20\"&gt;20歲&lt;/option&gt; &lt;option value=\"70\"&gt;70歲&lt;/option&gt; &lt;option value=\"75\"&gt;75歲&lt;/option&gt; &lt;/select&gt; &lt;span class=\"error-message\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;button type=\"button\"&gt;刪除&lt;/button&gt;&lt;/p&gt; &lt;/fieldset&gt; &lt;p&gt; &lt;button type=\"button\"&gt;新增被保險人&lt;/button&gt; &lt;button type=\"submit\"&gt;送出&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 未經美化的畫面應該會長這樣： 基本的 HTML 準備好之後，我建議對於 Angular 還沒那麼熟悉的朋友先不要一口氣就想要直接把它做成動態的，先把它當成靜態表單來做會比較簡單一些。 因此，我們先準備相關的屬性與方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import { Component } from '@angular/core';import { ValidationErrors } from '@angular/forms';@Component({ selector: 'app-template-driven-forms-async-insured', templateUrl: './template-driven-forms-async-insured.component.html', styleUrls: ['./template-driven-forms-async-insured.component.scss']})export class TemplateDrivenFormsAsyncInsuredComponent { // 綁在姓名欄位上 name = ''; // 綁在性別欄位上 gender = ''; // 綁在年齡欄位上 age = ''; // 姓名欄位的錯誤訊息 nameErrorMessage = ''; // 年齡欄位的錯誤訊息 ageErrorMessage = ''; /** * 綁定在姓名欄位上，當使用者改變被保險人的姓名時，會觸發此函式，並取得對應的錯誤訊息 * * @param {string} name * @param {ValidationErrors | null} errors * @memberof TemplateDrivenFormsAsyncInsuredComponent */ insuredNameChange(name: string, errors: ValidationErrors | null): void { this.name = name; this.nameErrorMessage = this.getErrorMessage(errors); } /** * 綁定在年齡欄位上，當使用者改變被保險人的年齡時，會觸發此函式，並取得對應的錯誤訊息 * * @param {string} age * @param {ValidationErrors | null} errors * @memberof TemplateDrivenFormsAsyncInsuredComponent */ insuredAgeChange(age: string, errors: ValidationErrors | null): void { this.age = age; this.ageErrorMessage = this.getErrorMessage(errors); } /** * 綁定在表單上，當按下送出按鈕時會觸發此函式 * * @memberof TemplateDrivenFormsAsyncInsuredComponent */ submit(): void { // do submit... } /** * 根據 FormControl 的 errors 屬性取得相應的錯誤訊息 * * @private * @param {ValidationErrors | null} errors - FormControl 的 errors * @return {*} {string} * @memberof TemplateDrivenFormsAsyncInsuredComponent */ private getErrorMessage(errors: ValidationErrors | null): string { let errorMessage = ''; if (errors?.required) { errorMessage = '此欄位必填'; } else if (errors?.minlength) { errorMessage = '姓名至少需兩個字以上'; } return errorMessage; }} 準備好相關的屬性和方法之後，我們直接把他們跟 Template 綁定： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;form (ngSubmit)=\"submit()\"&gt; &lt;fieldset&gt; &lt;legend&gt;被保人&lt;/legend&gt; &lt;p&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" name=\"name\" id=\"name\" required maxlength=\"10\" minlength=\"2\" #nameNgModel=\"ngModel\" [ngModel]=\"name\" (ngModelChange)=\"insuredNameChange(nameNgModel.value, nameNgModel.errors)\" /&gt; &lt;span class=\"error-message\"&gt;{{ nameErrorMessage }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 性別： &lt;input type=\"radio\" name=\"gender\" id=\"male\" value=\"male\" required [(ngModel)]=\"gender\" &gt; &lt;label for=\"male\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" name=\"gender\" id=\"female\" value=\"female\" required [(ngModel)]=\"gender\" &gt; &lt;label for=\"female\"&gt;女&lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"age\"&gt;年齡：&lt;/label&gt; &lt;select name=\"age\" id=\"age\" required #ageNgModel=\"ngModel\" [ngModel]=\"age\" (ngModelChange)=\"insuredAgeChange(ageNgModel.value, ageNgModel.errors)\" &gt; &lt;option value=\"\"&gt;請選擇&lt;/option&gt; &lt;option value=\"18\"&gt;18歲&lt;/option&gt; &lt;option value=\"20\"&gt;20歲&lt;/option&gt; &lt;option value=\"70\"&gt;70歲&lt;/option&gt; &lt;option value=\"75\"&gt;75歲&lt;/option&gt; &lt;/select&gt; &lt;span class=\"error-message\"&gt;{{ ageErrorMessage }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;button type=\"button\"&gt;刪除&lt;/button&gt;&lt;/p&gt; &lt;/fieldset&gt; &lt;p&gt; &lt;button type=\"button\"&gt;新增被保險人&lt;/button&gt; &lt;button type=\"submit\"&gt;送出&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 從目前的程式碼應該不難發現，大體上跟我們第二天的實作內容差不多、結構也差不多，應該沒有什麼難度。 如果大家在這邊有遇到問題，大致上可以檢查看看自己有沒有引入 FormsModule ，抑或者是表單欄位上是否有 name 屬性，我就不再贅述囉。 目前的結果： 有了基本的互動效果之後，我們就可以開始來思考怎麼樣把這個表單變成動態的。 相信大家一定知道，既然我們要讓被保人可以被新增或刪除，表示我們應該是會用陣列來存放這些被保人的資料，所以我們可以先將這些我們需要的資料欄位定義一個型別以便後續使用。 像是這樣： 1234567export type Insured = { name: string; gender: string; age: number; nameErrorMessage: string; ageErrorMessage: string;}; 或者是這樣： 1234567export interface Insured { name: string; gender: string; age: number; nameErrorMessage: string; ageErrorMessage: string;}; 甚至是這樣： 1234567export class Insured { name: string; gender: string; age: string; nameErrorMessage: string; ageErrorMessage: string;}; 這三種定義型別的方式基本上都可以，我就不多解釋他們之間的差異了，我個人近期是滿喜歡用第一種的。 接著我們就可以將原本那些單個的屬性拿掉，改成用陣列的方式，像是這樣： 1234567891011121314151617181920// 以上省略...import { Insured } from './insured.type';@Component({ // 省略...})export class TemplateDrivenFormsAsyncInsuredComponent { // 被保險人清單 insuredList: Insured[] = []; // 以下這些都可以移除 // name = ''; // gender = ''; // age = ''; // nameErrorMessage = ''; // ageErrorMessage = ''; // 以下省略...} 這些單個的屬性移除掉之後，原本有使用到它們的部分就會壞掉，所以我們要將它們改為使用傳進來的被保人的資料，像這樣： 123456789101112131415161718192021222324252627282930313233343536373839// 以上省略...import { Insured } from './insured.type';@Component({ // 省略...})export class TemplateDrivenFormsAsyncInsuredComponent { // 被保險人清單 insuredList: Insured[] = []; /** * 綁定在姓名欄位上，當使用者改變被保險人的姓名時，會觸發此函式，並取得對應的錯誤訊息 * * @param {string} name * @param {ValidationErrors | null} errors * @param {Insured} insured * @memberof TemplateDrivenFormsAsyncInsuredComponent */ insuredNameChange(name: string, errors: ValidationErrors | null, insured: Insured): void { insured.name = name; insured.nameErrorMessage = this.getErrorMessage(errors); } /** * 綁定在年齡欄位上，當使用者改變被保險人的年齡時，會觸發此函式，並取得對應的錯誤訊息 * * @param {string} age * @param {ValidationErrors | null} errors * @param {Insured} insured * @memberof TemplateDrivenFormsAsyncInsuredComponent */ insuredAgeChange(age: string, errors: ValidationErrors | null, insured: Insured): void { insured.age = age; insured.ageErrorMessage = this.getErrorMessage(errors); } // 以下省略...} 接著我們就可以到 Template 裡，將所有被保人的資料用 *ngFor 的方式迴圈出來，並將原本用單個屬性綁定的部份也改為綁定迴圈出來的被保人資料： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;form (ngSubmit)=\"submit()\"&gt; &lt;!-- 將所有被保人的資料迴圈出來 --&gt; &lt;fieldset *ngFor=\"let insured of insuredList\"&gt; &lt;legend&gt;被保人&lt;/legend&gt; &lt;p&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;!-- 改為綁定被迴圈出來的被保人資料，並將其傳入函式內 --&gt; &lt;input type=\"text\" name=\"name\" id=\"name\" required maxlength=\"10\" minlength=\"2\" #nameNgModel=\"ngModel\" [ngModel]=\"insured.name\" (ngModelChange)=\"insuredNameChange(nameNgModel.value, nameNgModel.errors, insured)\" /&gt; &lt;span class=\"error-message\"&gt;{{ insured.nameErrorMessage }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 性別： &lt;!-- 改為綁定被迴圈出來的被保人資料 --&gt; &lt;input type=\"radio\" name=\"gender\" id=\"male\" value=\"male\" required [(ngModel)]=\"insured.gender\" &gt; &lt;label for=\"male\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" name=\"gender\" id=\"female\" value=\"female\" required [(ngModel)]=\"insured.gender\" &gt; &lt;label for=\"female\"&gt;女&lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"age\"&gt;年齡：&lt;/label&gt; &lt;!-- 改為綁定被迴圈出來的被保人資料，並將其傳入函式內 --&gt; &lt;select name=\"age\" id=\"age\" required #ageNgModel=\"ngModel\" [ngModel]=\"insured.age\" (ngModelChange)=\"insuredAgeChange(ageNgModel.value, ageNgModel.errors, insured)\" &gt; &lt;option value=\"\"&gt;請選擇&lt;/option&gt; &lt;option value=\"18\"&gt;18歲&lt;/option&gt; &lt;option value=\"20\"&gt;20歲&lt;/option&gt; &lt;option value=\"70\"&gt;70歲&lt;/option&gt; &lt;option value=\"75\"&gt;75歲&lt;/option&gt; &lt;/select&gt; &lt;span class=\"error-message\"&gt;{{ insured.ageErrorMessage }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;button type=\"button\"&gt;刪除&lt;/button&gt;&lt;/p&gt; &lt;/fieldset&gt; &lt;p&gt; &lt;button type=\"button\"&gt;新增被保險人&lt;/button&gt; &lt;button type=\"submit\"&gt;送出&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 接著我們就可以儲存以查看目前的結果： 咦？！怎麼表單欄位不見了？！ 別緊張，這是因為 insuredList 現在是個空陣列呀！ 接下來我們再加個新增被保險人與刪除被保險人的函式： 12345678910111213141516171819202122232425/** * 新增被保險人 * * @memberof TemplateDrivenFormsAsyncInsuredComponent */addInsured(): void { const insured: Insured = { name: '', gender: '', age: '', nameErrorMessage: '', ageErrorMessage: '' }; this.insuredList.push(insured);}/** * 刪除被保險人 * * @param {number} index * @memberof TemplateDrivenFormsAsyncInsuredComponent */deleteInsured(index: number): void { this.insuredList.splice(index, 1);} 然後把它們綁定到按鈕上，並且在 *ngFor 裡新增索引的宣告，以供刪除時使用 ： 12345678910&lt;form (ngSubmit)=\"submit()\"&gt; &lt;fieldset *ngFor=\"let insured of insuredList; let index = index\"&gt; &lt;!-- 中間省略... --&gt; &lt;p&gt;&lt;button type=\"button\" (click)=\"deleteInsured(index)\"&gt;刪除&lt;/button&gt;&lt;/p&gt; &lt;/fieldset&gt; &lt;p&gt; &lt;button type=\"button\" (click)=\"addInsured()\"&gt;新增被保險人&lt;/button&gt; &lt;button type=\"submit\"&gt;送出&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 結果： 雖然我們的表單就差不多快完成了，但其實我們的表單目前有兩個問題，不曉得大家有沒有發現？ 問題一 對專業的前端工程師來說，我們做出來的表單一定要讓人家有良好的使用者體驗。 為此，我們通常會使用一些 HTML 的屬性來讓我們的表單更為人性化，像是在 label 上加 for 。 但問題來了， for 要跟 id 搭配使用，但 id 一整頁只會有一個，而我們可能會有 N 個被保險人，怎辦？ 這時候我們可以善用陣列的索引值來幫我們達成這個目的，像是這樣： 123456789101112&lt;label [for]=\"'name-' + index\"&gt;姓名：&lt;/label&gt;&lt;input type=\"text\" [name]=\"'name-' + index\" [id]=\"'name-' + index\" required maxlength=\"10\" minlength=\"2\" #nameNgModel=\"ngModel\" [ngModel]=\"insured.name\" (ngModelChange)=\"insuredNameChange(nameNgModel.value, nameNgModel.errors, insured)\"/&gt; 我知道很醜，但沒辦法，這是天生的侷限。 對了， name 屬性也要噢！因為表單裡的 name 也是唯一性的。 問題二 這個問題是因為在畫面重新渲染完之後， NgForm 裡面 Key 值為 xxx-0 的 NgModel 們就不見了，只留下 xxx-1 的 NgModel 們。在這之後如果再按新增被保人時，由於新增的那一筆的索引是 1 ，就又會把原本留下的 Key 值為 xxx-1 的 NgModel 們蓋掉，導致大家現在所看到的情況。 解決方式其實說難不難，因為其實 *ngFor 有個 trackBy 的參數，只要傳入這個參數就可以解決這個問題。但說簡單也不簡單，不知道原因跟解法的人就會卡上一段時間。 其實我一開始也卡住，還跟社群的人求救，進而引出一大串的討論（笑）。 方式是先在 .ts 裡加一個函式： 12345678910/** * 根據索引來重新渲染有更改的節點 * * @param {string} index * @return {*} {number} * @memberof AppComponent */trackByIndex(index: number): number { return index;} 然後在 *ngFor 的後面加上： 1&lt;fieldset *ngFor=\"let insured of insuredList; let index = index; trackBy: trackByIndex\"&gt; 這樣就可以解決我們的問題了！ 最後，我們就剩以下兩項事情還沒做： 任一驗證有誤時，送出按鈕皆呈現不可被點選之狀態 沒有被保險人時，送出按鈕皆呈現不可被點選之狀態 這兩件事情基本上可以看成同一件事情 ─ 判斷表單是否無效。 怎麼判斷呢？ 大家記不記得上次有用到一個類別叫做 NgForm ，當表單內的驗證有誤時， NgForm 的屬性 invalid 就會為 true 。 所以我們一樣可以利用它來幫我們判斷，像這樣： 123456789&lt;form #form=\"ngForm\" (ngSubmit)=\"submit()\"&gt; &lt;fieldset *ngFor=\"let insured of insuredList; let index = index\"&gt; &lt;!-- 中間省略... --&gt; &lt;/fieldset&gt; &lt;p&gt; &lt;button type=\"button\" (click)=\"addInsured()\"&gt;新增被保險人&lt;/button&gt; &lt;button type=\"submit\" [disabled]=\"insuredList.length === 0 || form.invalid\"&gt;送出&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 結果： 本日小結今天的學習重點主要是在練習如何讓靜態的表單變成動態，雖然沒有多複雜，但可能也是會難倒大部分的初學者。 其實大體上的邏輯跟實作登入時是差不多的，大家之所以會卡住主要可能會是因為不知道如何讓靜態表單變成動態，而以 Template Driven Forms 的方式來說，滿多程式碼都會綁在 Template 上，大家在實作時要看清楚才不會出錯。 至於程式碼的部份我一樣會放在 Github - Branch: day10 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，也都非常歡迎留言給我讓我知道噢！","link":"/2021/09/25/angular-30days-form-and-test-10/"},{"title":"Angular 深入淺出三十天：表單與測試 Day09 - 整合測試實作 - 登入系統 by Reactive Forms","text":"昨天幫我們用 Reactive Forms 所撰寫的登入系統寫完單元測試之後，今天則是要來為它寫整合測試。 再次幫大家複習一下整合測試的測試目標： 整合測試的測試目標是要測試兩個或是兩個以上的類別之間的互動是否符合我們的預期。 如果對於整合測試在測什麼還沒有概念的話，建議大家先回到第七天的文章複習一下：整合測試實作 - 登入系統 by Template Driven Forms 。 實作開始跟上次一樣先增加一個 describe 的區塊，有關於整合測試的程式碼接下來都會放在這裡面： 12345678910111213141516171819202122232425262728import { TestBed } from '@angular/core/testing';import { AppComponent } from './app.component';describe('AppComponent', () =&gt; { let component: AppComponent; beforeEach(async () =&gt; { await TestBed.configureTestingModule({ declarations: [AppComponent], imports: [ FormsModule, ReactiveFormsModule ] }).compileComponents(); const fixture = TestBed.createComponent(AppComponent); component = fixture.componentInstance; }); describe('Unit testing', () =&gt; { // 昨天寫的單元測試... }); describe('Integration testing', () =&gt; { // 今天要寫的整合測試 });}); 一般我們不會特別將單元測試跟整合測試的程式碼分開檔案來寫，只會用測試集合將其區隔。 上次有提到整合測試跟畫面會比較有相關，但這次因為我們有使用到第二個類別 FormBuilder ，所以我們先來看 xxxx.component.ts 的程式碼： 123456789101112131415161718192021222324export class AppComponent { // 以上省略... constructor(private formBuilder: FormBuilder) {} ngOnInit(): void { this.formGroup = this.formBuilder.group({ account: [ '', [ Validators.required, Validators.pattern(/^\\b[\\w\\.-]+@[\\w\\.-]+\\.\\w{2,4}\\b$/gi) ] ], password: [ '', [Validators.required, Validators.minLength(8), Validators.maxLength(16)] ] }); } // 以下省略...} 以整合測試要驗證的項目來說，這邊其實可以驗在 ngOnInit 被呼叫時， formBuilder 的 group 函式有沒有被呼叫，像是這樣： 123456789it('should call function \"group\" of the \"FormBuilder\" when function \"ngOnInit\" be trigger', () =&gt; { // Arrange const formBuilder = TestBed.inject(FormBuilder); spyOn(formBuilder, 'group'); // Act fixture.detectChanges(); // Assert expect(formBuilder.group).toHaveBeenCalled();}); 不過我個人覺得這個測試案例在這裡沒啥必要，一方面是因為我們在單元測試已經有驗過 FormGroup 了， 另一方面則是因為在這裡我們其實並不在意 FormBuilder 的互動，只要 FormGroup 那邊的測試有符合預期即可。 因為 FormGroup 除了可以用 FormBuilder 來產生實體之外，也可以直接用 new FormGroup() 的方式來產生實體。 接著我們回來看畫面的部分，目前的程式碼大致上應該會長這樣： 123456789101112131415161718192021222324252627&lt;form *ngIf=\"formGroup\" [formGroup]=\"formGroup\" (ngSubmit)=\"login()\"&gt; &lt;p&gt; &lt;label for=\"account\"&gt;帳號：&lt;/label&gt; &lt;input type=\"email\" id=\"account\" [formControl]=\"accountControl\" /&gt; &lt;span class=\"error-message\"&gt;{{ getErrorMessage(accountControl) }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;密碼：&lt;/label&gt; &lt;input type=\"password\" id=\"password\" [formControl]=\"passwordControl\" /&gt; &lt;span class=\"error-message\"&gt;{{ getErrorMessage(passwordControl) }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=\"submit\" [disabled]=\"formGroup.invalid\"&gt;登入&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 大家有看出來要測什麼了嗎？我來幫大家整理一下要測的項目： 帳號欄位 屬性 type 的值要是 email 要將 accountControl 綁定到此欄位上 密碼欄位 屬性 type 的值要是 password 要將 passwordControl 綁定到此欄位上 錯誤訊息 要將帳號欄位的錯誤訊息綁定到畫面上 要將密碼欄位的錯誤訊息綁定到畫面上 登入按鈕 屬性 type 的值要是 submit 當表單是無效的狀態時，要有屬性 disabled 當表單是有效的狀態時，沒有屬性 disabled 當表單是有效狀態時，按下登入按鈕要能觸發函式 login 列完之後大家有沒有發現，跟上次測 Template Driven Forms 的時候相比，要驗證的項目少了很多對吧？！ 某方面來說，這是因為我們把一些原本是在這時候驗的項目轉移到單元測試上的緣故；另一方面是，有些項目可以多驗一些不同的狀況，容我後續遇到時再加以說明。 帳號欄位的驗證跟上次一樣先來驗證帳號欄位，複習一下帳號欄位的驗證項目： 屬性 type 的值要是 email 要將 accountControl 綁定到此欄位上 然後把帳號欄位要驗證的項目寫成測試案例： 12345678910111213141516171819202122232425describe('Account input field', () =&gt; { let accountInputElement: HTMLInputElement; beforeEach(() =&gt; { accountInputElement = compiledComponent.querySelector('#account')!; }); it('should have attribute \"type\" and the value is \"email\"', () =&gt; { // Arrange const attributeName = 'type'; const attributeValue = 'email'; // Assert expect(accountInputElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should binding with formControl \"accountControl\"', () =&gt; { // Arrange const account = 'whatever'; // Act component.accountControl.patchValue(account); fixture.detectChanges(); // Assert expect(accountInputElement.value).toBe(account); });}); 測試結果： 在這些測試案例裡，比較特別需要說明的是： should binding with formControl &quot;accountControl&quot; 這個測試案例，怎麼說呢？ 大家有沒有發現，這個測試案例跟上一個測試案例的驗證方式不太一樣？上一個是用 getAttribute 的方式，而這測試案例卻不是？ 在講原因之前，要先跟大家報告的是，其實將 FormControl 綁定到某個表單欄位上的方法有以下兩種： 直接用某個 FormControl 的實體綁定，使用方式是在該欄位用屬性綁定的方式綁定時體，如： [formControl]=&quot;accountControl&quot;（也就是我目前使用的方式）。 使用該欄位在 FormGroup 內所對應的 Key Name 來綁定，如： [formControlName]=&quot;'account'&quot; 或者是 formControlName=&quot;account&quot; 。 [formControlName]=&quot;'account'&quot; 與 formControlName=&quot;account&quot; 之間的差別在，前者在 Angular 裡叫做屬性綁定，意思是可以將其跟某個 Component 的屬性綁定；後者就只是在該元素上多加了一個自定的 HTML 的屬性，其值是寫死的。 如果是使用第二種的方式去將 FormControl 綁定到某個表單欄位上的話，在寫測試時可以很簡單的只用 getAttribute 的方式驗證。但是如果是使用第一種方式的話，就必須用我上面程式碼所示範的方式拐著彎驗，如果用 getAttribute 的方式來驗的話，只會取得 '[Object Object]' 這種沒有辦法進一步驗證的字串。 密碼欄位的驗證至於密碼欄位的部分，也跟帳號欄位差不多，其驗證項目如下： 屬性 type 的值要是 password 要將 passwordControl 綁定到此欄位上 測試程式碼如下： 12345678910111213141516171819202122232425describe('Password input field', () =&gt; { let passwordInputElement: HTMLInputElement; beforeEach(() =&gt; { passwordInputElement = compiledComponent.querySelector('#password')!; }); it('should have attribute \"type\" and the value is \"password\"', () =&gt; { // Arrange const attributeName = 'type'; const attributeValue = 'password'; // Assert expect(passwordInputElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should binding with formControl \"passwordControl\"', () =&gt; { // Arrange const password = 'whatever'; // Act component.passwordControl.patchValue(password); fixture.detectChanges(); // Assert expect(passwordInputElement.value).toBe(password); });}); 測試結果： 錯誤訊息的驗證錯誤訊息要驗證的項目是： 要將帳號欄位的錯誤訊息綁定到畫面上 要將密碼欄位的錯誤訊息綁定到畫面上 為什麼這兩個項目的敘述感覺起來很籠統呢？ 這是因為在我們原本的程式碼中，我們沒有特別用變數來儲存該欄位的錯誤訊息，而是直接讓 Template 在渲染畫面的時候，直接用該欄位的 formControl 的 errors 來取得對應的錯誤訊息，所以我們在驗證的時候就不能用上次的方式驗，具體請看我的測試程式碼： 12345678910111213141516171819202122232425describe('Error Message', () =&gt; { it('should binding error message \"格式有誤，請重新輸入\" with the error of \"accountControl\"', () =&gt; { // Arrange const errorMessage = '格式有誤，請重新輸入'; const targetElement = compiledComponent.querySelector('#account + .error-message'); // Act component.accountControl.setValue('abc'); component.accountControl.markAsDirty(); fixture.detectChanges(); // Assert expect(targetElement?.textContent).toBe(errorMessage); }); it('should binding error message \"密碼長度最短不得低於8碼\" with the error of \"passwordControl\"', () =&gt; { // Arrange const errorMessage = '密碼長度最短不得低於8碼'; const targetElement = compiledComponent.querySelector('#password + .error-message'); // Act component.passwordControl.setValue('abc'); component.passwordControl.markAsDirty(); fixture.detectChanges(); // Assert expect(targetElement?.textContent).toBe(errorMessage); });}); 從程式碼中可以看到，這邊要先將值設給對應的 formControl 並且 markAsDirty() 之後，才能抓取到正確的錯誤訊息。 這其實是因為在我們的程式碼裡， formControl 的狀態如果是 pristine 的話，會回傳空字串。 雖然我這邊目前是用各自欄位才會有的錯誤訊息來表示驗了兩種不同欄位，但其實是可以分成兩個欄位，然後將所有的情況都驗一遍。 不過這樣就會跟單元測試有點重疊，這部份大家可以自行斟酌。 測試結果： 登入按鈕的驗證最後是登入按鈕的驗證，它的驗證項目是： 屬性 type 的值要是 submit 當表單是無效的狀態時，要有屬性 disabled 當表單是有效的狀態時，沒有屬性 disabled 當表單是有效狀態時，按下登入按鈕要能觸發函式 login 程式碼如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748describe('Login button', () =&gt; { let buttonElement: HTMLButtonElement; beforeEach(() =&gt; { buttonElement = compiledComponent.querySelector('button')!; }); it('should have attribute \"type\" and the value is \"submit\"', () =&gt; { // Arrange const attributeName = 'type'; const attributeValue = 'submit'; // Assert expect(buttonElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"disabled\" when the form\\'s status is invalid', () =&gt; { // Arrange const attributeName = 'disabled'; // Assert expect(buttonElement.hasAttribute(attributeName)).toBe(true); }); describe('When the form\\'s status is valid', () =&gt; { beforeEach(() =&gt; { component.formGroup?.setValue({ account: 'abc@email.tw', password: '12345678' }); fixture.detectChanges(); }); it('should not have attribute \"disabled\"', () =&gt; { // Arrange const attributeName = 'disabled'; // Assert expect(buttonElement.hasAttribute(attributeName)).toBe(false); }); it('should trigger function \"login\" when being clicked', () =&gt; { // Arrange spyOn(component, 'login'); // Act buttonElement.click(); // Assert expect(component.login).toHaveBeenCalled(); }); });}); 測試結果： 這次沒有任何預期外的狀況，不像上次剛好遇到奇怪的問題，搞不好這又是 Reactive Forms 的另一個優點呢！（笑）。 至此，我們已經完成了第一個里程碑：用 Template Driven Forms 的方式與用 Reactive Forms 的方式各自實作一個登入系統，並且也都為它們寫了單元測試以及整合測試，相信大家對於如何使用 Angular 製作表單與撰寫測試都有了長足的進步。 明天開始就要邁入下一個里程碑：用 Template Driven Forms 的方式與用 Reactive Forms 的方式各自實作一個動態的表單，並且也要都為它們寫單元測試以及整合測試，敬請期待（壞笑）。 本日小結今天的重點主要有以下兩點： 學習如何正確驗證「將 formControl 綁定到表單欄位上」，並了解用不同的綁定方式在驗證上會有哪些差異。 學習如何正確驗證「直接用該欄位的 formControl 的 errors 來取得對應的錯誤訊息」的情況。 程式碼的部份一樣會放在 Github - Branch: day9 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，也都非常歡迎留言給我讓我知道噢！","link":"/2021/09/24/angular-30days-form-and-test-09/"},{"title":"Angular 深入淺出三十天：表單與測試 Day11 - Reactive Forms 實作 - 動態表單初體驗","text":"今天要來用 Reactive Forms 的方式再來實作一次昨天的表單。 具體的規格需求跟昨天差不多，如下所示： 被保險人的欄位： 姓名（文字輸入框） 最少需要填寫兩個字，如驗證有誤則顯示錯誤訊息姓名至少需兩個字以上 最多只能填寫十個字，如驗證有誤則顯示錯誤訊息姓名最多只能十個字 性別（單選） 選項：男性、女性 年齡（下拉選單） 選項： 18 歲、 20 歲、 70 歲、 75 歲 以上欄位皆為必填，如驗證有誤則顯示錯誤訊息此欄位為必填 以上驗證皆需在使用者輸入時動態檢查 按下新增被保險人按鈕可以新增被保險人 按下刪除被保險人按鈕可以刪除被保險人 任一驗證有誤時，送出按鈕皆呈現不可被點選之狀態 沒有被保險人時，送出按鈕皆呈現不可被點選之狀態 規格需求看清楚之後，我們就來開始實作吧！ 實作開始首先我們一樣先準備好基本的 HTML ： 123456789101112131415161718192021222324252627282930313233&lt;form *ngIf=\"formGroup\" [formGroup]=\"formGroup\" (ngSubmit)=\"submit()\"&gt; &lt;fieldset&gt; &lt;legend&gt;被保人&lt;/legend&gt; &lt;p&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" id=\"name\" formControlName=\"name\" /&gt; &lt;span class=\"error-message\"&gt;{{ getErrorMessage(\"name\") }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 性別： &lt;input type=\"radio\" id=\"male\" value=\"male\" formControlName=\"gender\" /&gt; &lt;label for=\"male\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" id=\"female\" value=\"female\" formControlName=\"gender\" /&gt; &lt;label for=\"female\"&gt;女&lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"age\"&gt;年齡：&lt;/label&gt; &lt;select id=\"age\" formControlName=\"age\"&gt; &lt;option value=\"\"&gt;請選擇&lt;/option&gt; &lt;option value=\"18\"&gt;18歲&lt;/option&gt; &lt;option value=\"20\"&gt;20歲&lt;/option&gt; &lt;option value=\"70\"&gt;70歲&lt;/option&gt; &lt;option value=\"75\"&gt;75歲&lt;/option&gt; &lt;/select&gt; &lt;span class=\"error-message\"&gt;{{ getErrorMessage(\"age\") }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;button type=\"button\"&gt;刪除&lt;/button&gt;&lt;/p&gt; &lt;/fieldset&gt; &lt;p&gt; &lt;button type=\"button\"&gt;新增被保險人&lt;/button&gt; &lt;button type=\"submit\"&gt;送出&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 未經美化的畫面跟昨天長得一樣： 接著跟昨天一樣先把它當成靜態表單來準備相關的屬性與方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import { Component, OnInit } from '@angular/core';import { FormBuilder, FormGroup, Validators } from '@angular/forms';@Component({ selector: 'app-template-driven-forms-async-insured', templateUrl: './template-driven-forms-async-insured.component.html', styleUrls: ['./template-driven-forms-async-insured.component.scss']})export class TemplateDrivenFormsAsyncInsuredComponent { /** * 綁定在表單上 * * @type {(FormGroup | undefined)} * @memberof ReactiveFormsAsyncInsuredComponent */ formGroup: FormGroup | undefined; /** * 透過 DI 取得 FromBuilder 物件，用以建立表單 * * @param {FormBuilder} formBuilder * @memberof ReactiveFormsAsyncInsuredComponent */ constructor(private formBuilder: FormBuilder) {} /** * 當 Component 初始化的時候初始化表單 * * @memberof ReactiveFormsAsyncInsuredComponent */ ngOnInit(): void { this.formGroup = this.formBuilder.group({ name: [ '', [Validators.required, Validators.minLength(2), Validators.maxLength(10)] ], gender: ['', Validators.required], age: ['', Validators.required] }); } /** * 透過欄位的 Errors 來取得對應的錯誤訊息 * * @param {string} key * @param {number} index * @return {*} {string} * @memberof ReactiveFormsAsyncInsuredComponent */ getErrorMessage(key: string): string { const formControl = this.formGroup?.get(key); let errorMessage: string; if (!formControl || !formControl.errors || formControl.pristine) { errorMessage = ''; } else if (formControl.errors.required) { errorMessage = '此欄位必填'; } else if (formControl.errors.minlength) { errorMessage = '姓名至少需兩個字以上'; } else if (formControl.errors.maxlength) { errorMessage = '姓名至多只能輸入十個字'; } return errorMessage!; } /** * 綁定在表單上，當按下送出按鈕時會觸發此函式 * * @memberof TemplateDrivenFormsAsyncInsuredComponent */ submit(): void { // do submit... }} 準備好相關的屬性和方法之後，我們直接把他們跟 Template 綁定： 12345678910111213141516171819202122232425262728293031323334353637&lt;form *ngIf=\"formGroup\" [formGroup]=\"formGroup\" (ngSubmit)=\"submit()\"&gt; &lt;fieldset&gt; &lt;legend&gt;被保人&lt;/legend&gt; &lt;p&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" id=\"name\" formControlName=\"name\" /&gt; &lt;span class=\"error-message\"&gt;{{ getErrorMessage('name') }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 性別： &lt;input type=\"radio\" id=\"male\" value=\"male\" formControlName=\"gender\"&gt; &lt;label for=\"male\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" id=\"female\" value=\"female\" formControlName=\"gender\"&gt; &lt;label for=\"female\"&gt;女&lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"age\"&gt;年齡：&lt;/label&gt; &lt;select id=\"age\" formControlName=\"age\"&gt; &lt;option value=\"\"&gt;請選擇&lt;/option&gt; &lt;option value=\"18\"&gt;18歲&lt;/option&gt; &lt;option value=\"20\"&gt;20歲&lt;/option&gt; &lt;option value=\"70\"&gt;70歲&lt;/option&gt; &lt;option value=\"75\"&gt;75歲&lt;/option&gt; &lt;/select&gt; &lt;span class=\"error-message\"&gt;{{ getErrorMessage('age') }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;button type=\"button\"&gt;刪除&lt;/button&gt;&lt;/p&gt; &lt;/fieldset&gt; &lt;p&gt; &lt;button type=\"button\"&gt;新增被保險人&lt;/button&gt; &lt;button type=\"submit\"&gt;送出&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 目前為止，大體上跟我們上次的實作差不多，應該沒有什麼難度。 不過這次綁定 FormControl 的方式，我改成用 formControlName=&quot;name&quot; ，而不是上次的 [formControl]=&quot;nameControl&quot; ，大家可以自行選用喜歡的方式。 如果大家在這邊有遇到問題，可以檢查看看自己有沒有引入 FormsModule 與 ReactiveFormsModule ，我就不再贅述囉。 目前的結果： 有了基本的互動效果之後，我們就可以開始來思考怎麼樣把這個表單變成動態的。 跟昨天一樣的是，既然我們要讓被保人可以被新增或刪除，表示我們應該是會用陣列來表達這些被保人的資料，也就是說，我們現在的 FormGroup 要從 1 個變成 N 個。 之前曾經提到，我們如果從資料面來看， {} 代表表單，也就是 FormGroup； '' 代表表單裡的子欄位，也就是 FormControl ；那 [] 呢？ 答案是 ─ FormArray ！ 不過 FormArray 不能直接跟 form 元素綁定，唯一可以跟 form 元素綁定的只有 FormGroup ，所以 FormArray 一定要在 FormGroup 裡面，就像這樣： 123this.formGroup = this.formBuilder.group({ insuredList: this.formBuilder.array([])}); 這邊要注意的是， FormArray 一定要透過 FormBuilder 或是 FormArray 的建構式來建立，像上面示範的那樣，或是這樣： 123this.formGroup = this.formBuilder.group({ insuredList: new FormArray([])}); 絕對不能偷懶寫成這樣： 123this.formGroup = this.formBuilder.group({ insuredList: []}); 這樣的話，就會變成普通的 FormControl 囉！切記切記！ 接著我們就可以將原本的程式碼修改成用陣列的方式，並把新增被保人、刪除被保人與判斷表單是否有效的函式都補上： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126@Component({ // 省略...})export class AppComponent implements OnInit { /** * 綁定在表單上 * * @type {(FormGroup | undefined)} * @memberof ReactiveFormsAsyncInsuredComponent */ formGroup: FormGroup | undefined; /** * 用以取得 FormArray * * @readonly * @type {FormArray} * @memberof ReactiveFormsAsyncInsuredComponent */ get formArray(): FormArray { return this.formGroup?.get('insuredList')! as FormArray; } /** * 綁定在送出按鈕上，判斷表單是不是無效 * * @readonly * @type {boolean} * @memberof ReactiveFormsAsyncInsuredComponent */ get isFormInvalid(): boolean { return this.formArray.controls.length === 0 || this.formGroup!.invalid; } /** * 透過 DI 取得 FromBuilder 物件，用以建立表單 * * @param {FormBuilder} formBuilder * @memberof ReactiveFormsAsyncInsuredComponent */ constructor(private formBuilder: FormBuilder) {} /** * 當 Component 初始化的時候初始化表單 * * @memberof ReactiveFormsAsyncInsuredComponent */ ngOnInit(): void { this.formGroup = this.formBuilder.group({ insuredList: this.formBuilder.array([]) }); } /** * 新增被保人 * * @memberof ReactiveFormsAsyncInsuredComponent */ addInsured(): void { const formGroup = this.createInsuredFormGroup(); this.formArray.push(formGroup); } /** * 刪除被保人 * * @param {number} index * @memberof ReactiveFormsAsyncInsuredComponent */ deleteInsured(index: number): void { this.formArray.controls.splice(index, 1); this.formArray.updateValueAndValidity(); } /** * 送出表單 * * @memberof ReactiveFormsAsyncInsuredComponent */ submit(): void { // do login... } /** * 透過欄位的 Errors 來取得對應的錯誤訊息 * * @param {string} key * @param {number} index * @return {*} {string} * @memberof ReactiveFormsAsyncInsuredComponent */ getErrorMessage(key: string, index: number): string { const formGroup = this.formArray.controls[index]; const formControl = formGroup.get(key); let errorMessage: string; if (!formControl || !formControl.errors || formControl.pristine) { errorMessage = ''; } else if (formControl.errors.required) { errorMessage = '此欄位必填'; } else if (formControl.errors.minlength) { errorMessage = '姓名至少需兩個字以上'; } else if (formControl.errors.maxlength) { errorMessage = '姓名至多只能輸入十個字'; } return errorMessage!; } /** * 建立被保人的表單 * * @private * @return {*} {FormGroup} * @memberof ReactiveFormsAsyncInsuredComponent */ private createInsuredFormGroup(): FormGroup { return this.formBuilder.group({ name: [ '', [Validators.required, Validators.minLength(2), Validators.maxLength(10)] ], gender: ['', Validators.required], age: ['', Validators.required] }); }} 接著我們到 Template 裡，把原本綁定的方式調整一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;form *ngIf=\"formGroup\" [formGroup]=\"formGroup\" (submit)=\"submit()\"&gt; &lt;ng-container formArrayName=\"insuredList\" *ngFor=\"let control of formArray.controls; let index = index\" &gt; &lt;fieldset [formGroupName]=\"index\"&gt; &lt;legend&gt;被保人&lt;/legend&gt; &lt;p&gt; &lt;label [for]=\"'name-' + index\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" [id]=\"'name-' + index\" formControlName=\"name\" /&gt; &lt;span class=\"error\"&gt;{{ getErrorMessage(\"name\", index) }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 性別： &lt;input type=\"radio\" [id]=\"'male-' + index\" value=\"male\" formControlName=\"gender\" /&gt; &lt;label [for]=\"'male-' + index\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" [id]=\"'female-' + index\" value=\"female\" formControlName=\"gender\" /&gt; &lt;label [for]=\"'female-' + index\"&gt;女&lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label [for]=\"'age-' + index\"&gt;年齡：&lt;/label&gt; &lt;select name=\"age\" [id]=\"'age-' + index\" formControlName=\"age\"&gt; &lt;option value=\"\"&gt;請選擇&lt;/option&gt; &lt;option value=\"18\"&gt;18歲&lt;/option&gt; &lt;option value=\"20\"&gt;20歲&lt;/option&gt; &lt;option value=\"70\"&gt;70歲&lt;/option&gt; &lt;option value=\"75\"&gt;75歲&lt;/option&gt; &lt;/select&gt; &lt;span class=\"error\"&gt;{{ getErrorMessage(\"age\", index) }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;button type=\"button\" (click)=\"deleteInsured(index)\"&gt;刪除&lt;/button&gt;&lt;/p&gt; &lt;/fieldset&gt; &lt;/ng-container&gt; &lt;p&gt; &lt;button type=\"button\" (click)=\"addInsured()\"&gt;新增被保險人&lt;/button&gt; &lt;button type=\"submit\" [disabled]=\"isFormInvalid\"&gt;送出&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 初次看到這種綁定方式的 Angular 初學者可能會傻眼，不過靜下心來看之後你會發現，其實這只是我們所建立的 FormGroup 裡的階層關係，這樣綁定 Angular 才能從一層層的表單之中開始往下找。 如果我們把其他的 HTML 都拿掉的話其實會清楚很多： 123&lt;form *ngIf=\"formGroup\" [formGroup]=\"formGroup\" (submit)=\"submit()\"&gt; &lt;!-- 其他省略 --&gt;&lt;/form&gt; 最外層的這個大家應該都知道，就是我們在 .ts 裡的 formGroup 。 12345678&lt;form *ngIf=\"formGroup\" [formGroup]=\"formGroup\" (submit)=\"submit()\"&gt; &lt;ng-container formArrayName=\"insuredList\" *ngFor=\"let control of formArray.controls; let index = index\" &gt; &lt;!-- 其他省略 --&gt; &lt;/ng-container&gt;&lt;/form&gt; 而這裡呢，就像我們寫靜態表單的時候，會從 FormGroup 裡根據對應的 key 值找到對應的 FormControl 一樣，這裡則是把對應的 FormArray 找出來。 然後再用 *ngFor 的方式，把 FormArray 底下的 AbstractControl 都迴圈出來。 關於 AbstractControl ，它其實是一個抽象類別，而 FormGroup 、 FormArray 與 FormControl 這三種類型其實都繼承於這個類別，所以大家不知道有沒有注意到，一般我們在 .ts 裡使用的時候，我們會特別用 as FormControl 或是 as FormArray 的方式來讓編譯器知道現在取得的物件實體是什麼型別，以便後續使用。 想知道更多 AbstractControl 的資訊的話，請參考官方 API 文件： https://angular.io/api/forms/AbstractControl 。 123456789&lt;form *ngIf=\"formGroup\" [formGroup]=\"formGroup\" (submit)=\"submit()\"&gt; &lt;ng-container formArrayName=\"insuredList\" *ngFor=\"let control of formArray.controls; let index = index\" &gt; &lt;fieldset [formGroupName]=\"index\"&gt; &lt;/fieldset&gt; &lt;/ng-container&gt;&lt;/form&gt; 最後再用索引值 index 找出對應的 FormGroup 。 而要做這件事情其實要有相對應的階層關係的 HTML 來幫忙，但因為我的 HTML 的階層關係少一層，所以我才會用 ng-container 多做一層階層，好讓我的表單可以順利綁上去。 如果今天你做的 HTML 的階層數是足夠的，就可以不用用 ng-container 多做一層階層，例如把上面的 HTML 改成這樣其實也可以： 123456789&lt;form *ngIf=\"formGroup\" [formGroup]=\"formGroup\" (submit)=\"submit()\"&gt; &lt;div formArrayName=\"insuredList\" *ngFor=\"let control of formArray.controls; let index = index\" &gt; &lt;fieldset [formGroupName]=\"index\"&gt; &lt;/fieldset&gt; &lt;/div&gt;&lt;/form&gt; 不過用 ng-container 的好處是這個元素並不會真的出現在畫面上，大家可以視情況斟酌使用。 改完之後就大功告成囉！來看看最後的結果： 本日小結今天的學習重點主要是在圍繞在 FormArray 上，因為多了這個階層的關係，所以在與 Template 的綁定上看起來會較為複雜一點點。 話雖如此，大家可以拿今天的 template 與昨天的 template 互相比較一下，除了 for 與 id 這兩個屬性因為天生侷限的關係真的沒辦法之外，但 name 的部份就不用再去處理了，還是很方便的。 今天的程式碼我會放在 Github - Branch: day11 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，也都非常歡迎留言給我讓我知道噢！","link":"/2021/09/26/angular-30days-form-and-test-11/"},{"title":"Angular 深入淺出三十天：表單與測試 Day14 - 單元測試實作 - 被保人 by Reactive Forms","text":"今天我們要來為我們用 Reactive Forms 所撰寫的被保人表單寫單元測試，如果還沒有相關程式碼的朋友，趕快前往閱讀第十一天的文章： Reactive Forms 實作 - 動態表單初體驗。 實作開始複習一下目前的程式碼： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122export class ReactiveFormsAsyncInsuredComponent implements OnInit { /** * 綁定在表單上 * * @type {(FormGroup | undefined)} * @memberof ReactiveFormsAsyncInsuredComponent */ formGroup: FormGroup | undefined; /** * 用以取得 FormArray * * @readonly * @type {FormArray} * @memberof ReactiveFormsAsyncInsuredComponent */ get formArray(): FormArray { return this.formGroup?.get('insuredList')! as FormArray; } /** * 綁定在送出按鈕上，判斷表單是不是無效 * * @readonly * @type {boolean} * @memberof ReactiveFormsAsyncInsuredComponent */ get isFormInvalid(): boolean { return this.formArray.controls.length === 0 || this.formGroup!.invalid; } /** * 透過 DI 取得 FromBuilder 物件，用以建立表單 * * @param {FormBuilder} formBuilder * @memberof ReactiveFormsAsyncInsuredComponent */ constructor(private formBuilder: FormBuilder) {} /** * 當 Component 初始化的時候初始化表單 * * @memberof ReactiveFormsAsyncInsuredComponent */ ngOnInit(): void { this.formGroup = this.formBuilder.group({ insuredList: this.formBuilder.array([]) }); } /** * 新增被保人 * * @memberof ReactiveFormsAsyncInsuredComponent */ addInsured(): void { const formGroup = this.createInsuredFormGroup(); this.formArray.push(formGroup); } /** * 刪除被保人 * * @param {number} index * @memberof ReactiveFormsAsyncInsuredComponent */ deleteInsured(index: number): void { this.formArray.removeAt(index); } /** * 送出表單 * * @memberof ReactiveFormsAsyncInsuredComponent */ submit(): void { // do login... } /** * 透過欄位的 Errors 來取得對應的錯誤訊息 * * @param {string} key * @param {number} index * @return {*} {string} * @memberof ReactiveFormsAsyncInsuredComponent */ getErrorMessage(key: string, index: number): string { const formGroup = this.formArray.controls[index]; const formControl = formGroup.get(key); let errorMessage: string; if (!formControl || !formControl.errors || formControl.pristine) { errorMessage = ''; } else if (formControl.errors.required) { errorMessage = '此欄位必填'; } else if (formControl.errors.minlength) { errorMessage = '姓名至少需兩個字以上'; } else if (formControl.errors.maxlength) { errorMessage = '姓名至多只能輸入十個字'; } return errorMessage!; } /** * 建立被保人的表單 * * @private * @return {*} {FormGroup} * @memberof ReactiveFormsAsyncInsuredComponent */ private createInsuredFormGroup(): FormGroup { return this.formBuilder.group({ name: [ '', [Validators.required, Validators.minLength(2), Validators.maxLength(10)] ], gender: ['', Validators.required], age: ['', Validators.required] }); }} 以目前的程式碼來看，我們要驗的單元一共有以下這些函式： formArray isFormInvalid ngOnInit addInsured deleteInsured getErrorMessage 以下就按照順序來撰寫測試吧！ 開始撰寫測試案例前，記得先處理好依賴，如果忘記的話，可以先回到第六天的文章複習，我就不再贅述囉！ 不過今天的測試案例幾乎都建立在 ngOnInit 被觸發後的情況之下，所以這次我打算直接把 fixture.detectChanges() 放在一開始的 beforeEach 裡，這樣就不用在每個測試案例加了。 像這樣： 1234beforeEach(() =&gt; { // 其他省略 fixture.detectChanges();}); 測試單元 - formArray這個單元很單純，基本只要驗在 ngOnInit 被觸發後，可以取得 formArray 即可。 程式碼如下： 12345678describe('formArray', () =&gt; { it('should get the FormArray from the FormGroup after \"ngOnInit\" being trigger', () =&gt; { // Act const formArray = component.formGroup?.get('insuredList') as FormArray; // Assert expect(component.formArray).toBe(formArray); });}); 測試結果： 測試單元 - isFormInvalid這個單元基本上要測三個狀況： formArray 裡的 controls 的長度為 0 時，回傳 true formGroup 裡有任何 errors 時，回傳 true formArray 裡的 controls 的長度不為 0 且 formGroup 裡也沒有任何 errors 時，回傳 false 程式碼如下： 12345678910111213141516171819202122232425262728describe('isFormInvalid', () =&gt; { it('should be true when there are not any insureds', () =&gt; { // Act const expectedResult = component.isFormInvalid; // Assert expect(expectedResult).toBe(true); }); it('should be true when there are any errors', () =&gt; { // Arrange const formControl = new FormControl('', Validators.required); component.formArray.push(formControl); // Act const expectedResult = component.isFormInvalid; // Assert expect(expectedResult).toBe(true); }); it('should be false when there are not any errors', () =&gt; { // Arrange const formControl = new FormControl(''); component.formArray.push(formControl); // Act const expectedResult = component.isFormInvalid; // Assert expect(expectedResult).toBe(false); });}); 測試結果： 測試單元 - ngOnInitngOnInit 要驗證的情況也很簡單，就是看執行完有沒有順利地把 formGroup 建立出來。 不過要驗證到什麼地步就看個人了，例如我們可以很簡單地這樣子驗： 12345678describe('ngOnInit', () =&gt; { it('should initialize property \"formGroup\"', () =&gt; { // Act fixture.detectChanges(); // Assert expect(component.formGroup).toBeTruthy(); });}); 也可以驗稍微仔細一點： 12345678describe('ngOnInit', () =&gt; { it('should initialize property \"formGroup\"', () =&gt; { // Act fixture.detectChanges(); // Assert expect(component.formGroup).toBeInstanceOf(FormGroup); });}); 驗得越粗糙，測試對你的單元保護力越低；反之則越高。所以就看你想要提供給你要測的單元怎麼樣的保護。 測試結果： 測試單元 - addInsured &amp; deleteInsured這兩個單元就更沒難度了，一個只是驗證執行後， formArray 的長度有沒有增加；另一個則是減少 formArray 的長度。 程式碼如下： 123456789101112131415161718192021describe('addInsured', () =&gt; { it('should push a \"formGroup\" into the \"formArray\"', () =&gt; { // Act component.addInsured(); // Assert expect(component.formArray.length).toBe(1); });});describe('deleteInsured', () =&gt; { it('should remove the \"formGroup\" from the \"formArray\" by the index', () =&gt; { // Arrange const index = 0; const formGroup = new FormGroup({}); component.formArray.push(formGroup); // Act component.deleteInsured(index); // Assert expect(component.formArray.length).toBe(0); });}); 測試結果： 我知道一定有人會有一個疑問：「為什麼測 deleteInsured 的時候， Arrange 的部分不直接用 component.addInsured() 就好，還要自己敲？」。 這是因為我們要做到測試隔離，大家還記得嗎？不記得的趕快回去翻第五天的文章：如何寫出優秀的測試？ 大家可以想想，如果今天我們真的使用了 component.addInsured() ，之後哪一天 addInsured 這個函式被改壞了不就也連帶導致了 deleteInsured 這個不相干的測試也會跑失敗嗎？ 雖然廣義一點來講，一個跑失敗跟兩個跑失敗貌似沒什麼區別，都是失敗。但在實質意義上來說就差很多，這點務必請大家銘記在心。 測試單元 - getErrorMessage最後是大家都非常熟悉的 getErrorMessage ，有沒有一種整天都在測這個案例的感覺？ 雖然前面都測得比較隨便粗糙，我們這個單元測仔細一點好了。 要驗證的項目如下： 如果用錯誤的 key 值導致找不到對應的 FormControl ，則回傳空字串。 如果該欄位沒有任何錯誤，則回傳空字串。 如果該欄位的 pristine 為 true，則回傳空字串。 如果該欄位的有 required 的錯誤，則回傳 此欄位必填 如果該欄位的有 minlength 的錯誤，則回傳 姓名至少需兩個字以上 如果該欄位的有 maxlength 的錯誤，則回傳 姓名至多只能輸入十個字 程式碼如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283describe('getErrorMessage', () =&gt; { let formGroup: FormGroup; beforeEach(() =&gt; { const nameControl = new FormControl('', [ Validators.required, Validators.minLength(2), Validators.maxLength(10) ]); formGroup = new FormGroup({ name: nameControl, }); component.formArray.push(formGroup); }); it('should return empty string with the wrong key', () =&gt; { // Arrange const key = 'leo' const index = 0; // Act const errorMessage = component.getErrorMessage(key, index); // Assert expect(errorMessage).toBe(''); }); it('should return empty string when the \"formControl\" without errors', () =&gt; { // Arrange const key = 'name' const index = 0; formGroup.get(key)?.setValue('Leo'); // Act const errorMessage = component.getErrorMessage(key, index); // Assert expect(errorMessage).toBe(''); }); it('should return empty string when property \"pristine\" of the \"formControl\" is `true`', () =&gt; { // Arrange const key = 'name' const index = 0; // Act const errorMessage = component.getErrorMessage(key, index); // Assert expect(errorMessage).toBe(''); }); it('should return \"此欄位必填\" when the \"formControl\" has the required error', () =&gt; { // Arrange const key = 'name' const index = 0; formGroup.get(key)?.markAsDirty(); // Act const errorMessage = component.getErrorMessage(key, index); // Assert expect(errorMessage).toBe('此欄位必填'); }); it('should return \"姓名至少需兩個字以上\" when the \"formControl\" has the min-length error', () =&gt; { // Arrange const key = 'name' const index = 0; const formControl = formGroup.get(key)!; formControl.setValue('A') formControl.markAsDirty(); // Act const errorMessage = component.getErrorMessage(key, index); // Assert expect(errorMessage).toBe('姓名至少需兩個字以上'); }); it('should return \"姓名至多只能輸入十個字\" when the \"formControl\" has the max-length error', () =&gt; { // Arrange const key = 'name' const index = 0; const formControl = formGroup.get(key)!; formControl.setValue('ABCDEF123456') formControl.markAsDirty(); // Act const errorMessage = component.getErrorMessage(key, index); // Assert expect(errorMessage).toBe('姓名至多只能輸入十個字'); });}); 測試結果： 今天所有測試的結果： 本日小結跟昨天一樣的是，其實測試手法大致上差不多就這些，當然更複雜的情境會用到其他的手法，但目前主要還是以讓大家多熟悉、多練習為主，後面才會提到更複雜的情況。 我個人覺得，提高撰寫測試的功力不外乎就是練習以及多跟他人交流，所以如果在公司沒人可以幫你 code review 或是你也不會幫其他人 code review 的話，是很可惜的一件事。 今天實作程式碼一樣會放在 Github - Branch: day14 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，也都非常歡迎留言給我讓我知道噢！","link":"/2021/09/29/angular-30days-form-and-test-14/"},{"title":"Angular 深入淺出三十天：表單與測試 Day12 - 單元測試實作 - 被保人 by Template Driven Forms","text":"今天我們要來為我們用 Template Driven Forms 所撰寫的被保人表單寫單元測試，如果還沒有相關程式碼的朋友，趕快前往閱讀第十天的文章： Template Driven Forms 實作 - 動態表單初體驗。 此外，由於許多同樣的事情已在第六天的文章：單元測試實作 - 登入系統 by Template Driven Forms 講過了，例如前置作業的部份，我就不再重複贅述囉！ 實作開始個人習慣要撰寫測試時的第一件事情，就是先把目標類別的依賴都先準備好，例如我們的被保人表單至少會需要 FormsModule 。 123456789101112131415161718192021import { TestBed } from '@angular/core/testing';import { TemplateDrivenFormsAsyncInsuredComponent } from './template-driven-forms-async-insured.component';describe('TemplateDrivenFormsAsyncInsuredComponent', () =&gt; { let component: TemplateDrivenFormsAsyncInsuredComponent; let fixture: ComponentFixture&lt;TemplateDrivenFormsAsyncInsuredComponent&gt;; beforeEach(async () =&gt; { await TestBed.configureTestingModule({ declarations: [TemplateDrivenFormsAsyncInsuredComponent], imports: [FormsModule] }).compileComponents(); fixture = TestBed.createComponent(TemplateDrivenFormsAsyncInsuredComponent); component = fixture.componentInstance; }); it('should create', () =&gt; { expect(component).toBeTruthy(); });}); 加完之後使用 ng test 的指令將測試程式啟動起來，應該要能通過我們的第一個測試案例 should create。 雖然有些人可能會發現，當前這個階段如果不加不會報錯，其實這是因為我們的程式一開始沒有任何表單（空陣列），一旦後續測試時加了之後一定會報錯噢！ 再次幫大家複習：單元測試主要是要用來驗證單個類別的函式其實際執行結果是否符合我們預期的執行結果。 開始前先打開 .ts 來看一下要寫哪些案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687export class TemplateDrivenFormsAsyncInsuredComponent { // 被保險人清單 insuredList: Insured[] = []; /** * 根據索引來重新渲染有更改的節點 * 詳情請參考官方文件：https://angular.tw/api/common/NgForOf * * @param {string} index * @return {*} {number} * @memberof AppComponent */ trackByIndex(index: number): number { return index; } /** * 綁定在姓名欄位上，當使用者改變被保險人的姓名時，會觸發此函式，並取得對應的錯誤訊息 * * @param {string} name * @param {ValidationErrors | null} errors * @param {Insured} insured * @memberof TemplateDrivenFormsAsyncInsuredComponent */ insuredNameChange(name: string, errors: ValidationErrors | null, insured: Insured): void { insured.name = name; insured.nameErrorMessage = this.getErrorMessage(errors); } /** * 綁定在年齡欄位上，當使用者改變被保險人的年齡時，會觸發此函式，並取得對應的錯誤訊息 * * @param {string} age * @param {ValidationErrors | null} errors * @param {Insured} insured * @memberof TemplateDrivenFormsAsyncInsuredComponent */ insuredAgeChange(age: string, errors: ValidationErrors | null, insured: Insured): void { insured.age = age; insured.ageErrorMessage = this.getErrorMessage(errors); } /** * 新增被保險人 * * @memberof TemplateDrivenFormsAsyncInsuredComponent */ addInsured(): void { const insured: Insured = { name: '', gender: '', age: '', nameErrorMessage: '', ageErrorMessage: '' }; this.insuredList.push(insured); } /** * 刪除被保險人 * * @param {number} index * @memberof TemplateDrivenFormsAsyncInsuredComponent */ deleteInsured(index: number): void { this.insuredList.splice(index, 1); } /** * 根據 FormControl 的 errors 屬性取得相應的錯誤訊息 * * @private * @param {ValidationErrors | null} errors - FormControl 的 errors * @return {*} {string} * @memberof TemplateDrivenFormsAsyncInsuredComponent */ private getErrorMessage(errors: ValidationErrors | null): string { let errorMessage = ''; if (errors?.required) { errorMessage = '此欄位必填'; } else if (errors?.minlength) { errorMessage = '姓名至少需兩個字以上'; } return errorMessage; }} 以目前的程式碼來看，我們要測的單元有 trackByIndex 、 insuredNameChange 、 insuredAgeChange 、 addInsured 與 deleteInsured 這五個，接下來我們照順序先從 trackByIndex 來寫好了。 測試單元 - trackByIndex這個測試單元非常簡單，不多說直接看程式碼： 12345678describe('trackByIndex', () =&gt; { it('should just return the index', () =&gt; { // Arrange const index = 0; // Assert expect(component.trackByIndex(index)).toBe(index); })}); 測試結果： 測試單元 - insuredNameChange接下來要測的單元是 insuredNameChange ，要測的案例有： 會將傳入的 name 的值賦值給傳入的 insured 裡的 name 。 如果傳入的 errors 有 required 欄位，則會將錯誤訊息 此欄位必填 賦值給傳入的 insured 裡的 nameErrorMessage 。 如果傳入的 errors 有 minlength 欄位，則會將錯誤訊息 姓名至少需兩個字以上 賦值傳入的 insured 裡的 nameErrorMessage 。 程式碼如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950describe('insuredNameChange', () =&gt; { let insured: Insured; beforeEach(() =&gt; { insured = { name: '', gender: '', age: '', nameErrorMessage: '', ageErrorMessage: '' }; }); it('should assign the value of the formControl to property \"name\" of the insured', () =&gt; { // Arrange const value = 'Leo'; const errors = null; // Act component.insuredNameChange(value, errors, insured); // Assert expect(insured.name).toBe(value); }); it('should assign error message \"此欄位必填\" to property \"nameErrorMessage\" of the insured when the value of the formControl is empty string', () =&gt; { // Arrange const value = ''; const errors = { required: true }; const errorMessage = '此欄位必填'; // Act component.insuredNameChange(value, errors, insured); // Assert expect(insured.nameErrorMessage).toBe(errorMessage); }); it('should assign error message \"姓名至少需兩個字以上\" to property \"nameErrorMessage\" of the insured when the value\\;s length of the formControl less than 2', () =&gt; { // Arrange const value = 'L'; const errors = { minlength: { actualLength: 1, requiredLength: 2 } }; const errorMessage = '姓名至少需兩個字以上'; // Act component.insuredNameChange(value, errors, insured); // Assert expect(insured.nameErrorMessage).toBe(errorMessage); });}); 這邊的程式碼大家應該都還算熟悉，比較特別需要提醒的是，記得要把初始化這件事寫在 beforeEach 裡，讓每個測試案例在執行之前都能拿到重新初始化過後的值，避免與其他的測試案例共用同個資料或物件。 測試結果： 測試單元 - insuredAgeChange下個要測的單元是 insuredAgeChange ，基本上跟 insuredNameChange 相似度高達 87% ，要測試的案例有： 會將傳入的 age 的值賦值給傳入的 insured 裡的 name 。 如果傳入的 errors 有 required 欄位，則會將錯誤訊息 此欄位必填 賦值給傳入的 insured 裡的 nameErrorMessage 。 程式碼如下： 12345678910111213141516171819202122232425262728293031323334describe('insuredAgeChange', () =&gt; { let insured: Insured; beforeEach(() =&gt; { insured = { name: '', gender: '', age: '', nameErrorMessage: '', ageErrorMessage: '' }; }); it('should assign the value of the formControl to property \"age\" of the insured', () =&gt; { // Arrange const age = '18'; const errors = null; // Act component.insuredAgeChange(age, errors, insured); // Assert expect(insured.age).toBe(age); }); it('should assign error message \"此欄位必填\" to property \"ageErrorMessage\" of the insured when the value of the formControl is empty string', () =&gt; { // Arrange const age = ''; const errors = { required: true }; const errorMessage = '此欄位必填'; // Act component.insuredAgeChange(age, errors, insured); // Assert expect(insured.ageErrorMessage).toBe(errorMessage); });}); 測試結果： 測試單元 - addInsured這個單元的測試也是相當簡單，基本上只要驗證執行後會新增一個被保人表單的資料即可。 程式碼如下： 12345678910111213141516describe('addInsured', () =&gt; { it('should add a new insured data into property \"insuredList\" after being triggered', () =&gt; { // Arrange const expectResult: Insured[] = [{ name: '', gender: '', age: '', nameErrorMessage: '', ageErrorMessage: '' }]; // Act component.addInsured(); // Assert expect(component.insuredList).toEqual(expectResult); });}); 測試結果： 雖然很間單，但大家有沒有注意到，在這我裡我不是用 toBe 而是用 toEqual 來驗證？ toBe 的比較一般會用在原始型別的對比上，但如果今天要對比的是物件就要改成用 toEqual 來驗證了。 如果不知道為什麼的朋友，可能要先複習一下 JS 的核心概念囉！ 參考文件：MDN 官方文件 - 理解相等比較模型。 測試結果： 測試單元 - deleteInsured最後一個單元也非常簡單，基本上只要驗證能將被保人的資料從 insuredList 中刪除即可。 程式碼如下 12345678910111213141516describe('deleteInsured', () =&gt; { it('should delete the insured data by the index after being triggered', () =&gt; { // Arrange component.insuredList = [{ name: '', gender: '', age: '', nameErrorMessage: '', ageErrorMessage: '' }]; // Act component.deleteInsured(0); // Assert expect(component.insuredList).toEqual([]); });}); 測試結果： 今天所有的測試結果： 本日小結不知道大家有沒有覺得今天的單元測試很簡單，甚至是有點無聊了呢？ 與一開始還沒接觸時相比，是不是覺得其實寫單元測試也沒花多少時間，而且更可以保證程式碼的品質呢？ 沒錯，這一切都會隨著熟練度的提升而變得愈加容易！ 今天的學習重點主要是： 清楚 toBe 與 toEqual 的差別。 測試隔離 練習寫測試 今天的程式碼會放在 Github - Branch: day12 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，也都非常歡迎留言給我讓我知道噢！","link":"/2021/09/27/angular-30days-form-and-test-12/"},{"title":"Angular 深入淺出三十天：表單與測試 Day15 - 整合測試實作 - 被保人 by Reactive Forms","text":"昨天幫我們用 Reactive Forms 所撰寫的被保人表單寫完單元測試之後，今天則是要來為它寫整合測試。 大家還記得整合測試的目標是要測什麼嗎？我幫大家複習一下： 整合測試的測試目標是要測是兩個或是兩個以上的類別之間的互動是否符合我們的預期。 實作開始首先我們先增加一個 Integration testing 的區塊，有關於整合測試的程式碼接下來都會放在這裡面，至於昨天的就放在 Unit testing 的區塊： 1234567891011describe('TemplateDrivenFormsAsyncInsuredComponent', () =&gt; { // 其他省略... describe('Unit testing', () =&gt; { // 昨天寫的單元測試... }); describe('Integration testing', () =&gt; { // 今天要寫的整合測試 });}); 跟之前樣先打開 .html 來看一下目前的程式碼： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;form *ngIf=\"formGroup\" [formGroup]=\"formGroup\" (submit)=\"submit()\"&gt; &lt;ng-container formArrayName=\"insuredList\" *ngFor=\"let control of formArray.controls; let index = index\" &gt; &lt;fieldset [formGroupName]=\"index\"&gt; &lt;legend&gt;被保人&lt;/legend&gt; &lt;p&gt; &lt;label [for]=\"'name-' + index\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" [id]=\"'name-' + index\" formControlName=\"name\" /&gt; &lt;span class=\"error-message\"&gt;{{ getErrorMessage(\"name\", index) }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 性別： &lt;input type=\"radio\" [id]=\"'male-' + index\" value=\"male\" formControlName=\"gender\" /&gt; &lt;label [for]=\"'male-' + index\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" [id]=\"'female-' + index\" value=\"female\" formControlName=\"gender\" /&gt; &lt;label [for]=\"'female-' + index\"&gt;女&lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label [for]=\"'age-' + index\"&gt;年齡：&lt;/label&gt; &lt;select name=\"age\" [id]=\"'age-' + index\" formControlName=\"age\"&gt; &lt;option value=\"\"&gt;請選擇&lt;/option&gt; &lt;option value=\"18\"&gt;18歲&lt;/option&gt; &lt;option value=\"20\"&gt;20歲&lt;/option&gt; &lt;option value=\"70\"&gt;70歲&lt;/option&gt; &lt;option value=\"75\"&gt;75歲&lt;/option&gt; &lt;/select&gt; &lt;span class=\"error-message\"&gt;{{ getErrorMessage(\"age\", index) }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;button type=\"button\" (click)=\"deleteInsured(index)\"&gt;刪除&lt;/button&gt;&lt;/p&gt; &lt;/fieldset&gt; &lt;/ng-container&gt; &lt;p&gt; &lt;button type=\"button\" (click)=\"addInsured()\"&gt;新增被保險人&lt;/button&gt; &lt;button type=\"submit\" [disabled]=\"isFormInvalid\"&gt;送出&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 大家有看出來要測什麼了嗎？我來幫大家整理一下要測的項目： 姓名欄位 屬性 type 的值要是 text 屬性 formControlName 的值要是 name 當此欄位的狀態是 pristine 時，則不會有錯誤訊息 當此欄位的狀態不是 pristine 且欄位的值為空字串時，則顯示 此欄位必填 的錯誤訊息 當此欄位的狀態不是 pristine 且欄位的值只有一個字時，則顯示 姓名至少需兩個字以上 的錯誤訊息 當此欄位的狀態不是 pristine 且欄位的值超過十個字時，則顯示 姓名至多只能輸入十個字 的錯誤訊息 性別欄位 男 屬性 type 的值要是 radio 屬性 value 的值要是 male 屬性 formControlName 的值要是 gender 女 屬性 type 的值要是 radio 屬性 value 的值要是 male 屬性 formControlName 的值要是 gender 年齡欄位 屬性 formControlName 的值要是 age 當此欄位的狀態是 pristine 時，則不會有錯誤訊息 當此欄位的狀態不是 pristine 且欄位的值為空字串時，則顯示 此欄位必填 的錯誤訊息 新增被保人按鈕 按下按鈕要能觸發函式 addInsured 刪除被保人按鈕 按下按鈕要能觸發函式 deleteInsured 送出按鈕 屬性 type 的值要是 submit 沒有任何被保人時，送出按鈕皆呈現不可被點選之狀態 任一個被保人的驗證有誤時，送出按鈕皆呈現不可被點選之狀態 當所有的被保人資料皆正確時，按下送出按鈕要能觸發函式 submit 把要測的項目都列出來之後，有沒有覺得要測的項目很多阿？哈哈！ 再次跟大家說明，雖然上面這些項目有些其實並不真的屬於整合測試的範圍，但我個人會在這時候一起測，因為這樣可以省下一些重複的程式碼。 大家應該還記得怎麼測吧？忘記的趕快回去看一下之前的文章！ 此外，開始之前也別忘記先做以下程式碼所展示的前置作業，後面將不再贅述： 123456789describe('Integration testing', () =&gt; { let compiledComponent: HTMLElement; beforeEach(() =&gt; { compiledComponent = fixture.nativeElement; }); // 案例寫在這邊}); 姓名欄位的驗證複習一下姓名欄位的驗證項目： 屬性 type 的值要是 text 屬性 formControlName 的值要是 name 當此欄位的狀態是 pristine 時，則不會有錯誤訊息 當此欄位的狀態不是 pristine 且欄位的值為空字串時，則顯示 此欄位必填 的錯誤訊息 當此欄位的狀態不是 pristine 且欄位的值只有一個字時，則顯示 `姓名至少 程式碼如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108describe('the insured fields', () =&gt; { let formGroup: FormGroup; beforeEach(() =&gt; { const nameControl = new FormControl('', [ Validators.required, Validators.minLength(2), Validators.maxLength(10) ]); const genderControl = new FormControl('', Validators.required); const ageControl = new FormControl('', Validators.required); formGroup = new FormGroup({ name: nameControl, gender: genderControl, age: ageControl }); component.formArray.push(formGroup); fixture.detectChanges(); }); describe('the name input field', () =&gt; { let nameInputElement: HTMLInputElement; beforeEach(() =&gt; { nameInputElement = compiledComponent.querySelector('#name-0')!; }); it('should have attribute \"type\" and the value is \"text\"', () =&gt; { // Arrange const attributeName = 'type'; const attributeValue = 'text'; // Assert expect(nameInputElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"formControlName\" and the value is \"name\"', () =&gt; { // Arrange const attributeName = 'formControlName'; const attributeValue = 'name'; // Assert expect(nameInputElement.getAttribute(attributeName)).toBe(attributeValue); }); describe('Error Messages', () =&gt; { let nameFormControl: FormControl; beforeEach(() =&gt; { nameFormControl = formGroup.get('name') as FormControl; }); it('should be empty string when property \"pristine\" of the \"formControl\" is `true`', () =&gt; { // Arrange const targetElement = compiledComponent.querySelector('#name-0 + .error-message'); // Assert expect(targetElement?.textContent).toBe(''); }); describe('when the field is dirty', () =&gt; { beforeEach(() =&gt; { nameFormControl.markAsDirty(); fixture.detectChanges(); }); it('should be \"此欄位必填\" when the value is empty string', () =&gt; { // Arrange const errorMessage = '此欄位必填'; const targetElement = compiledComponent.querySelector('#name-0 + .error-message'); // Assert expect(targetElement?.textContent).toBe(errorMessage); }); it('should be \"姓名至少需兩個字以上\" when the value\\'s length less than 2', () =&gt; { // Arrange nameFormControl.setValue('A') const errorMessage = '姓名至少需兩個字以上'; const targetElement = compiledComponent.querySelector('#name-0 + .error-message'); // Act fixture.detectChanges(); // Assert expect(targetElement?.textContent).toBe(errorMessage); }); it('should be \"姓名至多只能輸入十個字\" when the value\\'s length greater than 10', () =&gt; { // Arrange nameFormControl.setValue('ABCDE123456') const errorMessage = '姓名至多只能輸入十個字'; const targetElement = compiledComponent.querySelector('#name-0 + .error-message'); // Act fixture.detectChanges(); // Assert expect(targetElement?.textContent).toBe(errorMessage); }); it('should be empty string when there are not any errors', () =&gt; { // Arrange nameFormControl.setValue('ABCDE123456') const errorMessage = '姓名至多只能輸入十個字'; const targetElement = compiledComponent.querySelector('#name-0 + .error-message'); // Act fixture.detectChanges(); // Assert expect(targetElement?.textContent).toBe(errorMessage); }); }); }); });}); 測試結果： 這段程式碼中有兩個重點： 為了之後測其他欄位，我多新增了一個 test insured fields 的 describe 。這是因為要驗證這些欄位之前，一定要先讓被保人的表單長出來，所我才會多包一層，並把大家都會做的事情拉到這層的 beforeEach 來做。 切記不要使用 component.addInsured() 來新增被保人。 性別欄位的驗證性別欄位要驗證的部份非常簡單，項目如下： 男 屬性 type 的值要是 radio 屬性 value 的值要是 male 屬性 formControlName 的值要是 gender 女 屬性 type 的值要是 radio 屬性 value 的值要是 male 屬性 formControlName 的值要是 gender 測試程式碼如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263describe('the gender radio buttons', () =&gt; { let radioButtonElement: HTMLInputElement; describe('male', () =&gt; { beforeEach(() =&gt; { radioButtonElement = compiledComponent.querySelector(`#male-0`)!; }); it('should have attribute \"type\" and the value is \"radio\"', () =&gt; { // Arrange const attributeName = 'type'; const attributeValue = 'radio'; // Assert expect(radioButtonElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"formControlName\" and the value is \"gender\"', () =&gt; { // Arrange const attributeName = 'formControlName'; const attributeValue = 'gender'; // Assert expect(radioButtonElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"value\" and the value is \"male\"', () =&gt; { // Arrange const attributeName = 'value'; const attributeValue = 'male'; // Assert expect(radioButtonElement.getAttribute(attributeName)).toBe(attributeValue); }); }); describe('female', () =&gt; { beforeEach(() =&gt; { radioButtonElement = compiledComponent.querySelector(`#female-0`)!; }); it('should have attribute \"type\" and the value is \"radio\"', () =&gt; { // Arrange const attributeName = 'type'; const attributeValue = 'radio'; // Assert expect(radioButtonElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"formControlName\" and the value is \"gender\"', () =&gt; { // Arrange const attributeName = 'formControlName'; const attributeValue = 'gender'; // Assert expect(radioButtonElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"value\" and the value is \"female\"', () =&gt; { // Arrange const attributeName = 'value'; const attributeValue = 'female'; // Assert expect(radioButtonElement.getAttribute(attributeName)).toBe(attributeValue); }); });}); 測試結果： 年齡欄位的驗證年齡欄位要驗證的項目如下： 屬性 formControlName 的值要是 age 當此欄位的狀態是 pristine 時，則不會有錯誤訊息 當此欄位的狀態不是 pristine 且欄位的值為空字串時，則顯示 此欄位必填 的錯誤訊息 程式碼如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546describe('the age field', () =&gt; { const key = 'age-0' let ageSelectElement: HTMLSelectElement; beforeEach(() =&gt; { ageSelectElement = compiledComponent.querySelector(`#${key}`)!; }); it('should have attribute \"formControlName\" and the value is \"age\"', () =&gt; { // Arrange const attributeName = 'formControlName'; const attributeValue = 'age'; // Assert expect(ageSelectElement.getAttribute(attributeName)).toBe(attributeValue); }); describe('Error Messages', () =&gt; { let ageFormControl: FormControl; beforeEach(() =&gt; { ageFormControl = formGroup.get('age') as FormControl; }); it('should be empty string when property \"pristine\" of the \"formControl\" is `true`', () =&gt; { // Arrange const targetElement = compiledComponent.querySelector('#age-0 + .error-message'); // Assert expect(targetElement?.textContent).toBe(''); }); describe('when the field is dirty', () =&gt; { beforeEach(() =&gt; { ageFormControl.markAsDirty(); fixture.detectChanges(); }); it('should be \"此欄位必填\" when the value is empty string', () =&gt; { // Arrange const errorMessage = '此欄位必填'; const targetElement = compiledComponent.querySelector('#age-0 + .error-message'); // Assert expect(targetElement?.textContent).toBe(errorMessage); }); }); });}); 年齡欄位的驗證跟姓名的驗證有 87% 像，複製過來再稍微調整一下即可。 測試結果： 刪除按鈕的驗證刪除被保人按鈕要驗證的是：按下按鈕要能觸發函式 deleteInsured 。這部份大家只要使用 Spy 的技巧來驗證即可，也是頗為簡單。 程式碼如下： 123456789101112describe('Delete insured button', () =&gt; { it('should trigger function `deleteInsured` after being clicked', () =&gt; { // Arrange const index = 0; const deleteButtonElement = compiledComponent.querySelector('fieldset button[type=\"button\"]') as HTMLElement; spyOn(component, 'deleteInsured'); // Act deleteButtonElement.click(); // Assert expect(component.deleteInsured).toHaveBeenCalledWith(index); });}); 測試結果： 新增被保人按鈕的驗證新增被保人按鈕要驗證的是：按下按鈕要能觸發函式 addInsured ，跟刪除被保人的按鈕要驗證的項目幾乎是一模一樣，複製過來稍微修改一下即可。 程式碼如下： 1234567891011describe('add insured button', () =&gt; { it('should trigger function `addInsured` after being clicked', () =&gt; { // Arrange const addButtonElement = compiledComponent.querySelector('p:last-child button[type=\"button\"]') as HTMLElement; spyOn(component, 'addInsured'); // Act addButtonElement.click(); // Assert expect(component.addInsured).toHaveBeenCalled(); });}); 測試結果： 送出按鈕的驗證最後，送出按鈕要驗證的項目是： 屬性 type 的值要是 submit 沒有任何被保人時，送出按鈕皆呈現不可被點選之狀態 任一個被保人的驗證有誤時，送出按鈕皆呈現不可被點選之狀態 當所有的被保人資料皆正確時，按下送出按鈕要能觸發函式 submit 程式碼如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960describe('submit button', () =&gt; { let buttonElement: HTMLButtonElement; beforeEach(() =&gt; { buttonElement = compiledComponent.querySelector('button[type=\"submit\"]') as HTMLButtonElement; }); it('should be existing', () =&gt; { // Assert expect(buttonElement).toBeTruthy(); }); it('should be disabled when there are not any insureds', () =&gt; { // Assert expect(buttonElement.hasAttribute('disabled')).toBe(true); }); describe('When there is a insured', () =&gt; { let formGroup: FormGroup; beforeEach(() =&gt; { const nameControl = new FormControl('', [ Validators.required, Validators.minLength(2), Validators.maxLength(10) ]); const genderControl = new FormControl('', Validators.required); const ageControl = new FormControl('', Validators.required); formGroup = new FormGroup({ name: nameControl, gender: genderControl, age: ageControl }); component.formArray.push(formGroup); fixture.detectChanges(); }); it('should be disabled when there ara any verifying errors that insured\\'s data', () =&gt; { // Arrange compiledComponent.querySelector('button[type=\"submit\"]') // Act fixture.detectChanges(); // Assert expect(buttonElement.hasAttribute('disabled')).toBe(true); }) it('should be enabled when there ara any verifying errors that insured\\'s data', () =&gt; { // Arrange formGroup.patchValue({ name: 'Leo', gender: 'male', age: '18', }); // Act fixture.detectChanges(); // Assert expect(buttonElement.hasAttribute('disabled')).toBe(false); }) });}); 測試結果： 至此，我們就完成了整合測試的部份囉！ 今天所有的測試結果： 本日小結今天一樣主要是讓大家練習，提昇撰寫測試的熟悉度，該講的重點應該在之前的文章都有提到。 不過我相信大家應該寫差不多類型的測試寫到有點索然無味了，所以我明天不會讓大家寫測試，而是會總結一下 Template Driven Forms 與 Reactive Forms 這兩種開發方式的優缺點，敬請期待。 今天的實作程式碼會放在 Github - Branch: day15 供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，也都非常歡迎留言給我讓我知道噢！","link":"/2021/09/30/angular-30days-form-and-test-15/"},{"title":"Angular 深入淺出三十天：表單與測試 Day18 - 與 Cypress 的初次見面（上）","text":"昨天跟大家分享了 Cypress 有多厲害之後，大家有沒有很期待呢？ 這兩天就讓我來跟大家介紹 Cypress 到底有多厲害吧！ 由於 Cypress 的功能非常地豐富且強大，所以我打算分成兩篇來介紹它，希望可以讓大家感受到它的魅力。 安裝 Cypress要開始使用它之前，當然要先安裝它囉！ 首先，我們新增一個空的資料夾，然後在終端機中輸入以下指令以進入該資料夾： 1$ cd /your/project/path 接著輸入以下指令以完成初始化： 1$ npm init 大家也可以選擇現有的專案，只要有 package.json 這個檔案即可。 然後輸入以下指令以安裝 1$ npm install cypress --save-dev 安裝完成之後，你會發現你的專案除了 package.json 有變動之外，就沒有其他變動了。 別擔心！這不是因為你做錯了什麼，純粹就是 Cypress 剛安裝完就是這樣，接著我們可以先打開 package.json ，並且在 scripts 的區段加上這個指令： 12345{ \"scripts\": { \"cy:open\": \"cypress open\" }} 大家不一定要像我一樣叫 cy:open ，可以自己取自己想要的名字，只要後面的 cypress open 不變即可。 修改好並儲存後，我們就可以在終端機裡以下指令以啟動 Cypress ： 1$ npm run cy:open 或者是 1$ yarn cy:open 初次執行時，Cypress 會知道你這個專案第一次執行它： 然後幫你產生出 cypress.json 與名為 cypress 的資料夾，並幫你開啟一個長這樣的小視窗： 這就表示我們順利完成 Cypress 的安裝囉！是不是超簡單的呢？！ 資料夾結構介紹接下來我們先來看看 Cypress 到底幫我們產生了些什麼檔案。 cypress.json當大家點開它的時候應該會嚇一跳，因為剛開始時，它裡面就只有這樣： 1{} 第一次使用 Cypress 的朋友應該會多少覺得有點錯愕，不知道這個檔案到底要用來幹嘛。 其實這個檔案是 Cypress 的設置檔，有關 Cypress 全局的配置都會在這裡設定。 那到底有哪些設定可以配置呢？ 關於這點大家其實可以看官方的 Configuration 文件，裡面寫得非常清楚，我就不再贅述。 而且裡面的設定非常地多，雖然不一定都會用到，但也由此可見 Cypress 的功能是多麼地強大。 接下來，點開 cypress 資料夾後你會發現裡面還有四個名為 fixtures 、 integration 、 plugins 、 supports 的資料夾。 fixtures這個資料夾主要是用來放一些在撰寫測試案例時，可能會常用到或共用的資料。例如：固定會輸入的帳密、固定會驗證的使用者資訊等等，並以 JSON 的形式存在。 後續使用時，大多會在 .spec.js 裡用像這樣子的方式直接引用： 1const requiredExample = require('../../fixtures/example'); integration這個資料夾是我們用來擺放 .spec.js 的地方。 比較值得一提的是，由於 Cypress 可以平行地執行多個不同的 .spec.js，所以我們在寫測試案例時可以善加利用此點，將不同系統或不會有依賴的測試分成不同的 .spec.js 來撰寫。 不過要反向思考的是，不同的測試檔之間就更不可以有依賴關係了。 plugins這個資料夾裡有一個 index.js ，當我們需要用到一些外掛模組的時候，就會需要到這裡面來設定，例如我們可能會需要在驗證重設密碼這個功能時，要到信箱裡去確認是否有收到信、點開重設密碼的連結等等。 這點如果真的要仔細介紹起來可能會需要花一到兩篇的篇幅，所以如果大家有興趣的話，可以直接看官網的 Write a Plugin 來學習怎麼樣撰寫與使用 Plugin。 此外，官方也有列出它們精選的 Plugin 供大家參考與使用。 support在 Cypress 裡，我們都是使用 cy.xxx 的方式來操作 Cypress 提供的 API ，而這些 API 在 Cypress 我們叫做 Command 。 雖然 Cypress 有提供許多的 Command 讓我們使用，不過我們其實也可以自定我們想要的 Command ，令我們在寫測試時更加地方便與輕鬆。 而這個資料夾就是用來擺放這些我們自定 Command 的地方。 打開資料夾後我們會看到裡面有兩個檔案 ─ index.js 與 commands.js ，其中的 commands.js 裡就是我們自定 Command 的地方。 而 index.js 則是用來 import 我們自定 Command 的檔案，執行時 Cypress 會自己從這裡去找到測試案例所需要用到的 Command ，不用特別在測試案例裡 import 。 在檔案命名上，當然也不一定要叫 commands.js ，你可以自己取你想要的檔名，只要記得在 index.js 裡 import 即可。 除了自定 Command 外，其實我們還可以覆寫既有的 Command ，語法大家可以參考官方的 Custom Commands 文件，後續我也會再分享給大家。 介紹完 Cypress 的資料夾結構後，我們回頭來看看 Cypress 打開的小視窗是什麼玩意兒吧！ Cypress Test Runner 這個小視窗其實是 Cypress Test Runner 所開啟的一個小視窗，一般開發時我們會使用 cypress open 的指令來啟動這個 Test Runner 的小視窗以便開發。 現在大家看到畫面中會有許多檔案，而這些檔案其實都是位於 /cypress/integration 之中， Test Runner 啟動時會幫我們把它們抓出來並顯示在上圖的列表中。 當我們想要測試某一個檔案裡的測試案例時，就只要點擊該檔案的名稱即可。 大家可以先點點看、玩玩看，點擊之後會做的事情我會在明天將它們更仔細地介紹給大家。 而這個 Test Runner 的小視窗其實有滿多滿強大的功能，例如在小視窗的右上角有個下拉選單可以選擇想要測試的瀏覽器： 這些瀏覽器是 Cypress 自動從你的作業系統中抓取的，只要你的作業系統有安裝 Cypress 所支援的瀏覽器，它就會成為這個下拉選單的選項。 想知道更多更詳細的資訊可以參考官方的 Launching Browsers 文件。 此外， 小視窗的上方有三個頁籤： Tests 、 Runs 、 Settings ，當前的畫面所顯示的是 Tests 的頁籤，我們點擊 Settings 的頁籤之後會看到以下畫面： 這邊比較重要且常用的會是 Configuration 的區塊，我們一樣點開它之後會看到許多設定： 我覺得這個功能非常地方便，因為這邊所顯示的設定是我們可以在 cypress.json 或者是 cypress.env.json 裡配置的所有設定。 有了這個之後，不用再為了找有哪些設定可以使用去看官網文件，甚至也透過不同顏色來得知當前的配置是來自於哪裡，非常地貼心！ 至於 Configuration 後面的區塊， Node.js Version 是可以顯示目前所執行的 node 的版本： 細節可參考官方的 Configuration - Node Version 文件。 Proxy Settings 則是顯示目前的 Proxy 相關設定： 想知道如何設定 Proxy 可參考官方的 Proxy Configuration 文件。 File Opener Preference 則是可以設定你想要用什麼軟體來開啟測試檔（因為在測試中可以透過點擊檔名來開啟該檔案）： 詳細請參考官方的 IDE Integration - File Opener Preference 文件。 最後 Experiments 則是顯示目前尚在實驗階段的設定： 詳細請參考官方的 Experiments 文件。 那 Runs 是做什麼用的呢？ 這邊是如果你有使用它們家的 Dashboard 服務的話，可以直接在這邊看到歷史的執行結果。 Dashboard 服務？這又是什麼東西？ Cypress DashboardCypress Dashboard 是 Cypress 它們家所提供的服務，主要是方便我們在使用 Cypress 來執行完自動化的 E2E 的測試後，把結果上傳到這裡來，已供後續觀測與整合第三方工具所用。 這又是一個很強大的工具，如果要介紹它又得花一整篇的文章，不過由於官網其實有非常詳盡的說明與影片，而且大家其實可以自己登入進去玩玩看，連結在這裡：https://dashboard.cypress.io/login 。 至於這個服務的收費方式，大家可以看這邊：https://dashboard.cypress.io/organizations/48db8376-6414-489b-b988-92233f50e335/pricing 。 想知道更詳細的資訊可以看官方的 Dashboard Introduction 文件。 不過值得一提的是，其實有個開源的工具叫做 Sorry Cypress ，它可以說是免費版的 Cypress Dashboard ，主要的核心功能如平行執行測試、儲存歷史執行結果等都有，不過在介面的設計上比較陽春一些些、最重要的是需要自己架設、自己設定。 我覺得這就像我們自己架設 Jenkins 與使用別人所提供的 CI 工具如 Circle CI 的概念很像，就看我們的需求來決定要選擇哪一種工具囉！ 本日小結今天主要是跟大家介紹 Cypress 的基礎功能面，我想讓大家在對它有個基本的了解之後，接下來我們在使用時會比較知道它在幹嘛、有哪些功能，不會忽然講到一個功能之後要忽然中斷原本的進度來解釋它。 而明天的文章會著重在 Cypress 的 Test Runner 上（今天只有介紹到一小部分的功能），敬請期待！！ 如果你有任何的問題或是回饋，還請麻煩留言給我讓我知道，感謝大家！","link":"/2021/10/03/angular-30days-form-and-test-18/"},{"title":"Angular 深入淺出三十天：表單與測試 Day13 - 整合測試實作 - 被保人 by Template Driven Forms","text":"昨天幫我們用 Template Driven Forms 所撰寫的被保人表單寫完單元測試之後，今天則是要來為它寫整合測試。 大家還記得整合測試的目標是要測什麼嗎？我幫大家複習一下： 整合測試的測試目標是要測是兩個或是兩個以上的類別之間的互動是否符合我們的預期。 實作開始首先我們先增加一個 Integration testing 的區塊，有關於整合測試的程式碼接下來都會放在這裡面，至於昨天的就放在 Unit testing 的區塊： 1234567891011describe('TemplateDrivenFormsAsyncInsuredComponent', () =&gt; { // 其他省略... describe('Unit testing', () =&gt; { // 昨天寫的單元測試... }); describe('Integration testing', () =&gt; { // 今天要寫的整合測試 });}); 跟之前樣先打開 .html 來看一下目前的程式碼： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;form&gt; &lt;fieldset *ngFor=\"let insured of insuredList; let index = index; trackBy: trackByIndex\"&gt; &lt;legend&gt;被保人&lt;/legend&gt; &lt;p&gt; &lt;label [for]=\"'name-' + index\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" [name]=\"'name-' + index\" [id]=\"'name-' + index\" required maxlength=\"10\" minlength=\"2\" #nameNgModel=\"ngModel\" [ngModel]=\"insured.name\" (ngModelChange)=\"insuredNameChange(nameNgModel.control, insured)\" /&gt; &lt;span class=\"error-message\"&gt;{{ insured.nameErrorMessage }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 性別： &lt;input type=\"radio\" [name]=\"'gender-' + index\" [id]=\"'male-' + index\" value=\"male\" required [(ngModel)]=\"insured.gender\" &gt; &lt;label [for]=\"'male-' + index\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" [name]=\"'gender-' + index\" [id]=\"'female-' + index\" value=\"female\" required [(ngModel)]=\"insured.gender\" &gt; &lt;label [for]=\"'female-' + index\"&gt;女&lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label [for]=\"'age-' + index\"&gt;年齡：&lt;/label&gt; &lt;select [name]=\"'age-' + index\" [id]=\"'age-' + index\" required #ageNgModel=\"ngModel\" [ngModel]=\"insured.age\" (ngModelChange)=\"insuredAgeChange(ageNgModel.control, insured)\" &gt; &lt;option value=\"\"&gt;請選擇&lt;/option&gt; &lt;option value=\"18\"&gt;18歲&lt;/option&gt; &lt;option value=\"20\"&gt;20歲&lt;/option&gt; &lt;option value=\"70\"&gt;70歲&lt;/option&gt; &lt;option value=\"75\"&gt;75歲&lt;/option&gt; &lt;/select&gt; &lt;span class=\"error-message\"&gt;{{ insured.ageErrorMessage }}&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;button type=\"button\" (click)=\"deleteInsured(index)\"&gt;刪除&lt;/button&gt;&lt;/p&gt; &lt;/fieldset&gt; &lt;p&gt; &lt;button type=\"button\" (click)=\"addInsured()\"&gt;新增被保險人&lt;/button&gt; &lt;button type=\"submit\" [disabled]=\"isFormInvalid\"&gt;送出&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 大家有看出來要測什麼了嗎？我來幫大家整理一下要測的項目： 姓名欄位 屬性 type 的值要是 text 屬性 name 的值要是 name-N 屬性 minlength 的值要是 2 屬性 maxlength 的值要是 10 要有屬性 required 要將被保人的屬性 name 的值綁定到此欄位上 此欄位的值如果有變動，要能觸發函式 insuredNameChange 性別欄位 屬性 type 的值要是 radio 屬性 name 的值要是 gender-N 要有屬性 required 要將被保人的屬性 gender 的值綁定到此欄位上 年齡欄位 屬性 name 的值要是 age-N 要有屬性 required 要將被保人的屬性 age 的值綁定到此欄位上 此欄位的值如果有變動，要能觸發函式 insuredAgeChange 錯誤訊息 要將被保人的的屬性 nameErrorMessage 的值綁定到畫面上 要將被保人的的屬性 ageErrorMessage 的值綁定到畫面上 新增被保人按鈕 按下按鈕要能觸發函式 addInsured 刪除被保人按鈕 按下按鈕要能觸發函式 deleteInsured 送出按鈕 屬性 type 的值要是 submit 沒有任何被保人時，送出按鈕皆呈現不可被點選之狀態 任一個被保人的驗證有誤時，送出按鈕皆呈現不可被點選之狀態 當所有的被保人資料皆正確時，按下送出按鈕要能觸發函式 submit 把要測的項目都列出來之後，有沒有覺得要測的項目很多阿？哈哈！ 再次跟大家說明，雖然上面這些項目有些其實並不真的屬於整合測試的範圍，但我個人會在這時候一起測，因為這樣可以省下一些重複的程式碼。 此外，開始之前也別忘記先做以下程式碼所展示的前置作業： 12345678910describe('Integration testing', () =&gt; { let compiledComponent: HTMLElement; beforeEach(() =&gt; { fixture.detectChanges(); compiledComponent = fixture.nativeElement; }); // 案例寫在這邊}); 姓名欄位的驗證複習一下姓名欄位的驗證項目： 屬性 type 的值要是 text 屬性 name 的值要是 name-N 屬性 minlength 的值要是 2 屬性 maxlength 的值要是 10 要有屬性 required 要將被保人的屬性 name 的值綁定到此欄位上 此欄位的值如果有變動，要能觸發函式 insuredNameChange 接下來就把姓名欄位要驗證的項目寫成測試案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081describe('the insured fields', () =&gt; { beforeEach(() =&gt; { component.insuredList = [{ name: '', gender: '', age: '', nameErrorMessage: '', ageErrorMessage: '' }]; fixture.detectChanges(); }); describe('the name input field', () =&gt; { const key = 'name-0' let nameInputElement: HTMLInputElement; beforeEach(() =&gt; { nameInputElement = compiledComponent.querySelector(`#${key}`)!; }); it('should have attribute \"type\" and the value is \"text\"', () =&gt; { // Arrange const attributeName = 'type'; const attributeValue = 'text'; // Assert expect(nameInputElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"name\" and the value is \"name-0\"', () =&gt; { // Arrange const attributeName = 'ng-reflect-name'; const attributeValue = key; // Assert expect(nameInputElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"minlength\" and the value is \"2\"', () =&gt; { // Arrange const attributeName = 'minlength'; const attributeValue = '2'; // Assert expect(nameInputElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"maxlength\" and the value is \"10\"', () =&gt; { // Arrange const attributeName = 'maxlength'; const attributeValue = '10'; // Assert expect(nameInputElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"required\"', () =&gt; { // Arrange const attributeName = 'required'; // Assert expect(nameInputElement.hasAttribute(attributeName)).toBe(true); }); it('should binding the value of the insured\\'s property \"name\"', () =&gt; { // Arrange const name = 'whatever'; // Act component.insuredList[0].name = name; fixture.detectChanges(); // Assert expect(nameInputElement.getAttribute('ng-reflect-model')).toBe(name); }); it('should trigger function \"insuredNameChange\" when the value be changed', () =&gt; { // Arrange spyOn(component, 'insuredNameChange'); const nameFormControl = component.nameNgModelRefList.get(0)!.control; // Act nameInputElement.value = 'whatever'; nameInputElement.dispatchEvent(new Event('ngModelChange')); // Assert expect(component.insuredNameChange).toHaveBeenCalledWith(nameFormControl, component.insuredList[0]); }); });}); 測試結果： 這段程式碼中有幾個重點： 為了之後測其他欄位，我多新增了一個 test insured fields 的 describe 。這是因為要驗證這些欄位之前，一定要先讓被保人的表單長出來，所我才會多包一層，並把大家都會做的事情拉到這層的 beforeEach 來做。 should have attribute &quot;name&quot; and the value is &quot;name-0&quot; 這個測試案例要記得我們在 Template 綁定時是用 [name] 的方式綁定，所以在驗證的時候是抓 ng-reflect-name ，如果單純抓 name 來驗是會報錯的噢！ should trigger function &quot;insuredNameChange&quot; when the value be changed 最後這個測試案例比較特別，不知道大家還記不記得上次寫這裡的時候，我有介紹過關於 Spy 的事情與怎麼用 @ViewChild 抓 Template 中的 nameFormControl ？ 如果不記得的話，趕快回去第七天的文章複習一下！ 上次用的 @ViewChild 是抓取單一的元素，但這次是複數的怎辦？ 答案是 ─ @ViewChildren 。 有沒有一種寫 Angular 還可以學英文的感覺？ 只要我們像這樣在程式碼中加上這個 Angular 的裝飾器： 1234export class TemplateDrivenFormsAsyncInsuredComponent { @ViewChildren('nameNgModel') nameNgModelRefList!: QueryList&lt;NgModel&gt;; // ...} Angular 就會在每次渲染完畫面之後，幫我們抓取有在 HTML 的屬性中加上 #nameNgModel 的所有元素，而抓出來的元素會用 Angular 所包裝的類別 ─ QueryList 包起來，以利我們使用。 性別欄位的驗證性別欄位的驗證項目如下： 男生 屬性 type 的值要是 radio 屬性 name 的值要是 male-N 屬性 value 的值要是 male 要有屬性 required 要將被保人的屬性 gender 的值綁定到此欄位上 女生 屬性 type 的值要是 radio 屬性 name 的值要是 female-N 屬性 value 的值要是 female 要有屬性 required 要將被保人的屬性 gender 的值綁定到此欄位上 測試程式碼如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697describe('the gender radio buttons', () =&gt; { let radioButtonElement: HTMLInputElement; describe('male', () =&gt; { beforeEach(() =&gt; { radioButtonElement = compiledComponent.querySelector(`#male-0`)!; }); it('should have attribute \"type\" and the value is \"radio\"', () =&gt; { // Arrange const attributeName = 'type'; const attributeValue = 'radio'; // Assert expect(radioButtonElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"name\" and the value is \"gender-0\"', () =&gt; { // Arrange const attributeName = 'ng-reflect-name'; const attributeValue = 'gender-0'; // Assert expect(radioButtonElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"value\" and the value is \"male\"', () =&gt; { // Arrange const attributeName = 'value'; const attributeValue = 'male'; // Assert expect(radioButtonElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"required\"', () =&gt; { // Arrange const attributeName = 'required'; // Assert expect(radioButtonElement.hasAttribute(attributeName)).toBe(true); }); it('should binding the value of the insured\\'s property \"gender\"', () =&gt; { // Arrange const gender = 'male'; // Act component.insuredList[0].gender = gender; fixture.detectChanges(); // Assert expect(radioButtonElement.getAttribute('ng-reflect-model')).toBe(gender); }); }); describe('female', () =&gt; { beforeEach(() =&gt; { radioButtonElement = compiledComponent.querySelector(`#female-0`)!; }); it('should have attribute \"type\" and the value is \"radio\"', () =&gt; { // Arrange const attributeName = 'type'; const attributeValue = 'radio'; // Assert expect(radioButtonElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"name\" and the value is \"gender-0\"', () =&gt; { // Arrange const attributeName = 'ng-reflect-name'; const attributeValue = 'gender-0'; // Assert expect(radioButtonElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"value\" and the value is \"female\"', () =&gt; { // Arrange const attributeName = 'value'; const attributeValue = 'female'; // Assert expect(radioButtonElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"required\"', () =&gt; { // Arrange const attributeName = 'required'; // Assert expect(radioButtonElement.hasAttribute(attributeName)).toBe(true); }); it('should binding the value of the insured\\'s property \"gender\"', () =&gt; { // Arrange const gender = 'female'; // Act component.insuredList[0].gender = gender; fixture.detectChanges(); // Assert expect(radioButtonElement.getAttribute('ng-reflect-model')).toBe(gender); }); });}); 這邊的測試雖然簡單，但我還是遇到了一個問題：「怎麼驗雙向綁定裡，關於 ngModelChange 的部份」。 我的預期是我點擊了某個性別的單選鈕之後，它會把值指定給被保人的 gender 欄位。 但我試了好幾種驗法，也查了老半天資料，就是沒辦法成功（攤手），如果有朋友成功驗出來，請麻煩在下方留言分享一下，感謝！ 測試結果： 年齡欄位的驗證年齡欄位的驗證項目如下： 屬性 name 的值要是 age-N 要有屬性 required 要將被保人的屬性 age 的值綁定到此欄位上 此欄位的值如果有變動，要能觸發函式 insuredAgeChange 程式碼如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344describe('the age field', () =&gt; { const key = 'age-0' let ageSelectElement: HTMLSelectElement; beforeEach(() =&gt; { ageSelectElement = compiledComponent.querySelector(`#${key}`)!; }); it('should have attribute \"name\" and the value is \"age-0\"', () =&gt; { // Arrange const attributeName = 'ng-reflect-name'; const attributeValue = key; // Assert expect(ageSelectElement.getAttribute(attributeName)).toBe(attributeValue); }); it('should have attribute \"required\"', () =&gt; { // Arrange const attributeName = 'required'; // Assert expect(ageSelectElement.hasAttribute(attributeName)).toBe(true); }); it('should binding the value of the insured\\'s property \"age\"', () =&gt; { // Arrange const age = '18'; // Act component.insuredList[0].age = age; fixture.detectChanges(); // Assert expect(ageSelectElement.getAttribute('ng-reflect-model')).toBe(age); }); it('should trigger function \"insuredAgeChange\" when the value be changed', () =&gt; { // Arrange spyOn(component, 'insuredAgeChange'); const ageNgModel = component.ageNgModelRefList.get(0)!; // Act ageSelectElement.value = '18'; ageSelectElement.dispatchEvent(new Event('ngModelChange')); // Assert expect(component.insuredAgeChange).toHaveBeenCalledWith(ageNgModel.value, ageNgModel.errors, component.insuredList[0]); });}); 年齡欄位的驗證跟姓名的驗證有 87% 像，複製過來再稍微調整一下即可。 測試結果： 錯誤訊息的驗證錯誤訊息要驗證的項目是： 要將被保人的屬性 nameErrorMessage 的值綁定到畫面上 要將被保人的屬性 ageErrorMessage 的值綁定到畫面上 測試程式碼如下： 12345678910111213141516171819202122232425describe('Error Messages', () =&gt; { it('should binding the value of the insured\\'s property \"nameErrorMessage\" in the template', () =&gt; { // Arrange const insured = component.insuredList[0]; const errorMessage = 'account error'; const targetElement = compiledComponent.querySelector('#name-0 + .error-message'); // Act insured.nameErrorMessage = errorMessage; fixture.detectChanges(); // Assert expect(targetElement?.textContent).toBe(errorMessage); }); it('should binding the value of the insured\\'s property \"ageErrorMessage\" in the template', () =&gt; { // Arrange const insured = component.insuredList[0]; const errorMessage = 'password error'; const targetElement = compiledComponent.querySelector('#age-0 + .error-message'); // Act insured.ageErrorMessage = errorMessage; fixture.detectChanges(); // Assert expect(targetElement?.textContent).toBe(errorMessage); });}); 錯誤訊息的驗證也非常簡單，大家應該都能輕鬆驗證！ 測試結果： 刪除按鈕的驗證刪除被保人按鈕要驗證的是：按下按鈕要能觸發函式 deleteInsured 。這部份大家只要使用 Spy 的技巧來驗證即可，也是頗為簡單。 程式碼如下： 123456789101112describe('Delete insured button', () =&gt; { it('should trigger function `deleteInsured` after being clicked', () =&gt; { // Arrange const index = 0; const deleteButtonElement = compiledComponent.querySelector('fieldset button[type=\"button\"]') as HTMLElement; spyOn(component, 'deleteInsured'); // Act deleteButtonElement.click(); // Assert expect(component.deleteInsured).toHaveBeenCalledWith(index); });}); 測試結果： 新增被保人按鈕的驗證新增被保人按鈕要驗證的是：按下按鈕要能觸發函式 addInsured ，跟刪除被保人的按鈕要驗證的項目幾乎是一模一樣，複製過來稍微修改一下即可。 程式碼如下： 1234567891011describe('add insured button', () =&gt; { it('should trigger function `addInsured` after being clicked', () =&gt; { // Arrange const addButtonElement = compiledComponent.querySelector('p:last-child button[type=\"button\"]') as HTMLElement; spyOn(component, 'addInsured'); // Act addButtonElement.click(); // Assert expect(component.addInsured).toHaveBeenCalled(); });}); 測試結果： 送出按鈕的驗證最後，送出按鈕要驗證的項目是： 屬性 type 的值要是 submit 沒有任何被保人時，送出按鈕皆呈現不可被點選之狀態 任一個被保人的驗證有誤時，送出按鈕皆呈現不可被點選之狀態 當所有的被保人資料皆正確時，按下送出按鈕要能觸發函式 submit 程式碼如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748describe('submit button', () =&gt; { let buttonElement: HTMLButtonElement; beforeEach(() =&gt; { buttonElement = compiledComponent.querySelector('button[type=\"submit\"]') as HTMLButtonElement; }); it('should be existing', () =&gt; { // Assert expect(buttonElement).toBeTruthy(); }); it('should be disabled when \"insuredList\" is empty array', () =&gt; { // Assert expect(buttonElement.hasAttribute('disabled')).toBe(true); }); it('should be disabled when there ara any verifying errors that insured\\'s data', () =&gt; { // Arrange component.insuredList = [{ name: 'A', gender: '', age: '', nameErrorMessage: '', ageErrorMessage: '' }]; compiledComponent.querySelector('button[type=\"submit\"]') // Act fixture.detectChanges(); // Assert expect(buttonElement.hasAttribute('disabled')).toBe(true); }) it('should be enabled when there ara any verifying errors that insured\\'s data', () =&gt; { // Arrange component.insuredList = [{ name: 'Leo', gender: 'male', age: '18', nameErrorMessage: '', ageErrorMessage: '' }]; // Act fixture.detectChanges(); // Assert expect(buttonElement.hasAttribute('disabled')).toBe(false); })}); 測試結果： 咦？怎麼會有 Error 咧？原來這個問題跟上次我們寫登入表單的整合測試所遇到的情況一樣。 所以我們目前先在這個案例的 it 的前面加上一個 x ，代表我們要 ignore 這個案例的意思，像這樣： 123xit('should be disabled when there ara any verifying errors that insured\\'s data', () =&gt; { // 省略...}) 測試結果： 至此，我們就完成了整合測試的部份囉！ 今天所有的測試結果： 本日小結其實今天用所有用到的測試手法與概念都在之前的的文章就已經分享過了，今天主要是讓大家練習，提昇撰寫測試的熟悉度。 明天我們要為用 Reactive Forms 所撰寫的被保人表單來撰寫單元測試，我覺得大家可以在看我的文章之前先自己寫寫看，之後再參考我的文章，一定會有更多的收穫！ 今天的實作程式碼會放在 Github - Branch: day13 供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，也都非常歡迎留言給我讓我知道噢！","link":"/2021/09/28/angular-30days-form-and-test-13/"},{"title":"Angular 深入淺出三十天：表單與測試 Day16 - Template Driven Forms vs Reactive Forms","text":"這段期間，我們用 Template Driven Forms 與 Reactive Forms 各自做了一個登入表單（靜態）與被保人表單（動態），而且我們也都為這些表單寫了單元測試與整合測試，大家應該對於這兩種開發表單的方式有一定的認知與體會。 因此，我們今天來將這兩種開發表單的方式做個小結與比較，順便沉澱一下這段時間的學習成果。 Template Driven Forms vs Reactive Forms一般我們在對比這兩個開發表單的方式時，會用以下三個面向來分析優劣： 開發難易度 維護難易度 測試難易度 開發難易度開發難易度指的是，開發者分別使用這兩種開發表單的方式開發同一個表單時的難易程度。 而這段時間，我也讓大家跟著我一起分別使用這兩種開發表單的方式開發了兩個表單，大家可以自己在心裡比較看看。 Template Driven FormsTemplate Driven Forms 的方式很接近前端原始寫法，資料的驗證與限制都是使用 HTML 原生的表單機制，只是再額外加上 Angular 的資料綁定機制與範本語法來處理，對於剛開始使用框架的初學者較為友善。 就像這樣： 123456789101112&lt;input type=\"email\" name=\"account\" id=\"account\" required pattern=\"\\b[\\w\\.-]+@[\\w\\.-]+\\.\\w{2,4}\\b\" #accountNgModel=\"ngModel\" [ngModel]=\"account\" (ngModelChange)=\" accountValueChange(accountNgModel.value, accountNgModel.errors) \"/&gt; Reactive FormsReactive Forms 的方式則是直接用程式來創建與操作表單物件 ─ FormGroup ，然後再把相應的 FormControl 綁定到畫面上的表單欄位。 就像這樣 12345const data = { account: ['', [ /* Validators... */]] password: ['', [ /* Validators... */]]};const formGroup = this.formBuilder.group(data); 123456789101112&lt;form [formGroup]=\"formGroup\"&gt; &lt;input type=\"email\" id=\"account\" formControlName=\"account\" /&gt; &lt;input type=\"password\" id=\"password\" formControlName=\"password\" /&gt;&lt;/form&gt; 與 Template Driven Forms 相比，大部分的程式新手會覺得較為抽象，且會有相對來說比較多較困難、較不習慣的觀念要熟悉，學習成本較高。 此外，如果有遇到更複雜的連動邏輯、更動態的表單，會比較需要對 RxJS 有更進一步的認知。 開發難易度小結大部分剛學 Angular 的朋友應該都會覺得 Template Driven Forms 比較簡單，不過雖然一開始做的時候好像很簡單且自然，但表單一複雜起來，那沱 HTML 實在是會有點慘不忍睹。 這還是因為我們這段時間所做的表單其實很陽春、很簡單，如果我們要做的是有著更複雜的連動邏輯、更動態的表單，光想到要處理一堆事情就頭皮發麻、冷汗狂流。 而 Reactive Forms 初接觸時好像感覺很難，但隨著熟悉度的提升，大家一定會覺得它越來越好用，用它來開發又快又輕鬆，尤其當要做的表單越複雜、越動態時，更能體會它的美好。 我自己一開始使用 Angular 的時候也是只會使用 Template Driven Forms 的開發方式來開發，甚至還實作過頗為複雜的動態表單。直到我學會了使用 Reactive Forms 的開發方式之後，才發現之前做的表單有多麼可怕。 維護難易度我這邊的維護難易度主要指的是以擴充性、重用性這兩種面向來比較這兩種開發方式的難易程度。 Template Driven Forms以擴充性來說，假如我們一起開發過被保人表單需要新增一個產品欄位，並增加年齡與產品之間的互動邏輯時，除了要在 Template 上新增一個產品欄位與其必須的驗證之外，在 Component 裡也需要加上相應欄位有變動時，與其他欄位的互動、提示訊息的邏輯。 以重用性來說，假如今天有同樣的表單欄位與驗證邏輯要在別的地方使用，但是畫面可能會長得很不一樣，抑或是只是其他表單裡的其中幾個欄位，這時為了要重用也會需調整不少程式碼。 好一點的情況可能只需要將這些欄位包裝起來並增加 input/output 的邏輯，差一點的情況大概就連重用都很困難，只能盡量把能抽的邏輯抽離，又或者把他們抽成最小最不會有影響的 Component 來使用。 Reactive Forms以擴充性來說，不管是要新增欄位還是調整結構，由於 Reactive Forms 本身就是用程式來建立表單，所以基本上都只需要在程式裡處理好，而 Template 就只是很簡單的增加該增加的欄位、並給予相應的綁定而已，如 formContorlName=&quot;xxx&quot; ，輕鬆自在。 以重用性來說，這件事在 Reactive Forms 看來更是小菜一碟。本來就是用程式建立表單的它，本身基本就具備非常良好的重用性，就算要把原本的表單抽成最小單位的 FormControl ，也只是像樂高積木一樣，需要的時候再組合起來就好。 維護難易度小結簡單來說， Template Driven Forms 的開發方式有點像在煮義大利麵，煮完之後就很難去分離，雖然麵依然是麵、醬汁依然是醬汁，但麵已飽富醬汁、醬汁也難以再還原回原本的食材。 而 Reactive Forms 就像是樂高積木，具有豐富的可變性與卓越的彈性，你想要怎麼組合都可以，就算拼成樂高版的義大利麵，也是說拆就拆、說散就散。 雖然整體來說還是要看個人的功力，但就同一個人用這兩種方法來比較的話，應該還是會有差不多的結果。 測試難易度測試嚴格來說應該是維護中的一環，因為每當程式碼有調整時，或者是需求有調整時，都有可能會影響到測試。 不過此處特別提出來比較主要是想要只在撰寫測試這件事情上來比較這兩種方式的難易度，尤其是我們這段時間總計寫了八篇的測試，大家應該會比較能感同身受。 Template Driven FormsTemplate Driven Forms 在撰寫測試上也因為其方式很接近前端原始寫法的關係，我覺得還算好寫，只要檢查元素的屬性與其值即可。 但由於 Template Driven Forms 比較不可控，且其更新時機是非同步且比較不可預測的關係，造成想要把它的測試寫得很好並不容易。 就拿我們寫過的測試來說，我們在第七天與第十三天時，都有著過相同的問題，而這問題，說不定其實是我寫不好，並不是框架本身的問題。 所以說，在某些特定情境下的測試案例，要寫得好其實並不容易。 Reactive Forms而 Reactive Forms 的更新時機基本上是同步且可預測的，有什麼變化就可以直接驗證到，畢竟它本身就是用程式來建立表單，可控性很高。 同樣地拿我們寫過的測試來說，相信大家應該都沒有遇到什麼問題，不知道大家是否也覺得它的測試案例相對好寫呢？ 測試難易度小結撰寫測試的難易度其實很大程度地影響了開發人員是否會持續撰寫或維護測試程式的意願。 所以對開發人員來說，當然是越容易越好。 本日小結今天主要是想明確地讓大家知道 Template Driven Forms 與 Reactive Forms 之間的不同與更清楚地對比，讓大家未來在遇到需要製作表單的情境時，可以根據需求來選擇最適合的方式。 下表總結了 Template Driven Forms 與 Reactive Forms 的不同之處： &nbsp; Reactive Forms Template Driven Forms 表單模型的設置 清楚的，在 Component 裡建立 隱晦的，用 Directive 建立 資料模型 有結構性且不變的 鬆散且容易改變 可預測性 同步的 非同步的 表單驗證方式 用函式驗證 用 Directive 驗證 雖說這段時間有分享如何使用 Template Driven Forms 的方式來開發表單，不過我個人在遇到要製作表單的情境時，其實都是選擇用 Reactive Forms 的方式來開發，因為實在是真的太好寫了！ 此外，我們的後續文章也將不會再分享 Template Driven Forms 的開發方式，而是會用 Reactive Forms 的方式來分享更多更進階的用法，讓大家可以因應更複雜、更動態的情境。 如果你有任何的問題或是回饋，還請麻煩留言給我讓我知道，感謝大家！","link":"/2021/10/01/angular-30days-form-and-test-16/"},{"title":"Angular 深入淺出三十天：表單與測試 Day17 - E2E 自動化測試工具簡介","text":"在這個各種前端框架、開發工具層出不窮、百花齊放、百鳥齊鳴的美好時代， E2E 自動化測試工具的選擇自然也很多。 今天我們會先來初步了解一下目前有哪些 E2E 自動化測試工具，讓大家在未來需要時，能夠以最短的時間找到最貼近自己需求的工具。 Selenium Selenium 是老牌的測試工具，出道已久且頗富盛名的它擁有豐富的 API 與衍生的工具軟體，可使用許多種語言撰寫，如：C#、JavaScript、Java、 Python 、 Ruby 。 主要是藉由 W3C WebDriver 所提供的 API (以前叫 Selenium WebDriver)。 TestCafe TestCafe 的主打是安裝與設置快速，且可以使用相對於 Selenium 來說，較少、較簡潔的程式碼來做到相同的操作。 主要原因是因為他們並不是以 W3C WebDriver 為基底，而是基於 Node.js 之上所開發的。 最強大的地方在於他們支援幾乎是目前市面上所有的瀏覽器， Chrome 跟 Firefox 我就不提了，其他還有 IE 、 Edge 、 Safari 、 Opera ，是至是跨瀏覽器的測試工具平台 BrowserStack 與 LambdaTest 。 NightWatch NightWatch 也是用 Node.js 所寫的，不過跟 TestCafe 不一樣的是，雖然是用 Node.js 所寫，但其底層還是使用 W3C WebDriver API 來驅動瀏覽器執行操作。 不過它們家也是說它們可以在一分鐘內快速完成設定並啟動服務，有興趣的朋友可以試試看。 不過它們家的貓頭鷹 Logo 很可愛！ Puppeteer Puppeteer 也是一個基於 Node.js 所開發的 E2E 測試工具，不過他是直接透過 Chrome 的 DevTools Protocol 來操控 Chrome 或 Chromium ，而且它預設會跑在 Headless 的模式下，非常方便。 除此之外，它所主打的功能有： 可以產生出所測試頁面的螢幕擷圖和 PDF 可以抓取 SPA （Single Page Application） 並將其元素都渲染出來 Angular 有個 SSG （Static Site Generation） 的框架 Scully 就是基於這件事情上所做出來的。 自動化表單送出、UI測試、鍵盤輸入等事件 使用最新版本的自動化測試環境、 JavaScript 並直接在最新版本的 Chrome 裡執行測試 提供 Timeline trace 的功能以幫助診斷效能問題 可以用來測試 Chrome 的 Extension 它們還有提供一個線上的 Playground ，大家有興趣可以玩玩看。 WebDriverIO WebDriverIO 號稱是下一個世代的 E2E 測試工具，它既可以使用 WebDriver 來達到跨瀏覽器測試的功能，也能像 Puppeteer 那樣使用 Chrome DevTools Protocol ，非常厲害。 Protractor Protractor 是為 Angular 量身打造的 E2E 測試工具，而其根本也是使用 WebDriver 來驅動瀏覽器。 身為 Angular 御用的 E2E 測試工具以及 Angular 生態圈的一員，它的方便之處在於新增 Angular 專案時，一定也會連帶地將 Protractor 也給配置妥當。 不過隨著 Angular 征戰多年，Angular 在今年五月於 Angular v12 版本推出時宣布， 在 Angular v12 之後，Protractor 將不會再內建在新專案中，而預計將會在 Angular v15 時（大概是 2022 年尾）， Angular 團隊會正式終結 Protractor 。 而目前 Angular 的官方團隊正在積極尋找其他的 E2E 測試框架夥伴，像上面有介紹到的 TestCafe 、 WebDriverIO 與稍後會介紹的 Cypress 都名列其中。 關於 Angular E2E 與 Protractor 的計畫，想要知道詳細情況的朋友可以閱讀官方的 RFC（請求意見稿） 想要知道 Angular v12 更新了什麼，可以參考我的部落格文章 Cypress Cypress 有一句非常有趣的標語，叫做： Test your code, not your patience. 大概是知道大家寫 E2E 測試時都寫的滿痛苦嗎？ 此外，它還有一句標語叫做： A test runner built for humans. 這是因為它們的主張 ─ 開發者友善，不管你是 QA 還是一般工程師都是一樣。 而且它還覺得它有七個地方跟別的 E2E 自動化測試工具不一樣： 它不使用 Selenium 框架 因為它認為大多數的 E2E 測試工具都是基於 Selenium 的框架下所運作，這就是為什麼它們都會有相同的問題。 它專注於非常出色地進行 E2E 測試 因為它們只想專注地在為 Web Application 撰寫 E2E 測試時，提供做出色的開發者體驗。 它適用於任何前端框架或是網站 只要是可以在瀏覽器上跑的網頁它都可以測試。（不過我想應該是要它有支援的瀏覽器才行）。 它只用 JavaScript 來撰寫 官方的原意是，因其測試程式碼是在瀏覽器上所執行，所以除了使用 JS 外，不需和任何的語言或是驅動程式綁定。 不過我覺得這邊有一個隱含的意思，就是只要是可以編譯成 JavaScript 的，它都可以接受，就像是我個人目前是使用 TypeScript 來撰寫它，但其他的語言我就沒試過了。 它是一個 All-in-one 的框架 就像 Angular 一樣不需自己去整合各個工具或函式庫，只要安裝 Cypress ，其他的它會幫我們搞定。 它適用於開發者和 QA 它們想讓測試驅動開發這件事情變得更加容易，也意即它們的測試將會又好寫、寫得又快。 它執行地比其他框架要快的多 官網的原意我覺得跟執行速度比較有關的地方是它可以併行運作並自動負載平衡這件事情。 至於瀏覽器支援度的部份，除了 Chrome 跟 FireFox 之外，也支援 Edge 、 Brave 甚至是 Electron 。 這麼多 E2E 自動化測試工具，你有比較喜歡哪一個嗎？ 除了上述介紹的這七種 E2E 自動化測試工具之外，我相信一定還有其他的 E2E 自動化測試工具是我沒有介紹到的，不過族繁不及備載，如有遺珠之憾還請多加見諒。 本日小結大家有沒有發現，其實大多數的測試框架都是透過 W3C WebDriver 來進行操作或者是驗證，比較特別一點的則是使用 Chrome 的 DevTools Protocol ，甚至是兩個都可以用。 但在這些 E2E 自動化測試工具裡，最特別的就是 Cypress ，而它其實也是我這次系列文要分享給大家的 E2E 自動化測試工具，後續的 E2E 測試也都將會分享如何使用 Cypress 來撰寫。 明天我更進一步地分享如何使用 Cypress，除了讓大家更進一步地了解這個框架之外，也讓大家如果在閱讀後續文章有任何不懂的地方可以回來複習。 如果你有任何的問題或是回饋，還請麻煩留言給我讓我知道，感謝大家！","link":"/2021/10/02/angular-30days-form-and-test-17/"},{"title":"Angular 深入淺出三十天：表單與測試 Day19 - 與 Cypress 的初次見面（下）","text":"昨天跟大家初步地分享了 Cypress 怎麼安裝、 Cypress 的資料夾結構 、 Cypress Test Runner 有哪些功能、和 Cypress 提供的強大 Dashboard 的服務之後，大家有試著自己玩玩看嗎？ 今天我想要分享給大家的是 Cypress 在執行測試時提供的功能。 可能有人會覺得，執行測試就執行測試，哪有什麼功能好分享的？ 別急，且聽我娓娓道來。 The Test Runner 昨天介紹到這個 Test Runner 開啟的小視窗，我們可以直接點擊列表中的某個檔案來執行該檔案的測試。 今天我們就來先點擊第一個 todo.spec.js 以執行這個檔案的測試，點擊該檔案之後你會發現， Cypress 用你所指定的瀏覽器打開了一個視窗，接著大家會看到這個畫面： Cypress 咻咻咻地就把事情做完了，是不是超快的？！ 沒錯，Cypress Test Runner 後來開的這個瀏覽器裡面其實是有玄機的，他不僅僅只是把結果顯示出來而已。 Application Under Test Cypress Test Runner 後來開的這個瀏覽器裡其實是一個互動介面，右邊這個區塊是實際受測的頁面，官方將其稱作為 AUT。 這個畫面不僅僅只是顯示而已，它是真實的頁面，所以我們一樣可以打開控制台、檢查元素與查看 CSS 設定。 不過 Cypress 其實是使用 iframe 的方式將其嵌在這個互動介面裡，也因此可能會遇到一些問題，官方有將可能的問題統整在這個文件裡，大家如果有遇到類似的問題可以到這個文件裡查詢。 而如果測試的語法有誤，它也會直接將錯誤訊息顯示在同一個地方： 網址列 在 AUT 的上方的網址列顯示的是當然是 AUT 的網址，不過該網址列是不能輸入的，點擊只會直接開新頁面以瀏覽該網頁而已。 Viewport 右上方所顯示的則是當前這個 AUT 所使用的視窗大小，單位是 px 。 而大小旁邊的 % 數指的是當前我們所看到的大小是實際受測大小的縮放比例。 如果想知道更多細節的話可以直接點它，它會跟你說要怎麼設置： The Selector Playground再來要介紹的是一個非常好用的功能，在網址列左方有一顆 icon 是準心的按鈕： 點下去之後會出現這一列工具列： 並且整個 AUT 會進入一個像是平常我們滑鼠右鍵檢查元素的模式，只要我們鼠標指到 AUT 任一元素上面，該元素就會變成藍色，並且會有個小小的 tooltip 跟你說這個元素的 CSS Selector 是什麼： 點擊下去之後你會發現，上面的輸入框會變成你剛剛點擊的元素的 CSS Selector ： 這時我們可以點選右邊的複製按鈕以直接複製 cy.get('[data-test=new-todo]') 這一串文字： 而複製按鈕旁邊的按鈕叫做 Print to console ： 點擊這顆按鈕可以將被選取元素的資訊印到控制台裡面，印出來的資料長得會像是這樣： 輸入框左邊的 cy.get 其實是可以切換的，點擊它會出現另外一個選項 cy.contains ： cy.contains 的功用是透過直接比對元素內是否有該字串來找尋元素，我們如果直接在輸入框輸入 Walk ，就會看到 Cypress 直接幫我們選取了 Walk the dog 這個代辦事項的元素： 而輸入框右邊的數字也會讓我們知道該選擇器一共選取到了多少個元素： 是不是非常地方便？我覺得這個工具會讓我們在撰寫測試案例的時候輕鬆許多，尤其如果你是需要撰寫 E2E 測試的 QA ，這個工具對你的幫助真的非常巨大，再也不用纏著前端工程師問該元素要怎麼選取，直接用這個工具就能輕鬆搞定！ 而且這個工具所提供的 CSS Selector 可是有玄機在裡頭的！ Cypress 預設會照著以下順序的優先權來提供 CSS Selector 給我們： 是否擁有屬性 ─ data-cy 是否擁有屬性 ─ data-test 是否擁有屬性 ─ data-testid （ i 真的是小寫！，不是我打錯噢！） 是否擁有屬性 ─ id 是否擁有屬性 ─ class tag 名稱（該元素的名稱，如 input 、 div ） 其他屬性名稱 偽元素選擇器 ─ nth-child 因此，只要該元素有優先權比較高的選擇器，不用擔心你會得到像是 div &gt; div &gt; div &gt; div &gt; p 之類的 CSS Selector ，只要前端工程師在開發時有加上高優先權選取器，都會有著事半功倍的效果。 講到這裡其實一定會有人擔心：這樣不就要每個元素都加？這樣不就會需要加很多？ 其實: 只要關鍵元素有加，讓寫 E2E 測試的人方便選取並與頁面互動即可。 如果寫 E2E 測試是必然，那增加方便選取的屬性名稱也是必然的。 謎之聲：不然你來寫 E2E 測試阿？！ 不過這個優先權，官方其實是有提供 API 以供我們在有需要的時候加以調整，雖然我覺得並不是很必要，但有需要的人可以參考官方的 Selector Playground API 文件。 而基於這個優先權，官方也提供 Best Practice Guide - Selecting Elements 給大家，希望大家未來在實作時能盡量照這個方式實作。 Command Log接下來是左半邊的重點 ─ Command Log ： 同樣地，這邊所顯示的東西也不僅僅只是單純的顯示結果，它一樣是個可以互動的介面。 上方藍色的連結是受測檔案的位置，我們可以直接點擊它， Cypress 會幫我們用我們設定的 File Opener 來打開它。 如果想知道怎麼設定 File Opener 的話，我昨天其實有介紹過，大家可以回頭看一下昨天的文章。 圖中列表裡，黑字且可點擊收合的項目，是我們在 .spec.js 裡所寫的 describe 或是 context 。 context 在 cypress 裡的功用與 describe 等同，唯一不同的大概就是在語意上，官方範例中的 context 會在 describe ，但 describe 不會在 context 裡。 而每個前面有勾勾 icon 的項目，則是我們在 .spec.js 裡所寫的每一個 it ，也就是每一個測試案例。 點擊任一個測試案例後，我們可以在它展開的區塊中看到該測試案例的所執行的 Command ： 而且你會發現，Cypress 還會告訴你這些 Command 是在 before 、 beforeEach 、 afterEach 和 after 這些 Hooks 中執行的，還是在 it 中執行的（ TEST BODY 指的就是在 it 中執行的 Command ）： 此外，當我們的滑鼠游標滑到任一 Command 上，或是點擊任一 Command 時， Cypress 會直接幫我們還原在執行該 Command 時，頁面當前的狀況（ DOM Snapshot ）： 就像坐上了時光機一樣！ Cypress 預設會幫我們每個測試案例都保留 50 筆的 DOM Snapshot 以供我們進行時空旅行。 不過一旦測試案例一多，這其實是件很吃記憶體的事情。 因此， Cypress 也有提供設定讓我們可以調整保留的筆數，透過在 cypress.json 或者是 cypress.env.json 將 numTestsKeptInMemory 調小即可。 想調大當然也是沒有問題的！（笑） 還有，大家有沒有發現在滑鼠游標滑過每一個 Command 的時候，每一行 Command 開頭的數字會變成一顆圖釘？ 這是因為 Cypress 有提供釘選的功能。 當我們想透過時空旅行去觀看某一個 Command 執行時的狀況，除了將滑鼠游標滑到該 Command 上之外，點擊該 Command 會將當前 AUT 的內容釘選在當下的那個狀況： 同時， Cypress 也會幫我們資訊印出來，以供我們使用： 如果覺得藍藍的很礙事，我們可以點擊這顆按鈕把它關掉： 如果要恢復則再點擊一次即可。 而如果要解除釘選，則可以按旁邊這顆按鈕： 也可以透過再次點擊當前釘選的 Command 或者是釘選其他的 Command 來解除對當前 Command 的釘選。 此外，如果釘選到的 Command 是有狀態切換效果的，像是 Checkbox 、 Radio button ，還會有 Before / After 的 Toggle Button ： 如此一來我們就可以知道在該行 Command 執行完之後，狀態有沒有如我們所預期的改變： Test Status Menu 最後，則是左上方的這個 Status Menu。 最左邊 &lt; Test 的部分按下去之後，會把一開始的那個小視窗叫出來，這時我們可以再選擇其他的測試檔案來執行。 不過 Cypress 在這個模式下，一次只能執行一個檔案噢！ 而旁邊這個勾勾跟叉叉應該不用我說大家應該都知道，是指通過測試跟沒通過測試的數量，右邊那個灰色圈圈則是指略過的測試數量。 再旁邊的數字則是執行完這個檔案的所有測試所耗費的時間，相信大家也都知道。 右邊這個橘色有上下箭頭的 icon ，可以用來切換在執行測試時，如果測試案例已經長到超過螢幕高度，是否要自動 Scroll 的功能： 最右邊的則是是重新執行所有測試案例的按鈕，沒什麼特別的： 不過，其實還有一個小秘密不知道大家有沒有發現，其實 View All Test 跟 Disabled Auto-scrolling 和 Run All Tests 這三個按鈕是有快捷鍵的！ 雖然不是什麼大不了的事情，但我覺得 Cypress 在很多小細節都很細心、很貼心，所以 Cypress 這個 E2E 自動化測試工具才會這麼好用！ 本日小結今天的重點主要是想讓大家清楚地知道和了解這個 Cypress Test Runner 提供了些什麼功能，相信之後在後續使用 Cypress 寫 E2E 測試的時候，大家會比較知道怎麼 debug 、或者是比較知道我在做什麼，而且使用上也一定會比較熟悉且順手。 明天我們就要開始正式用 Cypress 寫 E2E 測試囉，敬請期待！ 如果有任何的問題或是回饋，還請麻煩留言給我讓我知道，感謝大家！","link":"/2021/10/04/angular-30days-form-and-test-19/"},{"title":"Angular 深入淺出三十天：表單與測試 Day20 - E2E 測試實作 - 登入系統","text":"經過這兩天的介紹，相信大家對於 Cypress 應該已經有了一定程度的理解，有沒有人已經開始用它來寫測試了呢？ 今天就讓我帶著大家用 Cypress 來為我們的表單撰寫 E2E 測試吧！ 實作開始首先先輸入以下命令以啟動 Cypress 的 Test Runner ： 1$ npm run cy:open 或者是 1$ yarn cy:open 如果你還不知道怎麼安裝 Cypress 或者是為什麼要輸入這個指令的話，請參考第 18 天的文章：與 Cypress 的初次見面（上）。 接著就會看到熟悉的小視窗： 準備測試檔之前在第 18 天的文章有介紹到，這些測試檔是官方產出的範例，如果大家嫌自己刪很麻煩的話，其實這個小視窗有提供一個方法可以一鍵刪除： 按下這個連結之後，它會顯示： 按確定之後，它就會幫你刪光光，非常的方便： 當然如果想留著也無所謂，只是順帶一提這個貼心的小功能。 然後我們就可以按下 + New Spec File 來建立我們的第一個 E2E 測試檔： 由於 E2E 測試是要模擬使用者的行為來操作真實的系統，所以在撰寫測試前，我們先確定要測的系統可以被訪問，待會才能夠使用 Cypress 來訪問它。 當然如果要測的系統有放在網路空間裡最好，沒有的話就在本地端啟動它即可。 第一個 E2E 測試的測試案例接著我們打開剛建立的測試檔，來寫我們的第一個 E2E 測試的測試案例。 程式碼如下： 12345678910describe('Login Form', () =&gt; { it('have title \"Template Driven Forms 實作 ─ 登入\"', () =&gt; { // Arrange const title = 'Template Driven Forms 實作 ─ 登入'; // Act cy.visit('http://localhost:4200'); // Assert cy.get('h1').should('have.text', title); });}); 執行結果： 雖然大家看我寫得好像很簡單，不過大家在實作時應該會有個疑問：怎麼都沒有 intellisense ？ intellisense 指的是當我們 Coding 時，編輯器會跟我們說有什麼方法可以使用的那個選單，有的人也會叫他 auto-complete 。 其實這是因為少了一句關鍵的語法： 只要大家將這個語法 /// &lt;reference types=&quot;cypress&quot; /&gt; 放在檔案開頭，就可以在撰寫測試時有 intellisense 囉！ 一開始我也沒注意到它，因為我平常是寫 TypeScript 的版本，所以我去查了一下這是什麼原理，原來這是早期 TypeScript 用來宣告依賴關係的方式，詳細大家可以參考我找到的網路文章：https://willh.gitbook.io/typescript-tutorial/basics/declaration-files#san-xie-xian-zhi-ling 撰寫測試案例藉由第一個測試案例來驗證環境沒問題後，我們就可以正式來寫需求的測試案例了。 複習並整理一下要驗的案例： 輸入正確格式的帳號與密碼，登入按鈕為 enabled 的狀態 輸入不正確格式的帳號但正確格式的密碼，登入按鈕為 disabled 的狀態 輸入正確格式的帳號但不正確格式的密碼，登入按鈕為 disabled 的狀態 程式碼如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243describe('Login Form', () =&gt; { beforeEach(() =&gt; { cy.visit('http://localhost:4200'); }); it('have title \"Template Driven Forms 實作 ─ 登入\"', () =&gt; { // Arrange const title = 'Template Driven Forms 實作 ─ 登入'; // Assert cy.get('h1').should('have.text', title); }); context('When typing the correct account and password', () =&gt; { it('should can login', () =&gt; { // Act cy.get('#account').type('abc@email.com'); cy.get('#password').type('12345678'); // Assert cy.get('button').should('be.enabled'); }); }); context('When typing the incorrect account and the correct password', () =&gt; { it('should can not login', () =&gt; { // Act cy.get('#account').type('abcdef'); cy.get('#password').type('12345678'); // Assert cy.get('button').should('be.disabled'); }); }); context('When typing the correct account and the incorrect password', () =&gt; { it('should can not login', () =&gt; { // Act cy.get('#account').type('abc@email.com'); cy.get('#password').type('12345'); // Assert cy.get('button').should('be.disabled'); }); });}); 執行結果： 大家有沒有覺得寫起來其實跟之前的單元測試與整合測試並沒有什麼太大的差別？ 這是因為在撰寫測試的時候，大體上的觀念都是共通且雷同的，只有所使用的語法與 API 不同罷了。 雖然上述測試程式碼只驗了三個情境，但這是因為我覺得其實大多的情境都已經有被整合測試覆蓋到的緣故。 不過在現實情況裡，寫整合測試的人不一定跟寫 E2E 測試的人是同一個，所以就算驗比較完整一點也是很正常的。 E2E 測試小技巧 ─ 自訂 Command雖說已經寫完測試了，但既然每個測試案例都需要輸入帳號密碼，那我們可以使用自訂 Command 的技巧來重構一下這段程式碼。 首先我們打開在 /support 資料夾底下的 commands.js ，大家應該會看到像這樣被註解起來的程式碼： 1234567891011121314// -- This is a parent command --// Cypress.Commands.add('login', (email, password) =&gt; { ... })////// -- This is a child command --// Cypress.Commands.add('drag', { prevSubject: 'element'}, (subject, options) =&gt; { ... })////// -- This is a dual command --// Cypress.Commands.add('dismiss', { prevSubject: 'optional'}, (subject, options) =&gt; { ... })////// -- This will overwrite an existing command --// Cypress.Commands.overwrite('visit', (originalFn, url, options) =&gt; { ... }) 這些程式碼一樣也是 Cypress 幫我們產生的範例，主要是讓我們知道怎麼做才能自訂 Command 。 我們可以從中看到，其實有四種方式可以自訂 Command ，不過今天我們只會用到第一種。 想知道其他方式如何使用？請參考官方的 Custom Commands - Examples 文件。 首先取消 login 那一行的註解，並將程式碼改成這樣： 1234Cypress.Commands.add('fillWith', (account, password) =&gt; { cy.get('#account').type(account); cy.get('#password').type(password);}); 然後我們就能到 login-form.spec.js 裡將測試案例改成這樣： 1234567891011121314151617181920212223242526272829303132333435context('When typing the correct account and password', () =&gt; { it('should can login', () =&gt; { // Arrange const account = 'abc@email.com'; const password = '12345678'; // Act cy.fillWith(account, password); // Assert cy.get('button').should('be.enabled'); });});context('When typing the incorrect account and the correct password', () =&gt; { it('should can not login', () =&gt; { // Arrange const account = 'abcdef'; const password = '12345678'; // Act cy.fillWith(account, password); // Assert cy.get('button').should('be.disabled'); });});context('When typing the correct account and the incorrect password', () =&gt; { it('should can not login', () =&gt; { // Arrange const account = 'abc@email.com'; const password = '12345'; // Act cy.fillWith(account, password); // Assert cy.get('button').should('be.disabled'); });}); 這樣看起來是不是更清爽、更好閱讀了呢？ 此外，撰寫完測試之後，未來再執行測試時，就不會用同個模式跑，這個模式主要是用來開發測試程式碼用的，未來要再重複執行測試的話，我們一樣可以先在 package.json 裡的 script 區段加上： 123{ \"cy:run\": \"cypress run\"} 你也可以取自己喜歡的指令如 &quot;e2e&quot;: &quot;cypress run&quot; ，不一定要跟我一樣。 之後就能直接用以下的指令執行 E2E 測試了： 1$ npm run cy:run 或者是 1$ yarn cy:run 執行結果： 而且你會發現 Cypress 幫你錄了執行測試時的影片，不妨點開來看看吧！ 本日小結今天的重點主要是在撰寫 E2E 測試的測試案例上與自訂 Command 的部份，不過經歷之前的練習後，大家應該只要稍微熟悉一下就能輕易上手了。 明天我們再來練習用 Cypress 為我們之前寫的動態表單撰寫測試，敬請期待！ 今天的實作程式碼會放在 Github - Branch: day20 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果你有任何的問題或是回饋，還請麻煩留言給我讓我知道！","link":"/2021/10/05/angular-30days-form-and-test-20/"},{"title":"Angular 深入淺出三十天：表單與測試 Day21 - E2E 測試實作 - 被保人表單","text":"大家如果對於昨天的 E2E 測試如果沒有什麼問題的話，今天就來為我們的被保人表單撰寫 E2E 測試吧！ 實作開始 撰寫測試前的準備昨天有說過了，今天就不再贅述囉！不知道該幹嘛的朋友可以參考昨天實作開始的一開始的做了些什麼事情。 首先我們一樣先建立一個測試檔 insured-form.spec.js，然後打開剛建立的測試檔加上此句語法讓編輯器可以知道我們在寫 Cypress 以方便撰寫測試程式碼： 1/// &lt;reference types=\"cypress\" /&gt; 原理昨天一樣有介紹過了，忘記或不知道的朋友可以複習一下昨天的文章。 被保人表單的第一個 E2E 測試的測試案例接著我們打開剛建立的測試檔，來寫我們的第一個 E2E 測試的測試案例，以驗證我們的環境已準備好。 程式碼如下： 12345678910111213describe('Insured Form', () =&gt; { beforeEach(() =&gt; { cy.visit('http://localhost:4200'); cy.get('ul li').contains(title).click(); }); it('have title \"Reactive Forms 實作 ─ 被保險人\"', () =&gt; { // Arrange const title = 'Reactive Forms 實作 ─ 被保險人'; // Assert cy.get('h1').should('have.text', title); });}); 執行結果： 還記得之前在介紹 Test Runner 的時候有稍稍帶過 contains 這個 Command 嗎？ 確切是在第 19 天的文章： 與 Cypress 的初次見面（下） 這次特別使用一次給大家看，因為如果不使用這個方式， CSS Selector 可能就要寫成： cy.get('ul li:last-child &gt; a').click(); ，滿醜的。 當然根據官方的 Best Practice ，直接在上面加個 data-cy=&quot;insured-form-page-link&quot; 的屬性是最好的。 原因一樣在第 19 天的文章： 與 Cypress 的初次見面（下） 有說明過，不知道的朋友可以回去複習一下。 撰寫測試案例藉由第一個測試案例來驗證環境沒問題後，我們就可以正式來寫需求的測試案例了。 複習並整理一下要驗的案例： 要可以新增被保險人 要可以刪除被保險人 輸入正確姓名與選擇年齡後，但沒選擇性別，送出按鈕為 disabled 的狀態 輸入正確姓名與選擇性別後，但沒選擇年齡，送出按鈕為 disabled 的狀態 選擇性別與年齡後，但沒輸入姓名，送出按鈕為 disabled 的狀態 程式碼如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071describe('Insured Form', () =&gt; { beforeEach(() =&gt; { cy.visit('http://localhost:4200'); cy.get('ul li').contains('Reactive Forms 實作 ─ 被保險人').click(); }); it('have title \"Reactive Forms 實作 ─ 被保險人\"', () =&gt; { // Arrange const title = 'Reactive Forms 實作 ─ 被保險人'; // Assert cy.get('h1').should('have.text', title); }); it('should can add the insured', () =&gt; { // Arrange const name = 'Leo'; const gender = 'male'; const age = '18'; // Act cy.get('[type=\"button\"]').click(); cy.get('#name-0').type(name); cy.get(`[for=\"${gender}-0\"]`).click(); cy.get('#age-0').select(age); // Assert cy.get('[type=\"submit\"]').should('be.enabled'); }); it('should can delete the insured', () =&gt; { // Act cy.get('[type=\"button\"]').click(); cy.get('fieldset').contains('刪除').click(); // Assert cy.get('fieldset').should('have.length', 0); }); it('should can not add the insured when the age is not valid', () =&gt; { // Arrange const name = 'Leo'; const gender = 'male'; // Act cy.get('[type=\"button\"]').click(); cy.get('#name-0').type(name); cy.get(`[for=\"${gender}-0\"]`).click(); // Assert cy.get('[type=\"submit\"]').should('be.disabled'); }); it('should can not add the insured when the gender is not valid', () =&gt; { // Arrange const name = 'Leo'; const age = '18'; // Act cy.get('[type=\"button\"]').click(); cy.get('#name-0').type(name); cy.get('#age-0').select(age); // Assert cy.get('[type=\"submit\"]').should('be.disabled'); }); it('should can not add the insured when the name is not valid', () =&gt; { // Arrange const gender = 'male'; const age = '18'; // Act cy.get('[type=\"button\"]').click(); cy.get(`[for=\"${gender}-0\"]`).click(); cy.get('#age-0').select(age); // Assert cy.get('[type=\"submit\"]').should('be.disabled'); });}); 執行結果： 大家有覺得昨天寫過一次後，今天再寫一次有比較熟悉一點了嗎？ 雖然這次驗的情境比較多，但我覺得如果大多的情境都已經有被整合測試覆蓋到的話，或許只需要驗證第一個情境就好。 不過在現實中，寫整合測試的人不一定跟寫 E2E 測試的人是同一個，所以寫 E2E 的人照著需求規格寫，多驗一點情境也是很好的。 在今天的測試程式碼中，比較值得一提的是使用 cy.select() 的使用，它的參數可以欲選擇選項的 value 值，或者是選項的名稱，更可以是選項的 index ，是非常方便的一個 Command 。 此外，在選年齡時，如果大家不是跟我一樣是點擊 Label ，而是直接點選 Radio Button 的話，記得要使用 cy.check() 的 Command。 Cypress 的錯誤訊息不過就算寫錯也無所謂，因為 Cypress 這個貼心鬼其實都會跟你說你哪裡寫錯、可以怎麼寫。 例如剛剛說的 cy.select() ，如果我們使用 cy.click() ， Cypress 就會跟你說你可以用 cy.select() 來替代唷！而且還會跟你說你寫錯的地方是在哪一行： 又或者你使用了 cy.select() ，但忘記帶參數，它也會跟你說你漏了什麼參數： Cypress 真是個貼心鬼 撰寫了兩次的 E2E 測試之後，也累積了不少測試案例，這時候大家應該會發現有一些重複的東西散落在不同的測試檔案之中，又或者會有某些 Hard Code 在測試程式碼裡的東西應該要被抽出來，以利後續維護。 這時我們就可以善用在第 18 天的文章裡曾經提過 fixtures 與 Cypress 的 cypress.json 的配置來達成。 E2E 測試小技巧 ─ 環境變數舉例來說，如果你的 E2E 的測試專案都是在測同一個網域的網頁，那我們就可以在 cypress.json 加上 baseUrl 的設置： 123{ \"baseUrl\": \"http://localhost:4200\"} 如此就可讓我們後續使用 cy.visit() 、 cy.request() 或是 cy.intercept() 時，就可以不用再傳入一樣的字串。 而且這個用法還會有一個好處，就是當需要執行不同環境的測試時，我們可以用像是這樣子的方式來替換掉該變數： 1$ CYPRESS_BASE_URL=https://product.domain.com cypress run 更多的環境變數小技巧請詳閱官方的 Environment Variables 文件。 E2E 測試小技巧 ─ fixtures上述提到的環境變數一般常用在會因為測試環境改變時需要改變的值上，但其實還有很多值是不會因為環境改變而改變的，這時就可以用上現在這個小技巧。 這個小技巧其實我也有在第 18 天的文章 ─ 與 Cypress 的初次見面（上） 裡稍微提到過，就是我們可以在 /fixtures 的資料夾底下新增 .json 檔，然後我們可以將值放在裡面，需要的時候再從裡面拿。 像現在我們可以在 /fixtures 裡新增一個 insured-form.json 的檔案，然後內容大概會是這樣： 123456{ \"title\": \"Reactive Forms 實作 ─ 被保險人\", \"name\": \"Leo\", \"gender\": \"male\", \"age\": \"18\"} 然後在 insured-form.spec.js 就可以改成這樣： 12345678910111213141516171819202122232425262728293031import insuredForm from '../fixtures/insured-form.json';describe('Insured Form', () =&gt; { beforeEach(() =&gt; { cy.visit(''); cy.get('ul li').contains(insuredForm.title).click(); }); it('have title \"Reactive Forms 實作 ─ 被保險人\"', () =&gt; { // Arrange const title = insuredForm.title; // Assert cy.get('h1').should('have.text', title); }); it('should can add the insured', () =&gt; { // Arrange const name = insuredForm.name; const gender = insuredForm.gender; const age = insuredForm.age; // Act cy.get('[type=\"button\"]').click(); cy.get('#name-0').type(name); cy.get(`[for=\"${gender}-0\"]`).click(); cy.get('#age-0').select(age); // Assert cy.get('[type=\"submit\"]').should('be.enabled'); }); // 以下省略...}); 如此一來，未來當驗證的資料需要改變時，就只要到 /fixtures 裡的 insured-form.json 改就好，維護起來就更加輕鬆愉快囉！ 今天我故意沒有用自訂 Command 的技巧來重構我的測試程式碼，大家不妨試著自己自訂看看吧！ 本日小結今天的重點主要是後面的兩個小技巧，這兩個小技巧對於日後大家真的在自己的專案或為公司專案撰寫 E2E 測試會非常有幫助，請務必多加熟悉。 不過平常都用 TypeScript 寫的我覺得很不習慣，明天就來分享怎麼樣把它變成 TypeScript 的版本吧！ 今天的實作程式碼會放在 Github - Branch: day21 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果你有任何的問題或是回饋，還請麻煩留言給我讓我知道！","link":"/2021/10/06/angular-30days-form-and-test-21/"},{"title":"Angular 深入淺出三十天：表單與測試 Day22 - 把 Cypress 變成 TypeScript 版","text":"平常都用慣 TypeScript 版的 Cypress，但這兩天都用 JavaScript 在寫測試，令我有點不太習慣。 雖然 JS 版或 TS 版的差別並沒有多大，但少了一些開發時期的型別檢查與 Intellisense 還是令人感到彆扭。 因此，我們今天就來分享如何把 JS 版的 Cypress 變成 TS 版吧！ Angular 專案首先，如果你的專案是 Angular ，預設不會配有任何 E2E 自動化測試工具，如果我們想要在 Angular 的專案使用 Cypress ，可以直接在終端機輸入以下指令： 1$ ng add @cypress/schematic 等待它執行完成後，你會發現 Angular Schematics 除了幫你裝好 Cypress 之後，也在 package.json 裡的 scripts 區段增加了以下三個指令： 1234567{ \"scripts\": { \"e2e\": \"ng e2e\", \"cypress:open\": \"cypress open\", \"cypress:run\": \"cypress run\" }} 並且在 angular.json 裡的 architect 區段添加了以下設定： 123456789101112131415161718192021222324252627282930313233{ \"cypress-run\": { \"builder\": \"@cypress/schematic:cypress\", \"options\": { \"devServerTarget\": \"ng-with-cypress:serve\" }, \"configurations\": { \"production\": { \"devServerTarget\": \"ng-with-cypress:serve:production\" } } }, \"cypress-open\": { \"builder\": \"@cypress/schematic:cypress\", \"options\": { \"watch\": true, \"headless\": false } }, \"e2e\": { \"builder\": \"@cypress/schematic:cypress\", \"options\": { \"devServerTarget\": \"ng-with-cypress:serve\", \"watch\": true, \"headless\": false }, \"configurations\": { \"production\": { \"devServerTarget\": \"ng-with-cypress:serve:production\" } } }} e2e 的部份如果原本是使用 Protractor ，也會被調整過來。 這段設定的用意是讓 Angular CLI 知道，當我們要執行 cypress run 、 cypress open 或是 ng e2e 的指令時，會連帶啟動 Angular 的服務，方便開發者使用時，不需額外自己啟動。 葛來芬多 Cypress 加 10 分！ 此外，不可少的 cypress.json 與 /cypress 資料夾當然也已經新增好了，而且 cypress.json 裡還已經幫我們配置了以下設定： 123456789{ \"integrationFolder\": \"cypress/integration\", \"supportFile\": \"cypress/support/index.ts\", \"videosFolder\": \"cypress/videos\", \"screenshotsFolder\": \"cypress/screenshots\", \"pluginsFile\": \"cypress/plugins/index.ts\", \"fixturesFolder\": \"cypress/fixtures\", \"baseUrl\": \"http://localhost:4200\"} 原本 /cypress 資料夾裡的 .js 檔也都變成了 .ts 檔，至此，我們就成功地把 Cypress 加入的 Angular 專案之中了，是不是超方便、超簡單的？！ Angular + Cypress 真的會把開發者寵壞 想知道什麼是 Angular Schematics 嗎？可以閱讀我的系列文：高效 Coding 術：Angular Schematics 實戰三十天。 其他更多資訊，可以參考 Cypress 官方文件：https://docs.cypress.io/guides/migrating-to-cypress/protractor#Recommended-Installation 額外告訴大家一個小故事：其實這個 Schematics 原本不是官方維護的，這個 Schematics 的原身一開始是這個 @briebug/cypress-schematic ，不過後來被官方採用，才改由 Cypress 團隊維護。 衷心感謝所有曾經或正在為 Open Source 貢獻心力的每一個人。 其他類型專案Angular 專案有 Angular Schematics ，但其他類型的專案或者是單單只有 Cypress 的專案怎辦？ 別擔心，其實要做的事情也不會太繁瑣或困難。 首先，我們可以先在專案裡輸入以下指令以安裝 TypeScript ： 1$ npm install typescript --save-dev or 1$ yarn add typescript --dev 如果你的專案裡已經有安裝 TypeScript 的話請略過此步驟 然後在 /cypress 資料夾內新增一個 tsconfig.json 檔，並添加以下內容： 12345678{ \"compilerOptions\": { \"target\": \"es5\", \"lib\": [\"es5\", \"dom\"], \"types\": [\"cypress\"] }, \"include\": [\"**/*.ts\"]} 然後就可以把我們的 .js 檔都改成 .ts 檔，並把所有的 /// &lt;reference types=&quot;cypress&quot; /&gt; 都拿掉囉！ 不過如果你本來的專案就是 TypeScript 的，這時候你可能會發現你原本非 E2E 測試的 .spec.ts 檔案多了一堆紅色毛毛蟲： 然後你將滑鼠游標移到紅色毛毛蟲上， VSCode 會跟你說： 但是如果我們實際跑測試的話，又都會通過，那到底為什麼會有紅色毛毛蟲呢？ 其實這是因為， VSCode 以為原本非 E2E 測試的 .spec.ts 是 Cypress 的檔案，所以它把原本是 Jasmine 的 expect() ： 誤認為是 Chai 的 expect() ： 那該怎麼辦才好呢？ 其實會造成這個狀況是因為 VSCode 它預設會吃 tsconfig.json 的設定，而如果原本根目錄就有 tsconfig.json ，然後又在 /cypress 裡加了 tsconfig.json 的話，就會出現這種狀況。 這時我們只需要在根目錄的 tsconfig.json 加上這個設定就可以恢復正常了： 123456789{ \"include\": [ \"src\", \"node_modules/cypress\" ], \"exclude\": [ \"node_modules/cypress\" ]} 如果這部份有遇到問題的話，可以參考我的 Source Code 的設定。 不過別高興地太早，還有一件事情需要我們留意與調整。 自訂 Command之前在 JS 版本使用自訂 Command 時，自訂的 Command 沒有 Intellisense 很不方便，而且參數也都沒有辦法定義型別，也增加了後續維護的困難度。 而現在我們升級成 TS 版本後，想要享受 TS 所帶來的好處之前，我們需要在我們的 command.ts 檔的開頭增加以下程式碼： 1234567declare namespace Cypress { interface Chainable { // 這裡面擺放的是自訂 Command 的宣告 // 例如： fillWith(account: string, password: string): Chainable&lt;string&gt; }} 原本的自訂 Command 的區塊也可以一併調整成這樣： 1234Cypress.Commands.add('fillWith', (account: string, password: string) =&gt; { cy.get('#account').type(account); cy.get('#password').type(password);}) 如此一來，我們在寫測試案例的時候即可享有 Intellisense 與型別檢查的好處囉！ 想知道更多可以參考官方的 TypeScript Support 文件 本日小結今天的重點主要是升級完成後，千萬記得要在 command.ts 加上 namespace 的宣告，這點可能會是很多人會不小心忘記的地方。 此外，也記得將 /// &lt;reference types=&quot;cypress&quot; /&gt; 從程式碼中移除，這個語法主要是針對 JS 的，升級 TS 之後有它反而會錯。 我今天的實作程式碼會放在 Github - Branch: day22 上供大家參考，不過雖然該專案是 Angular 專案，但我是使用「其他專案」的方式，所以在測試時會需要自己啟動 Angular 的服務。 同時也建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果你有任何的問題或是回饋，還請麻煩留言給我讓我知道！","link":"/2021/10/07/angular-30days-form-and-test-22/"},{"title":"Angular 深入淺出三十天：表單與測試 Day26 - 進階表單開發技巧 - 自訂驗證器","text":"之前在開發表單的時候，我們都是使用 Angular 所提供的驗證器來驗證表單欄位裡的值是否符合我們的需求。 雖然 Angular 已經這麼貼心地提供了這麼多驗證了，但每個國家、地區的人文風土民情都不同，還有太多太多需要我們自己自訂規則才能符合需求的情況。 因此，今天我們就一起來看看要怎麼自訂驗證器吧！ 自訂驗證器的型別既然要自訂驗證器，就不能不知道驗證器的型別與其定義。 其實之前在第三天的文章：Reactive Forms 實作 - 以登入為例 裡就有提到驗證器的型別。 ValidatorFn驗證器的型別是 ValidatorFn ，其原始碼定義如下： 123interface ValidatorFn { (control: AbstractControl): ValidationErrors | null} 從定義中我們可以知道，驗證器其實就只是一個函式，該函式會傳入一個型別為 AbstractControl 的參數來讓我們在函式中判定該欄位的值是否符合我們的需求。 如果驗證結果符合需求，那就回傳 null ，代表沒有任何的錯誤；如果驗證結果不符合需求那就回傳一個型別為 ValidationErrors 的錯誤。 那 ValidationErrors 又是什麼呢？ ValidationErrorsValidationErrors 之前最早是在第二天的文章： Template Driven Forms 實作 - 以登入為例 裡登場。 其原始碼定義如下： 123type ValidationErrors = { [key: string]: any;}; 沒錯，你沒看錯，就是這麼簡單！ 從定義上看起來，基本上只要是個物件，就符合該型別的要求，而這也是因為滿足客製的條件，讓使用 Angular 的開發者有程度的規範但擁有盡可能大的彈性。 不過雖然大家可以隨意自訂，但我非常建議大家在自訂的時候可以參考官方的驗證器。 舉例來說，官方的 Validators.required 驗證器在驗證有誤時，會回傳的 ValidationErrors 是： 1{ required: true } 而 Validators.pattern 驗證器在驗證有誤時，會回傳的 ValidationErrors 是： 1234{ actualValue: 'xxx', requiredPattern: 'xxx'} Validators.minlength 跟 Validators.minlength 驗證器在驗證有誤時，則會回傳： 1234{ actualLength: 1, requiredLength: 2} 我們從中不難發現官方會在 ValidationErrors 中，回傳該欄位當前的狀態以及需求的狀態；而物件的屬性名稱也會按照 actual 加上 XXXX 以及 required 加上 XXXX 的方式來命名。 雖然具體上還是要看實際需求，但我個人覺得我們自己在自訂驗證器的 ValidationErrors 時，也可以照著這個規則來處理。 一方面，整個系統會比較一致；另一方面，也不需要多寫太多額外的程式來處理我們自訂的錯誤。 舉個例子，如果我們想自訂一個欄位的值只能是 Leo 的驗證器，其程式碼可能會像是這樣： 12345678910export leoValidator: ValidatorFn = (control: AbstractControl) =&gt; { const isLeo = control.value === 'Leo'; if (isLeo) { return null } return { actualValue: control.value, requiredValue: 'Leo' };}; 如此我們就在需要用到它時，直接像這樣使用即可： 1new FormControl('', leoValidator); 又或者是彈性一點，讓使用它的人來決定該欄位的值只能是什麼，其程式碼應該會像是這樣： 1234567891011export function nameValidator(name: string): ValidatorFn { return (control: AbstractControl): ValidationErrors | null =&gt; { if (control.value === name) { return null } return { actualValue: control.value, requiredValue: name }; };} 然後就可以像這樣使用： 1new FormControl('', nameValidator('Leo')); 不過， ValidatorFn 是用同步的方式來執行驗證，萬一遇到需要非同步驗證的情況要怎麼辦？ 非同步驗證器大家應該都滿喜歡玩遊戲的吧？！ 謎之音：不要自己愛玩就認為別人都愛玩 絕大多數的遊戲，尤其是線上遊戲，在取名時不能夠取跟別人相同的名字，而當取到跟別人一樣的名字時，系統會提示「此名稱已被使用」之類的錯誤訊息。 面對這種應用場景，相信大部分的朋友可能會是使用 valueChanges 來訂閱欄位的變化事件，當使用者輸入名稱時，會呼叫 API 讓後端來幫忙驗證該名字是否已被使用，然後再根據回傳結果來決定是否顯示錯誤訊息。 畢竟前端不可能事先取得幾千、幾萬甚至是幾十萬、幾百萬的名字再一一比對吧？ 不過如果有這樣的應用場景，我個人覺得還滿適合使用非同步驗證器來處理的。 順帶一提，這只是我個人舉例，不代表真實應用情況。 AsyncValidator1234567interface AsyncValidator extends Validator { validate(control: AbstractControl): Promise&lt;ValidationErrors | null&gt; | Observable&lt;ValidationErrors | null&gt; // inherited from forms/Validator validate(control: AbstractControl): ValidationErrors | null registerOnValidatorChange(fn: () =&gt; void)?: void} 從上述定義可以看出，跟同步的驗證器所不一樣的是，我們在自訂非同步的驗證器時，不是直接製作一個符合 AsyncValidatorFn 定義的函式 而是要用一個可被注入的 Class 來實作 AsyncValidator 這個介面。 就像下面這個官網的範例一樣： 12345678910111213@Injectable({ providedIn: 'root' })export class UniqueAlterEgoValidator implements AsyncValidator { constructor(private heroesService: HeroesService) {} validate( ctrl: AbstractControl ): Promise&lt;ValidationErrors | null&gt; | Observable&lt;ValidationErrors | null&gt; { return this.heroesService.isAlterEgoTaken(ctrl.value).pipe( map(isTaken =&gt; (isTaken ? { uniqueAlterEgo: true } : null)), catchError(() =&gt; of(null)) ); }} 使用方式為我們欄位設定非同步驗證器的方式也非常地簡單。 以 FormControl 來說， 我們可以用這樣子的方式來設定： 1new FormControl('', [/* 一般驗證器 */], [/* 非同步驗證器 */]); 簡單來說，不論是用 Reactive Forms 的哪種方式建立欄位，非同步驗證器都是放在一般驗證器後面就對了！ 本日小結希望透過今天的分享，能讓大家可以初步掌握自訂驗證器的技巧。雖然在實務上，大家不一定遇的到需要使用非同步驗證器的場景，但如果真的有需要用到又忘記怎麼做時，至少有這篇文章在，隨時都可以回來查詢。 此外，雖然沒有分享自訂 Template Driven Forms 驗證器的方式，但大家可以自行參考官方的 Form Validation - Adding custom validators to template-driven forms 文件。 而在非同步驗證器的部份，官網也有提到一些優化非同步驗證器的技巧，大家可以參考官方的 Form Validation - Optimizing performance of async validators 文件。 以上，就是今天的文章，如果有任何的問題或是回饋，還請麻煩留言給我讓我知道，感激不盡！","link":"/2021/10/11/angular-30days-form-and-test-26/"},{"title":"Angular 深入淺出三十天：表單與測試 Day23 - Reactive Forms 進階技巧 - 欄位連動檢核邏輯","text":"大家在日常生活中，應該看過滿多表單的某個欄位會隨著另個欄位的改變，而造成該欄位的驗證邏輯需要改變的情況吧？ 舉例來說，可能會有個欄位叫做聯絡資訊，使用者可以選擇要填入手機號碼或者是 E-mail ，該欄位再根據使用所選擇的類型來檢核該欄位的值。 今天，我們就來用 Reactive Forms 實作這個欄位，而這個欄位我會實作在我們的被保人表單上，各位就隨意吧！ 如果已經忘記被保人表單長怎麼樣的話，可以先回頭複習一下第十一天的文章：Reactive Forms 實作 - 動態表單初體驗。 實作開始首先，我們需要在原本的被保人表單裡新增一個欄位：聯絡資訊。 HTML 的部份大概會長這樣： 1234567891011&lt;p&gt; &lt;label&gt;聯絡資訊：&lt;/label&gt;&lt;/p&gt;&lt;p&gt; &lt;select&gt; &lt;option value=\"\"&gt;請選擇&lt;/option&gt; &lt;option value=\"mobile\"&gt;手機&lt;/option&gt; &lt;option value=\"email\"&gt;E-Mail&lt;/option&gt; &lt;/select&gt; &lt;input type=\"text\"&gt;&lt;/p&gt; 畫面看起來會像這樣： 雖然聯絡資訊是一個欄位，但其實我們需要兩個 FormControl ，一個給下拉選單，一個給實際填值的 input 元素。 因此，我們要在原本的 createInsuredFormGroup 裡多加兩個欄位，像是這樣： 123456789101112private createInsuredFormGroup(): FormGroup { return this.formBuilder.group({ name: [ '', [Validators.required, Validators.minLength(2), Validators.maxLength(10)] ], gender: ['', Validators.required], age: ['', Validators.required], contactInfoType: ['', Validators.required], contactInfo: ['', Validators.required] });} 然後將剛剛新增的欄位與畫面的元素綁定： 12345678&lt;p&gt; &lt;select formControlName=\"contactInfoType\"&gt; &lt;option value=\"\"&gt;請選擇&lt;/option&gt; &lt;option value=\"mobile\"&gt;手機&lt;/option&gt; &lt;option value=\"email\"&gt;E-Mail&lt;/option&gt; &lt;/select&gt; &lt;input type=\"text\" formControlName=\"contactInfo\"&gt;&lt;/p&gt; 接著我們透過把資料印在畫面上的方式來檢查是否已正確綁定，像這樣： 1&lt;pre&gt;{{ formGroup?.getRawValue() | json }}&lt;/pre&gt; 結果： 看起來已經有正確跟畫面上的元素綁定了，那接下來要怎麼做才好呢？ valueChangesFormControl 的父類別 AbstractControl 有個屬性叫做 valueChanges ，它是一個 Observable 。 我們可以透過訂閱某個 AbstractControl 的 valueChanges 這個 Observable 來知道該欄位是否已經發生變化，並且做出相應的處理。 因此，我們可以這樣調整 createInsuredFormGroup 裡的實作： 1234567891011121314151617181920212223242526272829private createInsuredFormGroup(): FormGroup { const contactInfoTypeControl = this.formBuilder.control('', Validators.required); const contactInfoControl = this.formBuilder.control('', Validators.required); contactInfoTypeControl.valueChanges.subscribe((value) =&gt; { switch (value) { case 'mobile': contactInfoControl.setValidators([Validators.required, Validators.pattern(/$09\\d{8}^/)]); break; case 'email': contactInfoControl.setValidators([Validators.required, Validators.email]); break; default: contactInfoControl.setValidators([Validators.required]); break; } contactInfoControl.updateValueAndValidity(); }); return this.formBuilder.group({ name: [ '', [Validators.required, Validators.minLength(2), Validators.maxLength(10)] ], gender: ['', Validators.required], age: ['', Validators.required], contactInfoType: contactInfoTypeControl, contactInfo: contactInfoControl });} 上述程式碼中有以下三個要點： 建立 FormControl 的時候可以藉由 this.formBuilder.control() 的方式建立，也可以直接使用 new FormControl() 建立，這點在前面的文章已經有提過，不過我在這邊再提醒大家一次。 setValidators() 執行完後，記得一定要使用 updateValueAndValidity() 來更新當前欄位的驗證，不然就要等到該欄位的值有改變時才會以新的驗證器來驗證。 由於 contactInfoType 允許使用者選擇 請選擇 的選項，因此記得在 default 的區塊裡，將 Validators.required 給加回去。 這邊改好之後，我們也順便調整一下 getErrorMessage 的實作，讓使用者可以知道該欄位的驗證有誤： 12345678910111213141516171819202122getErrorMessage(key: string, index: number): string { const formGroup = this.formArray.controls[index]; const formControl = formGroup.get(key); let errorMessage: string; if (!formControl || !formControl.errors || formControl.pristine) { errorMessage = ''; } else if (formControl.errors.required) { errorMessage = '此欄位必填'; } else if (formControl.errors.minlength) { errorMessage = '姓名至少需兩個字以上'; } else if (formControl.errors.maxlength) { errorMessage = '姓名至多只能輸入十個字'; // 增加以下兩個判斷 } else if (formControl.errors.pattern) { errorMessage = '手機號碼格式錯誤'; } else if (formControl.errors.email) { errorMessage = 'E-mail 格式錯誤'; } return errorMessage!;} 這邊要提醒大家的是，由於驗證 E-mail 格式的方式我今天是用 Validators.email 的驗證器來驗，不是之前的 Validators.pattern() ，所以我可以直接用 formControl.errors.email 來判斷。 如果實作時，手機號碼跟 E-mail 都是用 Validators.pattern() 的驗證器來驗的話，就需要進一步去比對 formControl.errors.pattern 裡的 Regular Expression 來分辨究竟是手機號碼的格式錯誤還是 E-mail 的格式錯誤了。 像是這樣： 12345678} else if (formControl.errors.pattern) { const requiredPattern = formControl.errors.pattern.requiredPattern; if (requiredPattern === '/A Regular Expression/') { errorMessage = '手機號碼格式錯誤'; } else if (requiredPattern === '/B Regular Expression/') { errorMessage = 'E-mail 格式錯誤'; }} 如此一來，我們就完成這個欄位的功能囉！ 結果： 本日小結今天的重點是學會如何使用 valueChanges 來動態調整相關欄位的驗證邏輯。 雖然是 Observable 是 RxJS 的東西，但今天並沒有太艱難或太複雜的運用，使用上的感覺會跟使用 Promise 的感覺類似，不過我個人認為 RxJS 好玩且強大許多。 關於 RxJS ，如果大家想知道更多資訊，我推薦大家去看 Mike 的打通 RxJS 任督二脈系列文，或者是直接買實體書也行。 雖然今天的實作已經完成了，但因為有調整程式碼的關係，測試程式碼其實也需要相應的調整才不會出錯，此部份就交給大家實作我就不再用篇幅分享實作囉！ 今天的程式碼會放在 Github - Branch: day23 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，還請麻煩留言給我讓我知道！","link":"/2021/10/08/angular-30days-form-and-test-23/"},{"title":"Angular 深入淺出三十天：表單與測試 Day25 - 測試進階技巧 - DI 抽換","text":"好一陣子沒寫單元測試與整合測試了，大家是否覺得有些生疏了呢？ 之前的測試都寫得很簡單，正好昨天好好地寫了搜尋輸入框還有呼叫 API ，可以藉由撰寫這個功能的測試來分享一些小技巧給大家。 小提醒：昨天的程式碼大家可以從 Github - Branch: day24 上 Clone 或者是 Fork 下來。 實作開始這次要撰寫測試的檔案比較多，有三個 Pipe 、 一個 Service 與一個 Component 的測試需要撰寫。 不過雖然檔案比較多，但要撰寫的測試其實不會比較難，相反地，由於我們昨天在開發的時候有把邏輯切到各個 Pipe 與 Service ，因此凡而在撰寫測試上會顯得更加地好寫。 測試單元 - BooleanInZhTwPipe首先，我們來看看最簡單的 BooleanInZhTwPipe ，其程式碼如下： 1234567export class BooleanInZhTwPipe implements PipeTransform { transform(value: boolean, ...args: unknown[]): string { return value ? '是' : '否'; }} BooleanInZhTwPipe 只有一個函式 transform ，因此我們只要驗證： 當傳入的 value 為 true 時，則回傳 是 。 當傳入的 value 為 false 時，則回傳 否 。 夠簡單了吧？ 測試程式碼如下： 123456789101112131415161718192021222324252627282930313233343536describe('BooleanInZhTwPipe', () =&gt; { let pipe: BooleanInZhTwPipe; beforeEach(() =&gt; { pipe = new BooleanInZhTwPipe(); }); it('create an instance', () =&gt; { expect(pipe).toBeTruthy(); }); describe('transform', () =&gt; { describe('when the first parameter is `true`', () =&gt; { it('should return \"是\"', () =&gt; { // Arrange const firstParameter = true; const expectedResult = '是'; // Acc const actualResult = pipe.transform(firstParameter); // Assert expect(actualResult).toBe(expectedResult); }); }); describe('when the first parameter is `false`', () =&gt; { it('should return \"否\"', () =&gt; { // Arrange const firstParameter = false; const expectedResult = '否'; // Acc const actualResult = pipe.transform(firstParameter); // Assert expect(actualResult).toBe(expectedResult); }); }); });}); 測試結果： 測試單元 - GoogleMapLinkPipeGoogleMapLinkPipe 的部份也很簡單，其程式碼如下： 1234567export class GoogleMapLinkPipe implements PipeTransform { transform({ PositionLat, PositionLon }: StationPosition, ...args: unknown[]): string { return `https://www.google.com/maps?q=${PositionLat},${PositionLon}&amp;z=7`; }} 而其驗證項目只需要驗證將傳入的第一個參數的 PositionLat 跟 PositionLong 是否有與 URL 相結合即可。 其測試程式碼如下： 12345678910111213141516171819202122232425262728describe('GoogleMapLinkPipe', () =&gt; { let pipe: GoogleMapLinkPipe; beforeEach(() =&gt; { pipe = new GoogleMapLinkPipe(); }); it('create an instance', () =&gt; { expect(pipe).toBeTruthy(); }); describe('transform', () =&gt; { describe('when the first parameter is `true`', () =&gt; { it('should return \"https://www.google.com/maps?q=2.34567,12.34567&amp;z=7\"', () =&gt; { // Arrange const firstParameter: StationPosition = { PositionLon: 12.34567, PositionLat: 2.34567, GeoHash: 'abcdefg' }; const expectedResult = 'https://www.google.com/maps?q=2.34567,12.34567&amp;z=7'; // Acc const actualResult = pipe.transform(firstParameter); // Assert expect(actualResult).toBe(expectedResult); }); }); });}); 測試結果： 測試單元 - LocationStringPipe最後一個 Pipe ─ LocationStringPipe 的程式碼如下： 1234567export class LocationStringPipe implements PipeTransform { transform({ PositionLat, PositionLon }: StationPosition, ...args: unknown[]): string { return `${PositionLat}, ${PositionLon}`; }} 其驗證項目只需要驗證將傳入的第一個參數的 PositionLat 跟 PositionLong 是否有變成字串並在其中加上逗號即可。 其測試程式碼如下： 1234567891011121314151617181920212223242526272829describe('LocationStringPipe', () =&gt; { let pipe: LocationStringPipe; beforeEach(() =&gt; { pipe = new LocationStringPipe(); }); it('create an instance', () =&gt; { const pipe = new LocationStringPipe(); expect(pipe).toBeTruthy(); }); describe('transform', () =&gt; { describe('when the first parameter is `true`', () =&gt; { it('should return \"2.34567, 12.34567\"', () =&gt; { // Arrange const firstParameter: StationPosition = { PositionLon: 12.34567, PositionLat: 2.34567, GeoHash: 'abcdefg' }; const expectedResult = '2.34567, 12.34567'; // Acc const actualResult = pipe.transform(firstParameter); // Assert expect(actualResult).toBe(expectedResult); }); }); });}); 測試結果： 至此， Pipe 的部份就全測完了，相信大家這部份一定沒什麼問題。 而大家應該也有發現，我們在今天在驗 Pipe 的時候跟在驗 Component 的時候有一個滿明顯的不同，那就是我們今天沒有 TestBed 。 其實這是因為我們的這幾個 Pipe 很乾淨，沒有依賴任何其他的 Class ，所以在撰寫測試時，其實就把它當成一般的 Class ，用 new xxxPipe() 的方式產生出實體就行了。 ReactiveFormsAutoCompleteSearchingService剛剛前面的 Pipe 只是先讓大家熱熱身，抓抓手感，接下來我們要為 ReactiveFormsAutoCompleteSearchingService 撰寫測試，算是今天的重頭戲之一。 雖然 ReactiveFormsAutoCompleteSearchingService 的程式碼也很簡單，但為什麼會是今天的重頭戲呢？ 這是因為 ReactiveFormsAutoCompleteSearchingService 有用到我們之前沒有用過的 httpClient 。 先來看看它的程式碼： 123456789101112export class ReactiveFormsAutoCompleteSearchingService { constructor(private httpClient: HttpClient) { } searchStation(stationName: string): Observable&lt;MetroStationDTO[]&gt; { let url = 'https://ptx.transportdata.tw/MOTC/v2/Rail/Metro/Station/TRTC?$format=JSON'; if (stationName) { url += `&amp;$filter=contains(StationName/Zh_tw,'${stationName}')`; } return this.httpClient.get&lt;MetroStationDTO[]&gt;(url); }} ReactiveFormsAutoCompleteSearchingService 跟上面的 Pipe 一樣，都只有一個函式，不過在這個函式裡我們會需要驗兩個情境，四個案例： 呼叫 searchStation 所帶入的參數是空字串時 該函式會回傳一個 Observable （單元測試） 要呼叫 httpClient 的 get 函式，並帶入參數 https://ptx.transportdata.tw/MOTC/v2/Rail/Metro/Station/TRTC?$format=JSON （整合測試） 呼叫 searchStation 所帶入的參數是有效字串時 該函式會回傳一個 Observable （單元測試） 要呼叫 httpClient 的 get 函式，並帶入參數 https://ptx.transportdata.tw/MOTC/v2/Rail/Metro/Station/TRTC?$format=JSON&amp;$filter=contains(StationName/Zh_tw,'xxx') （整合測試） 開始撰寫測試之前，我們一樣先把 ReactiveFormsAutoCompleteSearchingService 所依賴的項目準備好： 1234567beforeEach(() =&gt; { TestBed.configureTestingModule({ imports: [HttpClientTestingModule], providers: [ReactiveFormsAutoCompleteSearchingService] }); service = TestBed.inject(ReactiveFormsAutoCompleteSearchingService);}); 準備好依賴項目之後，就可以開始撰寫測試程式囉。 看仔細噢！原本 Service 要使用 HttpClient 的話，正常要在模組內引入 HttpClientModule 。 但在撰寫測試時，我們要引入的是 HttpClientTestingModule 這個 Angular 幫我們準備好專門給撰寫測試所要引入的 Module 。 我的測試程式碼如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243describe('searchStation', () =&gt; { describe('When the stationName is a empty string', () =&gt; { const stationName = ''; it('should return a Observable', () =&gt; { // Act const result = service.searchStation(stationName); // Assert expect(result).toBeInstanceOf(Observable); }); it('should call function \"get\" of the \"HttpClient\" with the correct API\\'s URL', () =&gt; { // Arrange const apiUrl = 'https://ptx.transportdata.tw/MOTC/v2/Rail/Metro/Station/TRTC?$format=JSON'; const httpClient = TestBed.inject(HttpClient); spyOn(httpClient, 'get'); // Act service.searchStation(stationName); // Assert expect(httpClient.get).toHaveBeenCalledWith(apiUrl); }); }); describe('When the stationName is a valid string', () =&gt; { const stationName = 'Leo'; it('should return a Observable', () =&gt; { // Act const result = service.searchStation(stationName); // Assert expect(result).toBeInstanceOf(Observable); }); it('should call function \"get\" of the \"HttpClient\" with the correct API\\'s URL', () =&gt; { // Arrange const apiUrl = 'https://ptx.transportdata.tw/MOTC/v2/Rail/Metro/Station/TRTC?$format=JSON&amp;$filter=contains(StationName/Zh_tw,\\'Leo\\')'; const httpClient = TestBed.inject(HttpClient); spyOn(httpClient, 'get'); // Act service.searchStation(stationName); // Assert expect(httpClient.get).toHaveBeenCalledWith(apiUrl); }); });}); 測試結果： ReactiveFormsAutoCompleteSearchingComponent最後要測的是 ReactiveFormsAutoCompleteSearchingComponent ，由於是 Component 的關係，基本上除了 Class 本身之外，我們還要來驗證 Template 的部份。 先來看看 Class 的程式碼： 123456789101112export class ReactiveFormsAutoCompleteSearchingComponent { searchingInputControl = new FormControl(); stations$ = this.searchingInputControl.valueChanges.pipe( startWith(''), debounceTime(500), switchMap(value =&gt; this.service.searchStation(value)) ); constructor(private service: ReactiveFormsAutoCompleteSearchingService) { }} 這個 Component 要驗的情境有： 驗證 searchingInputControl 是不是 FormControl 驗證 stations$ 是不是 Observable 驗證 stations$ 被訂閱時， ReactiveFormsAutoCompleteSearchingService 的函式 searchStation 會不會被呼叫並傳入空字串 驗證 searchingInputControl 的值變動時， ReactiveFormsAutoCompleteSearchingService 的函式 searchStation 會不會被呼叫並傳入 searchingInputControl 的值 驗證 searchingInputControl 的值快速變動兩次時，ReactiveFormsAutoCompleteSearchingService 的函式 searchStation 是否只被呼叫一次 驗證 searchingInputControl 的值變動兩次的間隔時間超過 500 毫秒時，ReactiveFormsAutoCompleteSearchingService 的函式 searchStation 是否被呼叫兩次 開始測試前，一樣先把依賴的項目準備好： 123456789101112131415161718192021222324252627describe('ReactiveFormsAutoCompleteSearchingComponent', () =&gt; { let component: ReactiveFormsAutoCompleteSearchingComponent; let fixture: ComponentFixture&lt;ReactiveFormsAutoCompleteSearchingComponent&gt;; beforeEach(async () =&gt; { await TestBed.configureTestingModule({ declarations: [ReactiveFormsAutoCompleteSearchingComponent], providers: [ { provide: ReactiveFormsAutoCompleteSearchingService, useValue: { searchStation: () =&gt; EMPTY } } ] }) .compileComponents(); fixture = TestBed.createComponent(ReactiveFormsAutoCompleteSearchingComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () =&gt; { expect(component).toBeTruthy(); });}); 從上述程式碼中，大家可能會發現以前從來沒看過的程式碼： 123456{ provide: ReactiveFormsAutoCompleteSearchingService, useValue: { searchStation: () =&gt; EMPTY }} 而這也是我們今天文章的主軸， DI 抽換 。 DI 抽換DI ，也就是 Dependency Injection ，依賴注入。 這點大家應該知道，而 DI 抽換是 Angular 提供的一個很有趣的功能，讓我們可以用以下三種方式替換掉想替換的 Provider ： useClass ─ 提供一個繼承於想替換掉的 Provider 的 Class ，然後用新的 Class 取代原本的 Provider 像是： 1234567891011121314class MyRouter extends Router { // ...}@NgModule({ // ... providers: [ { provide: Router, useClass: MyRouter } ]})export class AbcModule { } useValue ─ 像剛剛在測試程式碼裡所寫的那樣，直接用物件抽換掉想換掉的 Provider useFactory ─ 用函式來抽換，像是： 1234567891011121314const abcServiceFactory = () =&gt; { return new AbcService();}@NgModule({ // ... providers: [ { provide: AbcService, useClass: abcServiceFactory } ]})export class ABCModule { } 關於這部份，真的要講很細的話可以寫一整篇，不過我今天只是想讓大家知道我們可以透過 DI 抽換的方式，把不可控的依賴變成可控的，這樣才能寫出優秀的測試。 關於 DI 抽換的部分，如果想了解更多可以參考官方的 Dependency providers 文件。 知道 DI 抽換是什麼概念之後，我們就來開始撰寫測試案例吧！ 我的測試程式碼如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778describe('Property searchingInputControl', () =&gt; { it('should be a instance of FormControl', () =&gt; { // Assert expect(component.searchingInputControl).toBeInstanceOf(FormControl); });});describe('Property stations$', () =&gt; { it('should be a instance of FormControl', () =&gt; { // Assert expect(component.stations$).toBeInstanceOf(Observable); }); describe('when it be subscribed', () =&gt; { let service: ReactiveFormsAutoCompleteSearchingService; beforeEach(() =&gt; { service = TestBed.inject(ReactiveFormsAutoCompleteSearchingService); spyOn(service, 'searchStation').and.returnValue(of([])); }); it('should call function \"searchStation\" of the service with empty string', (done) =&gt; { // Act component.stations$.subscribe(() =&gt; { // Assert expect(service.searchStation).toHaveBeenCalledOnceWith(''); done(); }); }); describe('when the input value changes', () =&gt; { it('should call function \"searchStation\" of the service with the value', (done) =&gt; { // Arrange const value = 'Leo' // Act component.stations$.subscribe(() =&gt; { // Assert expect(service.searchStation).toHaveBeenCalledOnceWith(value); done(); }); component.searchingInputControl.patchValue(value); }); }); describe('when the input value changes twice quickly', () =&gt; { it('should call function \"searchStation\" of the service once with the last value', (done) =&gt; { // Arrange const firstValue = 'Leo' const secondValue = 'Chen' // Act component.stations$.subscribe(() =&gt; { // Assert expect(service.searchStation).toHaveBeenCalledOnceWith(secondValue); done(); }); component.searchingInputControl.patchValue(firstValue); component.searchingInputControl.patchValue(secondValue); }); }); describe('when the input value changes twice slowly', () =&gt; { it('should call function \"searchStation\" of the service twice', fakeAsync(() =&gt; { // Arrange const firstValue = 'Leo' const secondValue = 'Chen' // Act component.stations$.subscribe(); component.searchingInputControl.patchValue(firstValue); tick(600); component.searchingInputControl.patchValue(secondValue); tick(600); // Assert expect(service.searchStation).toHaveBeenCalledTimes(2); expect(service.searchStation).toHaveBeenCalledWith(firstValue); expect(service.searchStation).toHaveBeenCalledWith(secondValue); })); }); })}); 測試結果： 在上述的測試程式碼中，我們可以看到今天要分享給大家的最後一個技巧：非同步測試。 Angular 的非同步測試技巧在驗證非同步事件處理邏輯如 Promise 與 Observable 時，最簡單的方式當然就是直接 then 或是 subscribe 之後再驗證。 而這時我們會在傳入 it 的函式裡，多一個名為 done 的參數 （你要取名為別的名字也可以） ，如此我們就可以讓測試知道我們要等非同步事件完成後再行驗證。 像這樣： 12345it('description', (done) =&gt; { observable.subscribe(() =&gt; { done(); });}); 但除了這個方式外，Angular 還有提供另一個方式是是永 fakeAsync 與 tick 的組合。 使用方式是將原本要傳入 it 裡的函式傳入 fakeAsync() 裡並用它來做替代，接著就可以在 it 裡面使用 tick() 這個函式來代表時間的流逝。 例如： 1234567it('description', fakeAsync(() =&gt; { // Do A tick(300) // ms // Assert A})); 而且這個時間的流逝是假的，又或者是說，有種「時間加速器的概念」。 假設 Do A 到 Assert A 之間相隔十年，用了 tick(10年) 之後，瞬間就過完了十年，厲害吧！ 簡直媲美薩諾斯收集完無限寶石之後，一彈指就讓全宇宙的一半人口都灰飛湮滅的帥度 今天差不多就到這邊，訊息量應該滿大的，至於剩下 Template 的測試沒什麼太特別的地方，就讓大家練習做做看囉！ 本日小結今天的重點： 如果被測試的 Class 沒有任何依賴，則只需使用 new XXX() 來產生實體即可（ Component 除外） 如果有使用到 HttpClient 的話，撰寫測試時要引入的是 HttpClientTestingModule ，而不是 HttpClientModule DI 抽換 非同步的處理 以上技巧會在大家實際撰寫測時非常大量的使用，記得要多加練習才會熟能生巧噢！ 今天的程式碼會放在 Github - Branch: day25 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，還請麻煩留言給我讓我知道！","link":"/2021/10/10/angular-30days-form-and-test-25/"},{"title":"Angular 深入淺出三十天：表單與測試 Day24 - Reactive Forms 進階技巧 - Auto-Complete Searching","text":"在日常生活中，大家應該滿常看到有些系統的搜尋輸入框是可以在一邊打字的同時，一邊將搜尋結果呈現在一個下拉選單裡，非常地貼心且方便。 當然，這其中其實有很多細節，不過我們今天就專注在前端的表單開發上，來用 Reactive Forms 實作這個搜尋輸入框吧！ 沒錯，就算只是個搜尋框，它也是個表單噢！ 正好最近六角學院即將舉辦第三屆的前端 &amp; UI 修煉精神時光屋的活動，這次它們與交通部合作，並提供了全國最大的運輸資料流通服務平台 (TDX) 之交通 API 給大家使用，讓大家可以透過此活動精進自己的實力，非常推薦給大家。 想當初我第一次寫鐵人賽時，也是使用了參加六角舉辦的第一屆前端修煉精神時光屋的素材來寫，雖然這次沒有要參賽，但又跟六角有關係了呢！ 總之，藉由這次的機會與交通部提供的 運輸資料流通服務平台 (TDX) 之交通 API ，我們來簡單地做一個可以查詢台北捷運的車站的搜尋輸入框吧！ 這次因為有 API 可以使用的關係，會精實很多，如果跟不上的朋友，可能要再多熟悉一下 Angular 噢！ 需求規格說明簡單來說，這個功能會需要一個輸入框與一個表格，當使用者在輸入框裡打字時，表格的內容也會連動呈現出搜尋結果。 由於 Auto-Complete 的搜尋輸入框如果要自己做會需要處理不少細節，又不想安裝 UI 框架佔篇幅，所以我用這個方式來呈現查詢結果。 表格的欄位有以下這些： 車站代號 車站名稱 車站所屬縣市 車站所屬鄉鎮區 假日是否允許自行車進出站 位置 最後呈現結果： 實作開始首先，如果在需求明確的情況下，我個人習慣會先把畫面準備好。 HTML 的部份大概會長這樣： 12345678910111213141516171819202122232425262728&lt;p&gt;&lt;input type=\"text\" placeholder=\"請輸入捷運站名稱\" /&gt;&lt;/p&gt;&lt;table&gt; &lt;caption&gt; 台北捷運之捷運站查詢結果 &lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;車站代號&lt;/td&gt; &lt;td&gt;車站名稱&lt;/td&gt; &lt;td&gt;車站所屬縣市&lt;/td&gt; &lt;td&gt;車站所屬鄉鎮區&lt;/td&gt; &lt;td&gt;假日是否允許自行車進出站&lt;/td&gt; &lt;td&gt;位置&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;a target=\"_blank\" href=\"\"&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; CSS 的部份大家就自行發揮囉！ 畫面看起來會像這樣： 接著我們會需要一個 FormControl 來跟輸入框綁定，所以我們在 .ts 裡新增一個屬性 ─ searchingInputControl： 12345export class ReactiveFormsAutoCompleteSearchingComponent implements OnInit { searchingInputControl = new FormControl();} 別忘了先到 .module.ts 裡引入 FormsModule 與 ReactiveFormsModule 噢！ 然後將 searchingInputControl 與畫面輸入框綁定： 1&lt;p&gt;&lt;input type=\"text\" placeholder=\"請輸入捷運站名稱\" [formControl]=\"searchingInputControl\" /&gt;&lt;/p&gt; 接著我們使用昨天分享過的 valueChanges 來確認是否已正確綁定： 1234567891011export class ReactiveFormsAutoCompleteSearchingComponent implements OnInit { searchingInputControl = new FormControl(); ngOnInit(): void { this.searchingInputControl.valueChanges.subscribe((value) =&gt; { console.log(value); }); }} 結果： 看起來已經有正確的跟搜尋輸入框綁定了，那接下來要怎麼做才好呢？ Service我們的目的是希望使用者在輸入捷運站名稱的同時，只留下跟使用者的輸入有關聯的捷運站。 因此，我們會需要一支 Service 來幫我們呼叫交通部所提供的 運輸資料流通服務平台 (TDX) 之交通 API ，並把查詢結果顯示到畫面上。 Service 的程式碼大概會長這個樣子： 12345678910111213@Injectable()export class ReactiveFormsAutoCompleteSearchingService { constructor(private httpClient: HttpClient) { } searchStation(stationName: string): Observable&lt;MetroStationDTO[]&gt; { let url = 'https://ptx.transportdata.tw/MOTC/v2/Rail/Metro/Station/TRTC?$format=JSON'; if (stationName) { url += `&amp;$filter=contains(StationName/Zh_tw,'${stationName}')`; } return this.httpClient.get&lt;MetroStationDTO[]&gt;(url); }} 上述程式碼中有以下幾個重點： 要呼叫 API 的話，需要先到 .module.ts 裡引入 HttpClientModule ，才能在 Service 裡使用 HttpClient 來呼叫 API。 MetroStationDTO 是我根據交通部所提供的 運輸資料流通服務平台 (TDX) 之交通 API 裡定義的資料介面，詳細位置需先選擇「軌道」再點選「捷運」，如下圖所示： 由於 HTTP Method 是 GET 的緣故，所以參數是使用 Query Parameters 的方式帶進 URL 之中。 如果使用者沒有輸入站名時，還帶 $filter 參數會收到伺服器回傳的 Bed Request 錯誤，因此增加一個判斷式 ─ 當傳入的 stationName 為 Truthy 值時，才帶 $filter 參數。 參數 $filter 的值該怎麼帶這件事情其實在文件中沒有寫，算是這個文件比較美中不足的地方。好在六角學院的院長 ─ 廖洧杰院長前陣子有開直播課教學，而我猜測院長一定有在那堂課講這件事情，所以去翻了一下該堂直播課的共筆才找到該怎麼帶它的值。 Service 準備好之後，接下來就要將 FormControl 的 valueChanges 事件與 API 相結合了。 準備好見證神蹟了嗎？ OperatorsRxJS 真的是一個很棒的函式庫，它讓我們可以很好地操作非同步與資料串流，而且還能讓我們的程式碼非常地簡潔、非常地好閱讀。 就像我們現在需要把使用者的輸入事件與 API 做結合時，用 RxJS 的 Operators 就可以非常完美、漂亮地結合在一起。 就像這樣： 1234567891011121314151617export class ReactiveFormsAutoCompleteSearchingComponent implements OnInit { searchingInputControl = new FormControl(); constructor(private service: ReactiveFormsAutoCompleteSearchingService) { } ngOnInit(): void { this.searchingInputControl.valueChanges.pipe( startWith(''), debounceTime(500), switchMap(value =&gt; this.service.searchStation(value)) ).subscribe((result) =&gt; { console.log(result); }); }} 結果： 我相信在這邊一定會有非常多朋友看傻眼，這是什麼神操作？！這樣就接好了？！ 沒錯！這樣就接好了，是不是比你想像中簡單非常多呢？ 那這串到底做了什麼事呢？ 首先，我希望這個畫面一開始的時候就會先查詢一次，所以我使用 startWith('') 來呼叫查詢 API 。 再者，我希望查詢的間隔不要太過快速，當使用者「可能」已經打完字的時候才查詢，所以我使用 debounceTime(500) 來讓查詢的時間點會在使用者停止打字 500 毫秒後才呼叫查詢 API。 最後，則要將原本是 valueChanges 的 Observable 轉換成 呼叫 API 的 Observable 這件事情 ，所以我使用 switchMap(value =&gt; this.service.searchStation(value)) 。 關於 startWith ，大家可以參考官方文件或是 Mike 的文章。 關於 debounceTime ，大家可以參考官方文件或是 Mike 的文章。 關於 switchMap ，大家可以參考官方文件或是 Mike 的文章。 AsyncPipe接著，我們要將得到的資料綁定到畫面上，而綁定到畫面上的方式大致上有兩種： 自己訂閱後將資料指定給 Component 的屬性： 123456789101112131415161718export class ReactiveFormsAutoCompleteSearchingComponent implements OnInit { searchingInputControl = new FormControl(); stations: MetroStationDTO[] = []; constructor(private service: ReactiveFormsAutoCompleteSearchingService) { } ngOnInit(): void { this.searchingInputControl.valueChanges.pipe( startWith(''), debounceTime(500), switchMap(value =&gt; this.service.searchStation(value)) ).subscribe((stations) =&gt; { this.stations = stations; }); }} 然後再綁到畫面上： 1234567891011121314151617181920212223242526272829&lt;table&gt; &lt;caption&gt; 台北捷運之捷運站查詢結果 &lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;車站代號&lt;/td&gt; &lt;td&gt;車站名稱&lt;/td&gt; &lt;td&gt;車站所屬縣市&lt;/td&gt; &lt;td&gt;車站所屬鄉鎮區&lt;/td&gt; &lt;td&gt;假日是否允許自行車進出站&lt;/td&gt; &lt;td&gt;位置&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr *ngFor=\"let station of stations\"&gt; &lt;td&gt;{{ station.StationID }}&lt;/td&gt; &lt;td&gt;{{ station.StationName.Zh_tw }}&lt;/td&gt; &lt;td&gt;{{ station.LocationCity }}&lt;/td&gt; &lt;td&gt;{{ station.LocationTown }}&lt;/td&gt; &lt;td&gt;{{ station.BikeAllowOnHoliday }}&lt;/td&gt; &lt;td&gt; &lt;a target=\"_blank\" [href]=\"station.StationPosition\"&gt; {{ station.StationPosition }} &lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 不要自己訂閱，先將 Observable 準備好並用 Component 的屬性儲存起來： 123456789101112export class ReactiveFormsAutoCompleteSearchingComponent { searchingInputControl = new FormControl(); stations$ = this.searchingInputControl.valueChanges.pipe( startWith(''), debounceTime(500), switchMap(value =&gt; this.service.searchStation(value)) ); constructor(private service: ReactiveFormsAutoCompleteSearchingService) { }} 然後透過 AsyncPipe 讓 Template 自己訂閱： 1234567891011121314151617181920212223242526272829&lt;table&gt; &lt;caption&gt; 台北捷運之捷運站查詢結果 &lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;車站代號&lt;/td&gt; &lt;td&gt;車站名稱&lt;/td&gt; &lt;td&gt;車站所屬縣市&lt;/td&gt; &lt;td&gt;車站所屬鄉鎮區&lt;/td&gt; &lt;td&gt;假日是否允許自行車進出站&lt;/td&gt; &lt;td&gt;位置&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr *ngFor=\"let station of (stations$ | async) || []\"&gt; &lt;td&gt;{{ station.StationID }}&lt;/td&gt; &lt;td&gt;{{ station.StationName.Zh_tw }}&lt;/td&gt; &lt;td&gt;{{ station.LocationCity }}&lt;/td&gt; &lt;td&gt;{{ station.LocationTown }}&lt;/td&gt; &lt;td&gt;{{ station.BikeAllowOnHoliday }}&lt;/td&gt; &lt;td&gt; &lt;a target=\"_blank\" [href]=\"station.StationPosition\"&gt; {{ station.StationPosition }} &lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 就結果來說，這兩個方法基本上都可以，但我個人非常推薦使用第二種方式。 原因是使用第二種的方式一方面可以避免我們在 Component 被 Destroy 時忘記解除訂閱而導致 Memory Leak 的情形，另一方面是 Observable 會比單純資料好用很多。 甚至有時候我們自己訂閱會發生「明明資料就有收到但畫面沒有更新」的詭異狀況。 結果： Other Pipes雖然目前運作良好，但還有一些小東西還沒處理完： 假日是否允許自行車進出站的欄位我想讓它呈現 是 或是 否 。 位置的欄位我想讓它以 latitude, longitude 的格式呈現。 連結我想要可以點擊後用新的頁籤打開 Google Map ，並會看到那個捷運站的位置。 以上這三個小東西非常地簡單，我想大家應該也都知道該怎麼做，但是既然都已經到了第二十四天了，這邊我覺得我們要使用 Pipe ，而不是像之前一樣直接寫在 Component 裡。 這是因為，如果像之前的 getErrorMessage 是寫在 Component 裡的話，其實當畫面渲染時，該函式就會被呼叫，不管該值有沒有被改變。 但是使用 Pipe 的話，在該值被改變前，是不會被呼叫第二次的。 再者，使用 Pipe 的話，重用性與可維護性也比較好。 所以我建議大家可以使用 Pipe 來完成最後的小調整。 我個人會建立三個 Pipe ─ BooleanInZhTwPipe 、 GoogleMapLinkPipe 與 LocationStringPipe 。 它們的程式碼如下： 123456789@Pipe({ name: 'booleanInZhTw'})export class BooleanInZhTwPipe implements PipeTransform { transform(value: boolean, ...args: unknown[]): string { return value ? '是' : '否'; }} 12345678910@Pipe({ name: 'googleMapLink'})export class GoogleMapLinkPipe implements PipeTransform { transform({ PositionLat, PositionLon }: StationPosition, ...args: unknown[]): string { return `https://www.google.com/maps?q=${PositionLat},${PositionLon}&amp;z=7`; }} 12345678910@Pipe({ name: 'locationString'})export class LocationStringPipe implements PipeTransform { transform({ PositionLat, PositionLon }: StationPosition, ...args: unknown[]): string { return `${PositionLat}, ${PositionLon}`; }} 最終結果： 本日小結今天的重點主要是： 學習如何使用 TDX API 。 學習如何使用 RxJS 的 Operator ─ startWith 、 debounceTime 與 switchMap 將 valueChanges 與呼叫 API 串聯。 學習如何使用 AsyncPipe 。 學習如何自定 Pipe 。 今天的練習對於一些剛學 Angular 的朋友來說會滿精實且資訊量有點大的，大家可以多看幾遍，多自己練習、做實驗，相信對大家來說會很有幫助。 關於 RxJS ，如果大家想知道更多資訊，我推薦大家去看 Mike 的打通 RxJS 任督二脈系列文，或者是直接買實體書也行。 雖然今天的實作已經完成了，但還有測試的部份，我們明天來撰寫它吧！ 今天的程式碼會放在 Github - Branch: day24 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，還請麻煩留言給我讓我知道！","link":"/2021/10/09/angular-30days-form-and-test-24/"},{"title":"Angular 深入淺出三十天：表單與測試 Day29 - ControlContainer","text":"昨天跟大家分享了自訂表單元件的作法，但昨天的作法只適用於一個欄位、一個 FormControl 。 雖然 FormControl 裡是可以設 {} 的值，但如果我們真的想要的是一個可以直接用 [formGroup] 、 [formArray] 所使用的元件呢？ 沒問題，只要你想要， Angular 都給你 實作開始大家還記得之前我們做了個「被保人表單」吧？ 一開始只有「姓名」、「性別」跟「年齡」這三個欄位，後來我們加了「聯絡資訊」的欄位，這次我們再幫它加個「聯絡地址」的欄位吧！ 一般來說，聯絡地址的欄位通常會分成「縣市」、「鄉鎮市區」、「郵遞區號」與「地址」，而「縣市」、「鄉鎮市區」與「郵遞區號」之間會有一些連動邏輯，縣市」與「鄉鎮市區」這兩個欄位也通常會是下拉選單，其他的則是一般的 input 欄位。 首先一樣先把 HTML 準備好，像這樣： 12345678910111213&lt;p&gt;&lt;label&gt;聯絡地址：&lt;/label&gt;&lt;/p&gt;&lt;p&gt; &lt;select&gt; &lt;option value=\"\"&gt;請選擇縣市&lt;/option&gt; &lt;/select&gt; &lt;select&gt; &lt;option value=\"\"&gt;請選擇鄉鎮市區&lt;/option&gt; &lt;/select&gt;&lt;/p&gt;&lt;p&gt; &lt;input type=\"text\" style=\"width: 4rem\" placeholder=\"郵遞區號\"&gt; &lt;input type=\"text\" place=\"請輸入地址\"&gt;&lt;/p&gt; 畫面： 樣式用 inline 的方式設定是方便教學，小朋友們要盡量少用噢！ 接著，在 .ts 裡加入地址的相關欄位的 FormGroup 與 FormControl ： 123456789101112131415161718const addressInfoFormGroup = this.formBuilder.group({ city: '', district: '', zip: '', address: ''});return this.formBuilder.group({ name: [ '', [Validators.required, Validators.minLength(2), Validators.maxLength(10)] ], gender: ['', Validators.required], age: ['', Validators.required], contactInfoType: contactInfoTypeControl, contactInfo: contactInfoControl, addressInfo: addressInfoFormGroup}); 然後再將其綁與畫面上元素綁定，像這樣： 123456789101112131415&lt;ng-container formGroupName=\"addressInfo\"&gt; &lt;p&gt;&lt;label&gt;聯絡地址：&lt;/label&gt;&lt;/p&gt; &lt;p&gt; &lt;select formControlName=\"city\"&gt; &lt;option value=\"\"&gt;請選擇縣市&lt;/option&gt; &lt;/select&gt; &lt;select formControlName=\"district\"&gt; &lt;option value=\"\"&gt;請選擇鄉鎮市區&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"text\" style=\"width: 4rem\" placeholder=\"郵遞區號\" formControlName=\"zip\"&gt; &lt;input type=\"text\" placeholder=\"請輸入地址\" formControlName=\"address\"&gt; &lt;/p&gt;&lt;/ng-container&gt; 連動邏輯的實作就交給大家練習囉，我們今天沒有要著重於此部分的處理。 至此，我們就完成了第一步的準備工作。 ControlContainer接下來，我們就要將聯絡地址這塊拆成一個獨立的 Component ─ AddressInfoComponent 。 首先，先將 HTML 搬過去並稍微調整一下： 1234567891011121314&lt;ng-container [formGroup]=\"formGroup\"&gt; &lt;p&gt; &lt;select formControlName=\"city\"&gt; &lt;option value=\"\"&gt;請選擇縣市&lt;/option&gt; &lt;/select&gt; &lt;select formControlName=\"district\"&gt; &lt;option value=\"\"&gt;請選擇鄉鎮市區&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"text\" style=\"width: 4rem\" placeholder=\"郵遞區號\" formControlName=\"zip\"&gt; &lt;input type=\"text\" placeholder=\"請輸入地址\" formControlName=\"address\"&gt; &lt;/p&gt;&lt;/ng-container&gt; 接著在 AddressInfoComponent 裡注入 ControlContainer： 12345export class AddressInfoComponent { constructor(private controlContainer: ControlContainer) { }} 然後加上： 123get formGroup(): FormGroup { return this.controlContainer.control as FormGroup;} 再回到被保人表單裡，把原本的聯絡地址區塊改成： 12&lt;p&gt;&lt;label&gt;聯絡地址：&lt;/label&gt;&lt;/p&gt;&lt;app-address-info formGroupName=\"addressInfo\"&gt;&lt;/app-address-info&gt; 至此就大功告成了！是不是超簡單的？！ 不過之所以這麼簡單是因為這是 Reactive Forms 的方式，今天的 ControlContainer 不像昨天的 ControlValueAccessor 可以做一次之後，兩種方式都可以使用。 如果今天這個元件是要讓 Template Driven Forms 使用的話，首先要先將 Template 原本用 Reactive Forms 的綁定方式改成使用 Template Driven Forms 的綁定方式，像是這樣： 1234567891011121314&lt;ng-container ngModelGroup=\"addressInfo\"&gt; &lt;p&gt; &lt;select name=\"zip\" ngModel&gt; &lt;option value=\"\"&gt;請選擇縣市&lt;/option&gt; &lt;/select&gt; &lt;select name=\"district\" &gt; &lt;option value=\"\"&gt;請選擇鄉鎮市區&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"text\" style=\"width: 4rem\" placeholder=\"郵遞區號\" name=\"zip\" ngModel&gt; &lt;input type=\"text\" placeholder=\"請輸入地址\" name=\"address\" ngModel&gt; &lt;/p&gt;&lt;/ng-container&gt; 然後也不用在 AddressInfoComponent 裡注入 ControlContainer ，而是改在 AddressInfoComponent 的 MetaData 的 viewProviders 裡新增以下設定： 123456789101112@Component({ selector: 'app-address-info', templateUrl: './address-info.component.html', styleUrls: ['./address-info.component.scss'], viewProviders:[ { provide: ControlContainer, useExisting: NgForm } ]})export class AddressInfoComponent { 這樣就能直接用 &lt;app-address-info&gt;&lt;/app-address-info&gt; 的方式使用這個元件了。 大家覺得，是 Reactive Forms 的方式好用，還是 Template Driven Forms 的方式好用呢？ 本日小結今天的重點主要是讓大家知道要怎麼使用 ControlContainer 這個類別來包裝我們的元件，以達到提昇重用性與維護性的目的。 雖然麻煩的是，它沒辦法像昨天分享的 ControlValueAccessor 一樣，做好了之後可以適用於 Template Driven Forms 與 Reactive Forms ，但好在它的用法其實頗為簡單，主要的差異就只有在 Template Driven Forms 需要靠 viewProvider ，而 Reactive Froms 只要注入就行。 關於 viewProvider 與 provider 的差異，我推薦大家可以去看 Kevin （台灣 Angular GDE）的 [Angular] viewProviders V.S. providers ，我覺得寫得非常的清楚。 此外，如果覺得我分享不好，也可以參考 Kevin 的 [Angular] ControlContainer 的應用 今天的程式碼會放在 Github - Branch: day29 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，還請麻煩留言給我讓我知道！","link":"/2021/10/14/angular-30days-form-and-test-29/"},{"title":"Angular 深入淺出三十天：表單與測試 Day28 - 自訂表單元件","text":"經過了這段時間的練習與學習，相信大家應該越來越能體會 Angular 表單的強大與便利。 不過既然 Angular 表單這麼好用，如果能讓自己做的 Component 也像 Angular 表單那樣一般使用該有多好？ 因此，今天想要跟大家分享的是 ─ 如何自訂表單元件。 應用場景大家跟我一起想像一下，假設我們今天需要做一個管理平台，在這個管理平台裡，會有很多地方都會需要用到我們昨天做的 DateRangeComponent ，但不一定會是在同一個表單裡，只是剛好也需要 startDate 與 endDate 這兩個欄位，而且畫面與欄位驗證的規則也都是一樣。 例如： A 頁面是一個查詢訂單系統， B 頁面是查詢會員系統，雖然這兩個頁面的查詢條件可能都不太一樣，但恰好都可以根據起迄日來查詢相應的資料。 這時，我們很有可能就會將我們做好的 DateRangeComponent 做成表單元件，讓 A 跟 B 在使用它的時候，就像使用一般的表單元件一樣輕鬆、自然。 那究竟要怎麼做呢？ ControlValueAccessor首先要介紹給大家認識的是 ControlValueAccessor ，它是個 Interface ，而它定義了以下四個函式： 123456interface ControlValueAccessor { writeValue(obj: any): void registerOnChange(fn: any): void registerOnTouched(fn: any): void setDisabledState(isDisabled: boolean)?: void} writeValue(obj: any): void ─ 表單控件想要將值寫入時，會呼叫此函式 registerOnChange(fn: any): void ─ 表單控件初始化時會呼叫此函式，並傳入一個回呼函式，讓實作此介面的類別在其值有變動時，使用該回呼函式並傳入欲變動的值 registerOnTouched(fn: any): void ─ 表單控件初始化時會呼叫此函式，並傳入一個回呼函式，讓實作此介面的類別在失去焦點時，使用該回呼函式以通知表單控件 setDisabledState(isDisabled: boolean)?: void ─ 當表單控件的狀態變成 DISABLED 抑或是從 DISABLED 改變成其他狀態時，會呼叫此函式以通知實作此介面的類別 雖然我覺得我說的滿清楚的，但大家應該還是覺得很模糊，對吧？ 不要緊，我只是先讓大家有個印象，待會實作時大家就會更加理解了。 實作開始首先，我們需要另一個 Component 來用我們昨天做好的 DateRangeComponent ，像這樣： 123&lt;form *ngIf=\"formGroup\" [formGroup]=\"formGroup\"&gt; &lt;app-date-range formControlName=\"dateRange\"&gt;&lt;/app-date-range&gt;&lt;/form&gt; 然後在 Component 的 .ts 裡準備好 FormGroup ，像這樣： 1234567891011export class ReactiveFormsDateRangeComponent implements OnInit { formGroup: FormGroup | undefined; constructor(private formBuilder: FormBuilder) { } ngOnInit(): void { this.formGroup = this.formBuilder.group({ dateRange: '' }); }} 接著打開昨天做的 DateRangeComponent ，並在 implements 的後方加上 ControlValueAccessor ，像這樣： 123export class DateRangeComponent implements OnInit, ControlValueAccessor { // ...} 這時你應該會發現 DateRangeComponent 出現了一條紅色毛毛蟲，當你把滑鼠游標移到上面的時候，它說： 這是因為我們為 DateRangeComponent 加上實作 ControlValueAccessor 的宣告後，編輯器提醒我們要記得實作 ControlValueAccessor 的四個函式，才符合該介面的定義。 這就像是我們如果想要 Cosplay 鋼鐵人，但我什麼盔甲都沒穿就說自己是鋼鐵人，別人只會覺得滿臉問號。 但只要我們戴上了頭盔，別人就會知道你在扮演鋼鐵人。 所以我們就在 DateRangeComponent 裡加上以下四個函式： 1234567891011121314151617181920export class DateRangeComponent implements OnInit, ControlValueAccessor { // ... writeValue(obj: any): void { console.log('writeValue', obj); } registerOnChange(fn: any): void { console.log('registerOnChange', fn); } registerOnTouched(fn: any): void { console.log('registerOnTouched', fn); } setDisabledState(isDisabled: boolean): void { console.log('setDisabledState', isDisabled); }} 接下來，我們需要在 DateRangeComponent 的 MetaData 裡的 providers 裡加入一些設定，像這樣： 123456789101112131415@Component({ selector: 'app-date-range', templateUrl: './date-range.component.html', styleUrls: ['./date-range.component.scss'], providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; DateRangeComponent), multi: true } ]})export class DateRangeComponent implements OnInit, ControlValueAccessor { // ...} 我們之前其實也曾經在第二十五天的文章 ─ 測試進階技巧 - DI 抽換裡用過類似的技巧。 簡單來說，這個設定是為了讓表單可以透過 NG_VALUE_ACCESSOR 這個 InjectionToken 取得我們這個實作了 ControlValueAccessor 介面的 DateRangeComponent 實體。 想知道什麼是 InjectionToken 的朋友，可以參考 Mike 的 [Angular 大師之路] Day 23 - 認識 InjectionToken 。 想知道 useExisting 跟 useValue 、 useClass 與 useFactory 有哪裡不一樣的，也可以參考 Mike 的 [Angular 大師之路] Day 20 - 在 @NgModule 的 providers: [] 自由更換注入內容 (1) 與 [Angular 大師之路] Day 21 - 在 @NgModule 的 providers: [] 自由更換注入內容 (2) 。 而 forwardRef() 的部份，我覺得官網的 Dependency injection in action - Break circularities with a forward class reference 講得比較清楚。 最後的 multi: true ，可以參考林穎平 EP 的 [Day 8] 所以我說那個 multi 是？ ，如果想要更深入的了解其原理，他也寫了一篇 [Day 10] 深度看一下 Angular 建立 multi provider 的機制（真的很深入） 至此，我們就可以儲存檔案來看一下初始化完後會印出的 Log ： 接著我們在使用 DateRangeComponent 的 Component 裡加上以下程式碼以觀察其運作結果： 12345678910ngOnInit(): void { this.formGroup = this.formBuilder.group({ dateRange: '' }); setTimeout(() =&gt; { console.log('---- 3秒後 ----'); this.formGroup?.setValue({ dateRange: 'Leo' }); this.formGroup?.disable(); }, 3000);} 然後我們會發現： 這樣大家有比較了解一開始關於 ControlValueAccessor 各函式的說明了嗎？ 如果用圖示的話，現在的結構大概像這樣： 如果我們設值給 FormControl 時，則會觸發 ControlValueAccessor 的函式 writeValue ： 如果我們 disable 或 enable 了該 FormControl ，則會觸發 ControlValueAccessor 的函式 setDisabledState ： 而如果使用者改動了自訂的表單元件的值，則我們自訂的表單元件應該要呼叫透過初始化時所觸發的 registerOnChange 所傳入的 fn 去通知 FormControl： 讀萬卷書不如行萬里路。接下來，我們把剩下的實作做完就會更了解這其中的運作流程了！ 首先，先加工一下使用 DateRangeComponent 的 Component ： 12345678910111213141516171819202122export class ReactiveFormsDateRangeComponent implements OnInit { formGroup: FormGroup | undefined; constructor(private formBuilder: FormBuilder) { } ngOnInit(): void { const date = new Date(); this.formGroup = this.formBuilder.group({ dateRange: `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}` }); } enable(): void { this.formGroup?.enable(); } disable(): void { this.formGroup?.disable(); }} Template 的部份也加工一下： 12345678&lt;form *ngIf=\"formGroup\" [formGroup]=\"formGroup\"&gt; &lt;app-date-range formControlName=\"dateRange\"&gt;&lt;/app-date-range&gt; &lt;p&gt; &lt;button type=\"button\" [disabled]=\"formGroup.disabled\" (click)=\"disable()\"&gt;DISABLE&lt;/button&gt; &lt;button type=\"button\" [disabled]=\"formGroup.enabled\" (click)=\"enable()\"&gt;ENABLE&lt;/button&gt; &lt;/p&gt;&lt;/form&gt;&lt;pre&gt;{{ formGroup?.getRawValue() | json }}&lt;/pre&gt; 然後把 DateRangeComponent 改成這樣： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152export class DateRangeComponent implements OnInit, ControlValueAccessor { formGroup: FormGroup | undefined; fnFormRegisterOnChange: ((dateString: string) =&gt; void) | undefined; fnFormRegisterOnTouched: (() =&gt; void) | undefined; constructor(private formBuilder: FormBuilder) { } ngOnInit(): void { this.formGroup = this.formBuilder.group({ startDate: ['', [Validators.required, Validators.pattern(/^\\d{4}-\\d{2}-\\d{2}$/)]], endDate: ['', Validators.pattern(/^\\d{4}-\\d{2}-\\d{2}$/)] }, { validators: dateRangeValidator }); this.formGroup.valueChanges.subscribe(({ startDate, endDate }) =&gt; { let dateString = startDate; if (endDate) { dateString += `, ${endDate}`; } if (this.formGroup?.errors) { dateString = ''; } if (this.fnFormRegisterOnChange) { this.fnFormRegisterOnChange(dateString); } }); } writeValue(dateRangeString: string): void { const [startDate, endDate] = dateRangeString.split(', '); this.formGroup?.patchValue({ startDate, endDate }, { emitEvent: false }); } registerOnChange(fn: (dateRangeString: string) =&gt; void): void { this.fnFormRegisterOnChange = fn; } registerOnTouched(fn: () =&gt; void): void { this.fnFormRegisterOnTouched = fn; } setDisabledState(isDisabled: boolean): void { if (isDisabled) { this.formGroup?.disable(); } else { this.formGroup?.enable(); } }} 結果： 對了，這樣的作法不僅僅只適用於 Reactive Forms 噢！大家可以在使用 DateRangeComponent 的時候用 Template Driven Forms 的方式試試看，也是行得通的唷！ 本日小結今天的實作練習應該滿好玩的吧？ 我能理解大家第一次碰到的時候都會比較難以理解，記得我第一次碰到的時候，也只是複製人家的程式碼然後貼上而已，根本就不是了解其運作原理。 因此，希望我今天的文章能讓大家可以不僅僅只是複製貼上，而是對於其流程與原理有所掌握與理解。 今天的程式碼會放在 Github - Branch: day28 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，還請麻煩留言給我讓我知道！","link":"/2021/10/13/angular-30days-form-and-test-28/"},{"title":"Angular v12 來了！！","text":"今天一早準備工作時，看到令人興奮的好消息！那就是 ─ Angular v12 已經正式 Release 了！！ 官方文章在此：Angular v12 is now available 幫看到英文就倒退三百步的朋友總結一下幾個重點： Ivy Everywhere為了更靠近 Ivy Everywhere 這個目標， Angular 棄用了舊的 Compiler - View Engine ，不過這對於一般開發者來說沒什麼影響，主要是如果你是身為 Library 的作者且是使用 View Engine 來 Compile 的話，可以開始著手準備使用 Ivy 來 Compile 了。 為此，官方有提供實作細節。 Protractor 的未來關於 Angular 生態圈所標配的 E2E 測試框架 ─ Protractor 的未來，目前官方決定將從 v12 開始不再預設包含 Protractor ，而是與其他夥伴合作（目前官方已收到的夥伴回音有 Cypress 、 TestCafe 與 WebdriverIO 。如果你們公司也有在做這塊且有興趣，可以跟官方團隊聯繫），並透過 Angular CLI 的 schematic/builder 與 Angular 緊密結合。 官方堅信，透過與其他夥伴的合作以及擁抱社群的力量，可以使 Angular 變得更加強大！對於細節有興趣的朋友可以閱讀官方的RFC（請求意見稿）。 Nullish 操作符從 v12 開始，開發者們可以在 Angular 的 Template 裡使用 Nullish 操作符 ─ ??（沒錯，就是很香很甜的語法糖）了！ 透過使用 Nullish 操作符，可以讓你的 code 看起來更加 Clean （雖然每個人、每個團隊對於 Clean Code 的定義都不一樣，但官方是這麼認為，我也是）。 舉個例子： 1{{ age !== null &amp;&amp; age !== undefined ? age : calculateAge() }} 使用 Nullish 操作符後，你的 code 像這樣： 1{{ age ?? calculateAge() }} 謎之聲：耶！令人舒爽的程式碼！ 樣式相關的改進關於樣式方面，從 v12 開始，只要在 angular.json 裡加上 inlineStyleLanguage: &quot;scss&quot; 的設定，就可以在 Component 的 styles 裡寫 SCSS 了，雖然關於這點我其實覺得還好，因為我個人不喜歡將 Template 或是樣式直接寫在 *.component.ts 裡。 不過令人興奮的是， Angular CDK 與 Angular Material 現在內部已經改使用 Sass 新的 Module System 了！與此同時， Angular CDK 與 Angular Material 所外露的 API 介面也已經改採用 @use 語法，官方文件 也已經同步更新（尷尬，破版了XDD）。 不過如果你的應用程式是建立在 Angular v12 以下，但有使用到新版的 Angular CDK 或是 Angular Material 的話，可以使用 ng update 的指令讓 Angular CLI 幫你自動更新所有使用於 Angular CDK 與 Angular Material 的 @import 聲明（Before and After），並記得將你的 NPM 套件從 node-sass 改為 sass ， node-sass 已經沒有持續更新且維護了（如果你是使用 Angular v12 則不用做此行為，內建已經是 sass 了）。 編譯模式預設為 Production 模式v12 之後， ng build 指令將會預設為 Production 模式，意即開發者們不用再加上 --prod 來強調要編譯 Production 模式的檔案，減少多餘的步驟並防止將開發模式的程式碼誤植到 Production 上的意外發生。 預設開啟嚴格模式v12 之後，將預設開啟 TypeScript 的嚴格模式，嚴格模式會幫助開發者們儘早發現錯誤。 關於嚴格模式可以閱讀 Angular 官方文件與 Angular 官方部落格的文章。 Angular Language Service 預設為 Ivy-basedv12 之後，將原先 Angular Language Service 可以選擇性使用 Ivy-based 改為預設使用。 官方還有提供了一部影片 是關於Angular Language Service with Ivy 的，有興趣的朋友也可以看看。 使用 Webpack 5從 v11 開始， Angular 其實就有實驗性地在支援 Webpack 5 ；但從 v12 開始，就正式支援啦！！！（灑花） TypeScript v4.2v12 預設所採用的 TypeScript 是 v4.2 ，關於 v4.2 的細節可以閱讀官方的文章。 棄用對 IE 11 的支援從 v12 開始，官方將棄用對於 IE 11 的支援，並預計將在 v13 時正式將其移除。關於此決定可以觀看 官方的 RFC（請求意見稿）。 其他更新其實其他還有一些滿重要的更新與調整，不過上述幾點是我個人擷取出來，覺得對一般開發者來說比較重要且有感的更新，所以關於其他的更新，可以直接閱讀官方的文章，抑或是直接看官方的 CHANGELOG。 以上，就是今天李歐想要分享給大家的資訊，感謝您的收看！ 如果您喜歡我的文章，歡迎按讚、訂閱以及分享，我們下次見囉，拜拜～！（好 Youtuber 式的結尾XD）","link":"/2021/05/13/angular-v12-is-available-now/"},{"title":"Angular 深入淺出三十天：表單與測試 Day27 - Reactive Forms 進階技巧 - 跨欄位驗證","text":"今天想要跟大家分享的是跨欄位驗證的小技巧，這個小技巧其實沒有多厲害或多特別，只是可能滿多人剛好不知道原來可以這樣用。 而我們在 Day 23 - Reactive Forms 進階技巧 - 欄位連動檢核邏輯 所分享過欄位連動檢核邏輯的部份，就某方面來說，其實也可以使用這種方式來做，但究竟要適不適合、要不要使用，我覺得一切都還是要看需求、看想給使用者什麼樣的使用體驗來決定。 畢竟系統是為了服務需求而存在，至於能不能做到、能不能解決問題就看工程師的功力囉。 實作開始言歸正傳，我們今天要做的功能是起迄日的日期欄位檢核 感謝我的朋友 ─ Joseph 所提供的案例讓我多活了一天。 規格需求詳細規格需求如下： 起日 必填，驗證有誤時需顯示錯誤訊息： 此欄位必填 格式需為 yyyy-MM-dd ，驗證有誤時需顯示錯誤訊息： 日期格式不正確 需為確切存在的日期，驗證有誤時需顯示錯誤訊息： 此日期不存在 迄日 非必填 格式需為 yyyy-MM-dd ，驗證有誤時需顯示錯誤訊息： 日期格式不正確 需為確切存在的日期，驗證有誤時需顯示錯誤訊息： 此日期不存在 迄日不可早於起日，驗證有誤時需顯示錯誤訊息： 迄日不可早於起日 迄日不可晚於起日超過七天，驗證有誤時需顯示錯誤訊息： 迄日不可晚於起日超過七天 以上驗證皆需在使用者輸入時動態檢查 準備畫面接下來我們先把畫面準備好， HTML 如下： 12345678910&lt;form&gt; &lt;p&gt; &lt;label for=\"start-date\"&gt;起日：&lt;/label&gt; &lt;input type=\"text\" id=\"start-date\" placeholder=\"yyyy-mm-dd\"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"end-date\"&gt;迄日：&lt;/label&gt; &lt;input type=\"text\" id=\"end-date\" placeholder=\"yyyy-mm-dd\"&gt; &lt;/p&gt;&lt;/form&gt; 畫面應該會長這樣： 我知道一般大家在實作的時候會用漂亮的 UI 套件，不過我們現在主要聚焦在功能面，所以欄位的部份我只用簡單的 &lt;input type=&quot;text&quot;&gt; 的方式實作。 其實我本來想至少用 &lt;input type=&quot;date&quot;&gt; 來實作的，但它會害我們無法判斷使用者到底有沒有輸入值，所以最後還是放棄了使用它的打算。 準備 FormGroup接著把 Reactive Forms 的 FormGroup 也準備好： 12345678910111213141516171819export class ReactiveFormsDateRangeComponent implements OnInit { formGroup: FormGroup | undefined; constructor(private formBuilder: FormBuilder) { } ngOnInit(): void { this.formGroup = this.formBuilder.group({ startDate: [ '', [ Validators.required, Validators.pattern(/^\\d{4}-\\d{2}-\\d{2}$/) ] ], endDate: ['', Validators.pattern(/^\\d{4}-\\d{2}-\\d{2}$/)] }); }} 其實這邊的 Validators.required 與 Validators.pattern(/^\\d{4}-\\d{2}-\\d{2}$/) 可以不加，只不過後續就要把判斷寫在另一個地方，看大家想要稍稍彈性一點，還是直接寫死在另外一個地方都可以。 然後綁定到 Template 的表單上： 12345678910&lt;form *ngIf=\"formGroup\" [formGroup]=\"formGroup\"&gt; &lt;p&gt; &lt;label for=\"start-date\"&gt;起日：&lt;/label&gt; &lt;input type=\"text\" id=\"start-date\" placeholder=\"yyyy-mm-dd\" formControlName=\"startDate\"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"end-date\"&gt;迄日：&lt;/label&gt; &lt;input type=\"text\" id=\"end-date\" placeholder=\"yyyy-mm-dd\" formControlName=\"endDate\"&gt; &lt;/p&gt;&lt;/form&gt; 再次提醒大家，在使用 Reactive Forms 的方式來開發表單時，請記得到 .module.ts 裡的引入 FormsModule 與 ReactiveFormsModule 大家不要覺得我像老頭子一樣囉哩囉嗦的，都已經做了幾次的練習了還要一直提醒大家記得引入 FormsModule 和 ReactiveFormsModule 。 相信我，如果我沒提醒，一定會有很多還不是很熟悉的朋友會卡住。 所以大家互相體諒包容一下，熟悉的朋友快速略過就好。 自訂驗證器 ─ dateRangeValidator接著我們來用昨天分享過的自訂驗證器的的技巧來自訂一個名為 dateRangeValidator 的驗證器，程式碼如下： 1234export const dateRangeValidator: ValidatorFn = (formGroup) =&gt; { console.log(formGroup.value); return null}; 先把它掛在 FormGroup 上： 123456789this.formGroup = this.formBuilder.group({ startDate: [ '', [ Validators.required, Validators.pattern(/^\\d{4}-\\d{2}-\\d{2}$/) ] ], endDate: ['', Validators.pattern(/^\\d{4}-\\d{2}-\\d{2}$/)]}, { validators: dateRangeValidator }); 然後我們就可以在控制台裡看到 ─ 當 FormGroup 裡的欄位的值有變動時，就會觸發我們自訂的驗證器： 一開始的四個 { startDate: '', endDate: '' } 是 FormGroup 在初始化的時後所觸發的。 其實今天要做的這個功能最關鍵、最重要的兩件事情就是： 實作自訂驗證器 把它掛在 FormGroup 上 所以我們已經做完了，今天的文章就分享到這邊。 謎之音：喂！你給我回來！（抓回） 接下來在實作驗證器之前，我想先制定該驗證器在驗證有誤時，所要回傳的 ValidationErrors 格式。 制定驗證器的 ValidationErrors之所以想要先制定 ValidationErrors 的格式，一方面是因為待會實作驗證邏輯的時候需要用到；另一方面則是因為這個格式如果訂得好，後續實作時會輕鬆許多。 我的預期是這樣： 123456{ dateRange: { startDate: null | ValidationErrors; endDate: null | ValidationErrors; }} 這樣制定的意思是，如果起日欄位沒有錯誤，則 dateRange.startDate 的值會是 null ；而如果迄日欄位沒有錯誤，則 dateRange.endDate 的值會是 null ；又如果兩個欄位都沒錯誤，則該驗證器就會直接回傳 null 。 反之，如果起日欄位有錯誤，則 dateRange.startDate 的值會是我們接下來要制定的錯誤；迄日欄位亦然。 如此一來，如果驗證有誤時，我們比較能夠從驗證器所回傳的 ValidationErrors 來解析是哪個欄位有誤。 而 dateRange.startDate 與 dateRange.endDate 究竟會有哪些錯誤呢？ 先複習一下規格： 起日 必填，驗證有誤時需顯示錯誤訊息： 此欄位必填 格式需為 yyyy-MM-dd ，驗證有誤時需顯示錯誤訊息： 日期格式不正確 需為確切存在的日期，驗證有誤時需顯示錯誤訊息： 此日期不存在 迄日 非必填 格式需為 yyyy-MM-dd ，驗證有誤時需顯示錯誤訊息： 日期格式不正確 需為確切存在的日期，驗證有誤時需顯示錯誤訊息： 此日期不存在 迄日不可早於起日，驗證有誤時需顯示錯誤訊息： 迄日不可早於起日 迄日不可晚於起日超過七天，驗證有誤時需顯示錯誤訊息： 迄日不可晚於起日超過七天 除了必填與日期格式的部份已經用官方提供的 Validator 外，其他的錯誤應該就剩下： 不存在的日期： 123{ inexistentDate: true} 迄日早於起日： 123{ lessThanStartDate: true;} 迄日晚於起日七天 123456{ greaterThanStartDate: { actualGreater: 8 requiredGreater: 7 }} 以上格式是我自訂的，大家可以不用跟我一樣沒關係。 接著我們可以把錯誤訊息稍微訂個 type ，以便後續使用： 12345678910111213141516171819202122232425262728293031323334353637383940export type DateRangeValidationErrors = { dateRange: { startDate: null | DateErrors; endDate: null | DateErrors; }};export type DateErrors = | RequiredError | PatternError | InexistentDateError | LessThanStartDateError | GreaterThanStartDateError | ValidationErrors;export type RequiredError = { required: true;};export type PatternError = { pattern: { actualValue: string; requiredPattern: string; }};export type InexistentDateError = { inexistentDate: true;};export type LessThanStartDateError = { lessThanStartDate: true;};export type GreaterThanStartDateError = { greaterThanStartDate: { actualGreater: number; requiredGreater: number; }}; 如此一來，我們差不多就可以開始來寫驗證器的邏輯囉！ 實作驗證器的邏輯首先，我們先處理判斷使用者所輸入的日期是否真實存在的邏輯。 舉例來說，大家覺得 2021-02-29 這個日期是存在的嗎？大家應該翻一下年曆就會知道，今年不是閏年，所以二月不會有第二十九天。 但是如果單純用 Date 來判斷，它其實可以算得出來： 12console.log(new Date('2021-02-29'));// Mon Mar 01 2021 08:00:00 GMT+0800 (Taipei Standard Time) 那 2021-02-31 呢？ 12console.log(new Date('2021-02-31'));// Mon Mar 03 2021 08:00:00 GMT+0800 (Taipei Standard Time) 為什麼會這樣呢？ 以上述例子來說， 用字串來建立 Date 的時候，它只會幫我們驗證兩件事情： 月份不可以超過 12 日期不可以超過 31 只要合乎上述這兩件事情，它就不會是 Invalid Date 。 那年份呢？我很無聊的幫大家試了一下，可以到 275759 年唷！ 為了處理這件事情，我很偷懶的 Google 了一下大家的解法，最後借用了 Summer。桑莫。夏天的 JavaScript：檢查日期是否存在文中的程式碼，並且稍稍調整了一下以符合我的需求： 12345678910111213141516171819export const isDateExist = (dateString: string) =&gt; { const dateObj = dateString.split('-'); // yyyy-mm-dd //列出12個月，每月最大日期限制 const limitInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; const theYear = parseInt(dateObj[0]); const theMonth = parseInt(dateObj[1]); const theDay = parseInt(dateObj[2]); const isLeap = new Date(theYear, 2, 0).getDate() === 29; // 是否為閏年? if (isLeap) { // 若為閏年，最大日期限制改為 29 limitInMonth[1] = 29; } // 月份不可以大於 12， 並比對該日是否超過每個月份最大日期限制 return theMonth &lt; 12 &amp;&amp; theDay &lt;= limitInMonth[theMonth - 1];} 感謝每一個願意分享的朋友。 準備萬全之後，再來就是把驗證器的判斷邏輯補完： 123456789101112131415161718192021222324252627282930313233343536373839404142434445export const dateRangeValidator: ValidatorFn = (formGroup) =&gt; { const startDateControl = formGroup.get('startDate')!; const endDateControl = formGroup.get('endDate')!; let errors: DateRangeValidationErrors = { dateRange: { startDate: null, endDate: null, } }; if (startDateControl.errors) { errors.dateRange.startDate = startDateControl.errors; } else if (!isDateExist(startDateControl.value)) { errors.dateRange.startDate = { inexistentDate: true }; } if (endDateControl.errors) { errors.dateRange.endDate = endDateControl.errors; } else if (endDateControl.value) { if (!isDateExist(endDateControl.value)) { errors.dateRange.endDate = { inexistentDate: true }; } else if (!errors.dateRange.startDate) { const startDateTimeStamp = new Date(startDateControl.value).getTime(); const endDateTimeStamp = new Date(endDateControl.value).getTime(); const dayInMilliseconds = 24 * 60 * 60 * 1000; const duration = 7 * dayInMilliseconds; if (endDateTimeStamp &lt; startDateTimeStamp) { errors.dateRange.endDate = { lessThanStartDate: true }; } else if (endDateTimeStamp - duration &gt; startDateTimeStamp) { errors.dateRange.endDate = { greaterThanStartDate: { actualGreater: (endDateTimeStamp - startDateTimeStamp) / dayInMilliseconds, requiredGreater: 7 } } } } } if (!errors.dateRange.startDate &amp;&amp; !errors.dateRange.endDate) { return null; } return errors;}; 結果： 看起來效果不錯，接下來就是把錯誤訊息接上囉！ ErrorMessagePipe關於錯誤訊息的部份，今天就不把邏輯寫到 Component 的 .ts 裡了，來做個 ErrorMessagePipe 吧！ 程式碼如下： 123456789101112131415161718192021@Pipe({ name: 'errorMessage',})export class ErrorMessagePipe implements PipeTransform { transform(errors: null | DateErrors, ...args: unknown[]): string { if (errors) { if ((errors as RequiredError).required) { return '此欄位必填'; } else if ((errors as PatternError).pattern) { return '日期格式不正確'; } else if ((errors as InexistentDateError).inexistentDate) { return '此日期不存在'; } else if ((errors as LessThanStartDateError).lessThanStartDate) { return '迄日不可早於起日'; } else if ((errors as GreaterThanStartDateError).greaterThanStartDate) { return '迄日不可晚於起日超過七天'; } } return ''; }} 接著再到 Template 將其接上： 123456789101112131415161718192021222324252627282930313233&lt;h1&gt;Reactive Forms 進階技巧 ─ 跨欄位驗證&lt;/h1&gt;&lt;form *ngIf=\"formGroup\" [formGroup]=\"formGroup\"&gt; &lt;p&gt; &lt;label for=\"start-date\"&gt;起日：&lt;/label&gt; &lt;input type=\"text\" id=\"start-date\" placeholder=\"yyyy-mm-dd\" formControlName=\"startDate\" /&gt; &lt;span class=\"error-message\" *ngIf=\"formGroup.errors &amp;&amp; formGroup.dirty\" &gt; {{ formGroup.errors.dateRange.startDate | errorMessage }} &lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"end-date\"&gt;迄日：&lt;/label&gt; &lt;input type=\"text\" id=\"end-date\" placeholder=\"yyyy-mm-dd\" formControlName=\"endDate\" /&gt; &lt;span class=\"error-message\" *ngIf=\"formGroup.errors &amp;&amp; formGroup.dirty\" &gt; {{ formGroup.errors.dateRange.endDate | errorMessage }} &lt;/span&gt; &lt;/p&gt;&lt;/form&gt; 最終成果： 本日小結今天主要想告訴大家的是 FormGroup 、 FormArray 以及 FormControl 其實都可以設定 Validator 與 AsyncValidator ，不管是在初始化時就設定還是初始化後再動態設定都沒問題。 但可能是因為沒有遇過需要用到的場景，所以滿多對 Reactive Forms 還不太熟的朋友還是會不知道。 雖說今天主要想讓大家的知道的是 FormGroup 上也可以設定 Validator 與 AsyncValidator ，但寫著寫著又不知不覺寫了很多東西，希望這些東西都有幫助到大家。 此外， Template Driven Forms 當然也是可以跨欄位驗證，不過由於之前已經說過不會再分享 Template Driven Forms 的關係，所以有興趣的朋友可以參考官方的 Form Validation - Adding cross-validation to template-driven forms 的文件。 早知道就不要說不再分享，害自己少了好多篇可以寫，失策！ 對了，測試大家可以練習寫寫看，我就不實作給大家看囉！ 今天的程式碼會放在 Github - Branch: day27 上供大家參考，建議大家在看我的實作之前，先按照需求規格自己做一遍，之後再跟我的對照，看看自己的實作跟我的實作不同的地方在哪裡、有什麼好處與壞處，如此反覆咀嚼消化後，我相信你一定可以進步地非常快！ 如果有任何的問題或是回饋，還請麻煩留言給我讓我知道！","link":"/2021/10/12/angular-30days-form-and-test-27/"},{"title":"Angular 深入淺出三十天：表單與測試 Day30 - 表單原理","text":"經過前面二十九天的的練習與學習，相信大家應該在表單的實作上都熟悉了不少，只要不是太複雜、太特別的表單應該也都難不倒你們。 今天是本系列文的最後一天，就讓我們來好好地深入了解一下 Angular 表單會這麼強大的原因吧！ 首先，我想趁大家記憶猶新時，先帶大家來看為什麼我們昨天可以用 ControlContainer 來自訂一個可以被 Template Driven Forms 或是 Reactive Forms 所使用的 Component 。 ControlContainer 上圖是我根據 Angular 的 Source Code 找出 ControlContainer 的關係所畫的（斜體表抽象類別）。 從圖中我們會發現， ControlContainer 其實只是一個抽象類別，並繼承了另一個抽象類別 AbstractControlDirective ，而 AbstractControlDirective 這個抽象類別其實也被另一個抽象類別 NgControl 所繼承。 NgControl 晚點會提到，此處暫不多做說明。 至於 ControlContainer ，它其實也被 AbstractFormGroupDirect 、 NgForm 、 FormGroupDirective 與 FormArrayName 這四個 Directive 所繼承；甚至 AbstractFormGroupDirect 還被 FormGroupName 與 NgModelGroup 這兩個 Directive 所繼承。 換句話說， Angular 根據 ControlContainer 為基底，做出了以下五個 Directive ： FormGroupDirective FormGroupName FormArrayName NgForm NgModelGroup 在這五個 Directive 裡，前面三個是為什麼我們在用 Reactive Forms 的方式來開發表單時，可以在 Template 裡用 [formGroup] 、 [formGroupName] 、 [formArrayName] 的方式將元素與 FormGroup 、 FormArray 綁定的原因。 大家應該都還記得我們是怎麼將 FormGroup 與 FormArray 綁定到元素上的吧？！ 而後面兩個則是為什麼我們在用 Template Driven Forms 的方式來開發表單時，可以在 Template 裡在元素上使用 #XXX=&quot;ngForm' 、 #XXX=&quot;ngModelGroup&quot; 之後，可以拿到 NgForm 與 NgModelGroup 的實體的原因。 雖然本系列文沒有特別提到 ngModelGroup 的用法，想知道的朋友可以參考官方的 NgModelGroup API 文件 那為什麼我們可以使用 ControlContainer 來自訂元件呢？ 其實這正是因為上述五個 Directive 都透過 ControlContainer 這個令牌，把自己註冊到 Angular 的 DI 系統裡，讓想使用它們的類別，可以很方便地透過 Angular 的 DI 系統來找到它們的實體。 像是在昨天的文章裡所分享的那樣（Reactive Forms 的方式）： 123export class AddressInfoComponent { constructor(private controlContainer: ControlContainer) { }} Template Driven Forms 則是透過 viewProvider 的方式，忘記的話請看昨天的文章。 NgControl 同樣地， Angular 也根據 NgControl 為基底，做出了以下三個 Directive ： FormControlName FormControlDirective NgModel 在這三個 Directive 裡，前面兩個是為什麼我們在用 Reactive Forms 的方式來開發表單時，可以在 Template 裡用 [formControl] 、 [formControlName] 的方式將元素與 FormControl 綁定的原因。 大家應該都還記得我們是怎麼將 FormControl 綁定到元素上的吧？！ 而最後一個則是為什麼我們在用 Template Driven Forms 的方式來開發表單時，會在 Template 裡在元素上使用 #XXX=&quot;ngModel' 之後，可以拿到 NgForm 與 NgModelGroup 的實體的原因。 不過，大家還記不記得我們在第二十八天的時候，是怎麼自訂表單元件的嗎？ 沒錯！就是 ControlValueAccessor 。 上述三個 Directive 實作時，也是透過 DI 拿到實作了 ControlValueAccessor 介面的實體，並在初始化的時候透過 ControlValueAccessor 這個介面，搭建 FormControl 與實作了它的實體之間的溝通管道。 想看原始碼的朋友可以點我看原始碼。 如果想知道 @Self 與 @Optional 裝飾器是幹嘛用的，可以參考這篇很前顯易懂的文章： @Self or @Optional @Host? The visual guide to Angular DI decorators. 但除了 ControlValueAccessor 之外，其實 Angular 還有其他內建的 ValueAccessor： 從上圖中我們可以發現，內建的 ValueAccessor 基本上都是繼承於 BaseControlValueAccessor 這個類別，然後分別被 DefaultValueAccessor 與 BuiltInControlValueAccessor 繼承，而只有 DefaultValueAccessor 有實作 ControlValueAccessor 這個介面。 然後 Angular 再基於 BuiltInControlValueAccessor 之上去建立了以下六個 ValueAccessor： NumberValueAccessor RangeValueAccessor RadioControlValueAccessor CheckboxControlValueAccessor SelectControlValueAccessor SelectMultipleControlValueAccessor 而這六個 ValueAccessor 對於我們的表單開發來說是至關重要的存在，沒有了它們，我們就沒辦法在這些元素上綁定我們的表單控制項。 但其實 BaseControlValueAccessor 與 BuiltInControlValueAccessor 本身並沒有什麼比較特別的實作或定義，之所以會有 DefaultValueAccessor 與 BuiltInControlValueAccessor 的區別，是為了在機制上，能夠做到一個優先權判斷的機制。 當我們在使用自訂的 ValueAccessor 時候， DefaultValueAccessor 或是上述六個 ValueAccessor 其實都有可能與我們自訂的 ValueAccessor 同時存在。 因此，在將我們的表單控制項與元素綁定的時候， Angular 會根據以下的優先權來抓取對應的 ValueAccessor ： CustomValueAccessor BuiltInValueAccessor DefaultValueAccessor 如此一來，只要我們沒有自訂 ValueAccessor ，預設就是會使用內建的 ValueAccessor 來搭建表單控制項與元素之間的溝通橋樑。 我覺得 Angular 的開發團隊真的很聰明！ 同步與非同步除了上述的東西之外，其實還有一個比較特別的點，就是關於同步更新與非同步更新的問題。 在 Day16 - Template Driven Forms vs Reactive Forms 的小結裡，我分享了一個表格，表格裡提到了 Template Driven Forms 的可預測性是非同步的。 而這件事情其實可以在 NgModel 的原始碼第 222 行 看出一點端倪。 原始碼第 222 行這行是指 NgModel 在初始化的時候，會去設置表單控制項。 而在原始碼第 268 行中可以看到，它會判斷該 NgModel 是不是 _isStandalone ，也就是它是不是單獨存在，還是有被 &lt;form&gt;&lt;/form&gt; 包住。 如果是單獨存在， NgModel 的行為其實會跟 FormControlDirective 與 FormControlName 一樣，因為他們會用一樣的方法設置表單控制項。 但如果不是單獨存在，它會用 NgForm 的 addControl 來設置表單控制項，這時，它就會是非同步的，因為他必須等到 resolvedPromise 發出 resolver 事件的時候，才會進行設置。 addControl 的實作在原始碼的第 187 行到 196 行 resolvedPromise 的定義則是在原始碼的第 27 行 我其實不太懂 Angular 為什麼要在 NgModel 被 &lt;form&gt;&lt;/form&gt; 包起來的時候這樣子做，因為 resolvedPromise 其實也沒什麼特別的地方，但它們就讓 NgForm 在 addControl 、 removeControl 、 addFormGroup 與 removeFormGroup 這四個方法要變成非同步的方式處理。 如果大家有興趣，或許找個時間研究一下，說不定，你就幫官方解決了一個問題呢！ 本日小結今天主要是幫本系列文做個結尾，希望能讓大家透過我的分享，更熟悉、更了解 Angular 一點。 也因為分享的關係，其實在撰寫本系列文的同時，我也得到了許多。 以前尚不熟悉的更熟悉了；以前不知道的知道了。 這或許就是所謂的「施比受更有福」吧？！ 未來，還會不會再寫鐵人賽還不曉得（目前是不想再寫了，哈哈！）。 但是，寫鐵人賽真的是一個非常好的學習機會。 透過撰寫文章，來疏理自己所學，仔細咀嚼後再回饋給社群、回饋給社會。 如果你還沒寫過鐵人賽，我衷心推薦你這一輩子一定至少要寫一次鐵人賽。 最後，我想感謝訂閱我的文章、閱讀我的文章、喜歡我的文章的你們，謝謝你們不嫌棄，也謝謝你們願意讓我能夠幫到你們。 我也想感謝我的家人們，寫鐵人賽的這段期間，真的是非常地疏於陪伴，謝謝他們的支持（雖然他們看不到）。 感謝大家的收看，我們有緣再見！ ：） 其他資源 Angular Taiwan 臉書社團 Angular Taiwan 討論區 Angular Taiwan 線上讀書會社團 Angular Taiwan Youtube 頻道","link":"/2021/10/15/angular-30days-form-and-test-30/"},{"title":"Angular 之 Injector 探討","text":"關於 Angular 的 Injector ，雖然我之前在寫「Angular 深入淺出三十天」的系列文時，就有在基礎結構說明（四）這篇文章裡介紹過，不過今天我在跟朋友們聊到相關的話題時，除了好好的做了個實驗，並把程式碼保留下來之外，也忽然起了個念頭，覺得是該把這個問題寫成文章，讓剛學 Angular 或是對 Angular 的了解沒那麼深的朋友們可以比較容易理解、比較不會用錯（就我個人的經驗來看，沒有注意到這個部分的朋友們還滿多的）。 問題描述在 Angular 裡寫 Service 的時候，我們一般會用以下三種方式註冊它： 在該 Service 的 @Injectable() 裡加上 { providedIn: 'root' } 的 Metadata （ Angular 7+ 推薦寫法），抑或者在 AppModule 的 providers 裡註冊它（ Angular 6- 的寫法）。 在相關的功能模組的 providers 裡註冊它。 在某個 Component 的 providers 裡註冊它。 其實在 Angular 9 之後的版本，除了 providedIn: 'root' 之外，還多了 'platform' 與 'any' 這兩個選擇，不過此篇文章不討論這個部分。 這三種註冊方式其中的第一種與第三種，大家比較不會有問題，比較會有問題的是第二種，很多人可能會覺得，我使用起來明明就是同一個實體呀？怎麼官方說是不同實體呢？ 實驗開始為了釐清這個問題，我做了個實驗，程式碼在這裡：https://stackblitz.com/edit/angular-ivy-5fdo5y?file=src/app/app.component.html 在這個實驗裡，我用了四個 Module ─ AboutModule、ContactModule、HomeModule、WhateverModule 與兩個 Service ─ ASservice 與 BService 來模擬大部分會遇到的情況： AService 使用 providedIn: 'root' 註冊。 HomeModule、ContactModule、WhateverModule 都 import 到 AppModule 裡。 AboutModule 用 LazyLoading 的方式載入。 BService 則分別註冊在 ContactModule、HomeModule、AboutModule 的 providers 裡與 WhateverComponent 的 providers 裡。 結果： 有看懂嗎？ BService 在 HomeComponent 與 ContactComponet 裡是用同一個實體，這是因為他們都有被 import 到 AppModule 裡，這時 AppModule（上層 Module）會接手 ContactModule、HomeModule（子層 Module）的 injector，所以他們雖然有分別註冊 BService ，但實際上還是共用了同一個實體。 這部份其實官網文件有寫到： 網址在這：https://angular.io/guide/hierarchical-dependency-injection#moduleinjector 不過我這裡只有實驗一層的情況，如果 Module 一層一層的接下去，是不是也是一樣的狀況我就沒有特別做實驗了，大家可以自己玩看看。 至於 AboutComponent 跟 WhateverComponent 呢，很明顯都是使用不同的 BService 的實體，前者因為使用 LazyLoading 的關係，跟 AppModule 沒有直接關聯，後者則是因為是使用了第三種註冊方式的關係。 結論總而言之，官方之所以提供了不同的註冊方式給我們，就是希望我們可以在不同的情況下使用不同的註冊方式來解決我們的問題，只要能夠熟知這其中的差異，就可以寫出好維護又高品質的系統囉！","link":"/2021/03/25/get-to-the-meet-of-angular-injector/"},{"title":"如何在 macOS 裡使用 Homebrew 來安裝與升級 Git","text":"在 macOS 裡，因 Git 是內建在系統當中的關係，所以在 macOS 裡使用 Git 非常方便，打開終端機就能使用了。 但可惜的是，隨著 Git 裡有著某些重大安全性問題被發現， Git 也隨之釋出新版本提供給大家更新， macOS 內建的 Git 版本就過於老舊了些。 我們可以在終端機中輸入以下指令來查看當前所使用的 Git 的版本： 12$ git versiongit version 2.15.1 (Apple Git-101) 所以後來許多人就推薦改為使用 Homebrew 來安裝與更新 Git ，方式可以參考以下連結： 如何以 Homebrew 取代 MacOS 內建 Git 並更新 不過隨著 macOS 的更新，系統的安全性也逐漸被 Apple 增加，所以筆者在使用 sudo mv /usr/bin/git /usr/bin/git-apple 這個指令時（ macOS 版本為： Catalina 10.15.1 ），遇到了第一個問題： operation not permitted 。 這時筆者 Google 到第一個解決方案： [Mac] iTerm2或Terminal在升級macOS Mojave之後使用指令時會出現”Operation not permitted” 不過這個方式在筆者的系統中沒有作用，依舊會遇到 operation not permitted 的問題。 而後筆者 Google 到第二個解決方案： Operation Not Permitted when on root - El Capitan (rootless disabled) 裡的綠勾勾回覆 筆者照做之後，再次使用 sudo mv /usr/bin/git /usr/bin/git-apple ，遇到了第二個問題： Read-only file system 。因此筆者又 Google 了一下，找到了以下解決方案： macOS 无法sudo创建文件夹返回Read-only file system问题解决 參照上述文章，筆者在終端機裡輸入以下指令： 1$ sudo mount -uw / 即可正常使用： 1$ sudo mv /usr/bin/git /usr/bin/git-apple 而後就能夠改為使用 Homebrew 安裝的 Git： 12$ git versiongit version 2.24.1 以上，希望有幫到大家。","link":"/2019/12/12/how-to-use-git-with-homebrew-in-macos/"},{"title":"我的 Nx 筆記 - 如何在你的 Application 裡，用很漂亮的方式引入 Library 的 SCSS","text":"最近在開始研究 Nx 這個非常好用的開發工具，當然也撞了不少牆…（鼻青臉腫中）。 今天主要要分享的是： 如何在你的 Application 裡，用很漂亮的方式引入 Library 裡的 SCSS 而這個方法是我在這個 issue 裡看到的，留言的人是 tcoz 。 在開始之前，請先準備 Nx 的專案，且裡面有一個 Application 名為 sample 、 一個 Library 名為 sample-lib ，然後在 sample-lib 裡準備一個 abc.scss 。 scss 的內容很簡單： 123h1 { color: red;} 接著把 sample 跑起來，應該會看到以下畫面： 然後先在 Nx 的 angular.json 裡，找到你的專案的 build 配置，大概長這樣： 1234567891011121314151617181920212223242526{ \"//\": \"...\", \"projects\": { \"sample\": { \"//\": \"...\", \"architect\": { \"build\": { \"builder\": \"@angular-devkit/build-angular:browser\", \"options\": { \"outputPath\": \"dist/apps/sample\", \"index\": \"apps/sample/src/index.html\", \"main\": \"apps/sample/src/main.ts\", \"polyfills\": \"apps/sample/src/polyfills.ts\", \"tsConfig\": \"apps/sample/tsconfig.app.json\", \"aot\": false, \"assets\": [\"apps/sample/src/favicon.ico\", \"apps/sample/src/assets\"], \"styles\": [\"apps/sample/src/styles.scss\"], \"scripts\": [] }, }, \"//\": \"...\", } } }, \"//\": \"...\",} 然後加上 stylePreprocessorOptions 跟 extractCss 的配置，像這樣： 12345678910111213141516171819202122232425{ \"//\": \"...\", \"projects\": { \"sample\": { \"//\": \"...\", \"architect\": { \"build\": { \"builder\": \"@angular-devkit/build-angular:browser\", \"options\": { \"//\": \"...\", \"stylePreprocessorOptions\": { \"includePaths\": [\"libs/sample-lib/src/lib/scss\"] }, \"extractCss\": true, \"//\": \"...\", }, }, \"//\": \"...\", } } }, \"//\": \"...\",} includePaths 裡的路徑就是要處理的 SCSS 的資料夾路徑\b。 如此一來，就可以到 sample 裡的 SCSS 裡 import （我在 sample 裡的 style.scss import ）： 1@import \"abc\"; 結果： 參考資料 Angular 官方文件","link":"/2019/10/24/my-nx-note-impot-scss-from-library/"},{"title":"寫文件的好處","text":"不知為何，絕大多數的工程師們都很討厭寫文件，雖然在我的職涯頭兩年，好像也的確沒碰過文件，但後來幸運地跟有撰寫文件習慣的團隊合作過之後，再跟沒文件習慣的團隊合作就意識到了文件的重要性，所以今天我想跟大家來分享我覺得寫文件有哪些好處。 一、白紙黑字，有憑有據首先，我覺得有文件的第一個好處就是吵架開會的時候比較有依據。 沒有文件的時候大家口說無憑，甚至你自己說的話過了三、五天，甚至一、兩週之後，你不一定記得自己之前講了什麼，最慘的是客戶或是主管很容易就不小心施放了隕石術，把之前講過的東西都直接推翻。 而有文件之後，就比較可以避免這種情況，當然文件上面最好標註了當前的版本、日期，以及改動了什麼內容等，這樣比較可以大聲說話會沒有爭議。 更甚者還有改完文件後逼大家都看過、沒問題之後簽下大名的作法，以後就比較沒辦法耍賴了。 二、利於溝通第二個好處我覺得是可以讓溝通更順暢、更有效率。 在沒有文件之前很容易各說各話、容易發散，明明是同一件事情但上週可能用 A 詞彙，但這週用 B 詞彙，因此產生誤會，白白浪費許多的時間。 而有文件之後，大家在溝通時可能就可以用文件上的標題或是編號來溝通，節省時間又不容易誤會。 此外，有個文件的名稱就叫做「詞彙表（_Glossary_）」，用來記錄公司對內或對外的各種縮寫專有名詞。 三、便於傳承第三個好處是我覺得最重要的好處－傳承。 在沒有文件的時候，只要當時做專案或產品的那些人一旦都已經離職，該專案或產品一旦出了什麼問題，後續維護非常不便。 對工程師來說，該專案或產品的程式碼就會變成所謂的 Legacy code ，沒人知道當初為什麼程式碼要這樣寫，不知道如何下手或是這個改動會不會把其他功能改壞；對 Manager 來說，一旦老闆或客戶來詢問當時為什麼會這樣設計、需求為什麼這樣開的時候，也沒有人可以回答的出來，進而導致老闆或客戶的不信任。 還有另外一種狀況是當有新進同仁時，該同仁需要花一、兩個禮拜的時間去爬 code 、邊使用邊對照，甚至還要拉著老人問這個問那個之後才能夠對於該產品或專案有比較基礎的認知，勞民傷財。 而有了文件之後，有新進同仁就把文件丟給他看，花個兩三天就可以讀完；舊專案需要維護，找一下文件就知道要怎麼改；而老闆或客戶有問題也能夠迅速的從文件中找到資訊回覆，皆大歡喜！ 總結寫文件有三大好處： 白紙黑字，有憑有據 利於溝通 便於傳承 基於上述這三大好處，我覺得寫文件是很必要的事情，一旦有了文件，做事情都高效了起來。 至於要怎麼寫文件、要寫什麼文件、誰要負責寫文件這些事情，我們下次再聊囉！","link":"/2022/12/11/benefit-if-writgin-document/"},{"title":"JavaScript 小技巧：數字字串補零時超好用的原生方法 - padStart","text":"今天我想跟大家分享一個數字字串補零時超好用的原生方法： padStart; 當然所謂的「數字字串補零時超好用的原生方法」這件事情是我自己覺得最適合用它的應用場景，而如果你有想到更適合的應用場景也拜託請跟我分享！！ 假設我們今天收到需求是不管是 0~999 之間的任何一個數字，都要以三位數的形式顯示給使用者看。例如： 如果資料是 9 的話，要顯示 009 如果資料是 99 ，要顯示 099 如果是 999 ，就顯示 999。 所以，以前的我們大概會這樣寫： 123456789// 隨機產生一個 0~999 的數字const randomNum = Number((Math.random() * 1000).toFixed());let numString = `${randomNum}`;if (randomNum &lt; 10) { numString = `00${randomNum}`;} else if (randomNum &lt; 100) { numString = `0${randomNum}`;} 如果今天需求是需要一個超長的位數的話，那就會有很多個 if/else ，看起來是不是很笨？！是不是很醜？！ 但有了 padStart 之後，我們只要這樣寫： 1const num = (Math.random() * 1000).toFixed().padStart(3, \"0\"); 一行就解決了，是不是超讚的？！！！ 不管需求要幾位數，都只要改那個 3 就好，而如果不想補 &quot;0&quot; ，想補 &quot;*&quot; 也沒問題，把 &quot;0&quot; 改成 &quot;*&quot; 就好，方便的不得了！！ 而這個方法在各大瀏覽器的支援程度高達 95.72% ，所以各位可以放心使用！！ 如果你還要支援 IE 的話就抱歉了XD 同場加映聰明的你一定會想，既然有 padStart ，那是不是也有 padEnd ？ 沒錯，其使用的方式一模一樣，只是改為在後面補上你想要補的字而已！！ 像是： 1234const name = 'Leo';const result = name.padEnd(5, \"a\");console.log(result); // 'Leoaa' 是不是非常簡單呢？！ 今天的 JavaScript 小技巧就到這邊囉，我們下次見，掰掰！ Reference Can I use - padStart MDN - padStart","link":"/2023/01/01/javascript-tips-helpful-natvie-method-padstart/"},{"title":"JavaScript 之那些年我們都腦補錯的事","text":"我有一個很尊敬的老師兼程式入門導師 ─ 馬老師，他曾經這樣跟我說過： 電腦很乖很聽話，你叫他往東他不會往西，如果它做錯了那一定你的錯！ 這句話我一直放在心上並引以為鑑，所以凡遇到錯誤我一定會先仔細檢查個兩三遍，因為用膝蓋想都知道一定是我的錯，哈哈！ 後來我在上另一位我同樣也很尊敬的老師兼人生導師 ─ 保哥的 JavaScript 核心教戰時，他曾經這樣跟我說： 我們在寫 JavaScript 的時候常常自己在腦補，但我們自己常常腦補錯。 所以我為什麼會寫這篇文呢？ 事情是這樣子的，今天我在 Angular Taiwan 社群時看到有人發文提問： 其實我個人覺得這是一個滿好的問題，怎麼說呢？ 因為這個問題其實是出在對於 JavaScript 執行機制的認知不夠深刻所造成的 「腦補補錯」 的問題。 而我個人其實有的時候也會犯這種錯誤，曾經我異想天開地想在前端做一個讓所有頁籤都能夠在同一個時間點（例如整點）才發出事件的功能，但最後就因為這個 JavaScript 的執行機制導致它一定會有誤差，這個誤差時間會隨著頁面的忙碌程度而有所不同，再加上實在是效能太差（因為每毫秒都要檢查一次），所以最終宣告失敗。 總之，藉著這個機會發文來分享 JavaScript 的執行機制給大家，已經知道的朋友們可以複習一下，而不知道的朋友們則從中可以學到新知識，希望大家都能夠從中獲得些什麼。 順帶一提，此文發佈前已徵得該群友的同意，讓我可以將他在群中提問的問題分享給大家。 不過他說他很期待我的文，希望他看到此文不會太過於失望，因為我只是單純的經驗分享，因為我覺得參考連結的影片已經講得非常詳細了 ^^” Reference 所以說 event loop 到底是什麼玩意兒？| Philip Roberts | JSConf EU","link":"/2022/09/28/javascript-runtime-mechanism-notice/"},{"title":"我的 Nx 筆記 - tsconfig.json 的坑","text":"我最近在研究 Nx 時遇到了一個坑，這個坑讓我卡了兩、三個小時，所以我將這件事情筆記下來，希望如果以後有人遇到類似的問題，這篇筆記多少可以幫得上忙。 問題描述在 Angular 專案裡我們經常會看到各種 tsconfig.json ，而這些 tsconfig.json 又繼承來繼承去的，雖然一般我們不會特別去動他們的設定，但當我們因為某些緣故需要去調整的時候，就要特別小心「覆蓋」的問題。 而我遇到的狀況是，我在使用 JSZip 這個套件時，遇到了下圖中的 Error ： 解決辦法是在 apps/app-name/tsconfig.app.json 的 compilerOptions 裡加上 path 的配置： 123456789101112{ \"//\": \"...\", \"compilerOptions\": { \"//\": \"...\", \"paths\": { \"jszip\": [ \"node_modules/jszip/dist/jszip.min.js\" ] } } \"//\": \"...\"} 加上之後， JSZip 的問題解決了，但變成下圖中的 Error ： 我百思不得其解，因為 ng serve 沒有問題，但 build 的時候就會說找不到，而我也試了很多方式都解不掉這個問題。 後來我想到，會不會是因為設定會被覆蓋的關係？！ 因為原本 libs 裡的 import 路徑會在專案根目錄的 tsconfig.json 裡設定，而 tsconfig.json 們會像下圖這樣繼承配置： apps/app-name/tsconfig.json\b 繼承 ./tsconfig.json 裡的配置 。 apps/app-name/tsconfig.app.json 再繼承 apps/app-name/tsconfig.json\b 裡的配置。 因此，當我們一開始在 apps/app-name/tsconfig.app.json 加上因應 JSZip 的 paths 配置時，就覆蓋掉原本在 ./tsconfig.json 裡的 paths 配置，造成找不到 libs 裡 export 的 module 的問題。 解決辦法解決這個問題的辦法基本上有兩個： 在 apps/app-name/tsconfig.app.json 的 paths 補上原本在 ./tsconfig.json 的 paths 配置。 將 JSZip 的配置從 apps/app-name/tsconfig.app.json 移到 ./tsconfig.json 裡。 相對來說，第二個方式絕對會比第一個方式好得多。 結論一般來說，其他的 tsconfig.json 都不太會需要去動，因此只要我們養成習慣，都只在修改在專案根目錄下的 tsconfig.json 的配置就不會有問題了。 參考連結 How to use paths in tsconfig.json? TypeScript - Module Resolution","link":"/2019/10/31/my-nx-note-tsconfig/"},{"title":"用 RxJS 翻轉你的 coding 人生 - 以 Timer 為例","text":"昨天同事在某個頁面裡新增了一個「背景自動刷新頁面」的功能，而我在幫他 code review 之後趕緊請他改用 RxJS 實作這個功能，這是為什麼呢？ 沒有要鞭同事的意思，純粹是藉機分享！ 一般實作方式一般用 JavaScript 實作的計時器大概會長這樣： 1234567891011121314151617181920212223242526var REFRESH_PERIOD_SECOND = 30;var timer;var counter = 0;function startTimer() { timer = setInterval(function () { counter += 1; if (counter &gt;= REFRESH_PERIOD_SECOND) { // do something.. resetTimer(); } }, 1000);}function resetTimer() { stopTimer(); startTimer();}function stopTimer() { clearInterval(timer); counter = 0;}startTimer(); 完整程式碼範例： JS Bin 用 RxJS 的實作方式換用 RxJS 來實作的話大概會長這樣（以在 Angular 裡面實作為例）： 1234567891011121314151617181920212223242526272829303132333435363738@Component({ // ...})export class AppComponent implements OnInit { count = 0; private readonly REFRESH_PERIOD_SECOND = 30; private start$ = new Subject(); private stop$ = new Subject(); private timer$ = this.start$.pipe( switchMap(() =&gt; interval(1000).pipe(map((count) =&gt; count + 1))), tap((count) =&gt; (this.count = count)), filter((count) =&gt; count === this.REFRESH_PERIOD_SECOND), takeUntil(this.stop$), repeat() ); ngOnInit(): void { this.timer$.subscribe(() =&gt; this.resetTimer()); this.startTimer(); } startTimer(): void { this.start$.next(null); } stopTimer(): void { this.count = 0; this.stop$.next(null); } resetTimer(): void { this.stopTimer(); this.startTimer(); }} 完整程式碼範例： Stackblitz 所以說，改用 RxJS 來實作到底好在哪裡呢？ 我個人覺得有以下三個好處： 計時器要做的事情在初始化的時候就做好了，後續不用再重做第二次 由於有上一點的好處，所以實際在執行動作的時候，就只要用 start$ 或 stop$ 送出通知即可。 更好閱讀與更美觀 你覺得呢？","link":"/2022/09/29/timer-sample-in-rxjs/"},{"title":"JavaScript 語言特性之先 ++ 跟後 ++ 到底哪裡不同？","text":"今天我在看 Angular 的原始碼的時候我發現了一段程式碼如下： 123456let _nextReactiveId: number = 0;export abstract class ReactiveNode { private readonly id = _nextReactiveId ++; // 以下省略} 然後我就覺得，咦？！第一次看到別人這樣用（被發現我很少看別人的程式碼了），然後就很好奇所以這樣 id 會是從多少開始、然後也很好奇如果改為使用 ++ _nextReactiveId 或是 _nextReactiveId += 1 的話會怎樣，所以我就做了一下實驗，並且分享給大家！ 實驗 1 - i += 1首先我們一樣先宣告一個變數 i 等於 0 ： 1let i = 0; 然後宣告一個變數 a 等於 i += 1 之後的結果： 1const a = i += 1; 接著把它印出來看看： 12console.log(a) // 1console.log(i) // 1 從結果回推，看起來 i += 1 這部份會先運算 （為避免有人不知道，提示一下：i += 1 ⇒ i = i + 1），然後變數 a 會再把變數 i 的值給記錄下來，所以最終兩個變數的值都會是運算完之後的結果。 實驗 2 - i ++再來是第二種方式 - i ++ ，我們一樣宣告一個變數 b 來記錄 i ++ 之後的結果： 1const b = i ++; 猜猜看，b 跟 i 的值分別會是什麼呢？（小提示，剛剛 i 的值已經變為 1 了唷！） 12console.log(b) // 1console.log(i) // 2 看到結果的時候，大家是不是跟我最初剛知道這件事情的時候一樣驚訝呢？ 從結果回推之後我們了解到，原來這樣子使用時， b 會先把 i 的值給記錄下來，然後 i 再執行如同 i += 1 的運算，所以 b 的值會是 i 運算前的值，而 i 則會記錄運算後的值。寫成程式碼的話有點像是這樣： 12const b = i;i += 1; 所以實驗到這邊我就明白為什麼 Angular 的原始碼會那樣寫了！ 實驗 3 - ++ i最後，我們來看看 ++ i 吧！宣告一個變數 c 用以記錄 ++ i 之後的結果： 1const c = ++ i; 大家再來猜猜看 c 跟 i 的值分別會是什麼吧！（小提示：i 的值剛剛已經變為 2 囉！） 12console.log(c) // 3console.log(i) // 3 大家都有猜到嗎？ ++ i 的結果跟 i += 1 是一樣的，都是先運算，再記錄值。 結論從實驗結果來看，我們可以下一個結論：「在這個使用情境中，使用 i += 1 等於使用 ++ i 不等於使用 i ++ 。 而在此之前，雖然我知道這三種方式有所差異，但其實並沒有真的很清楚的知道差異的所在，而最近自己也在改變自己讀書與學習的方式（其實也就只是好好做筆記，建立自己的知識庫罷了），希望這一點一滴的累積，都可以幫助到自己，也幫助到大家。","link":"/2023/07/22/javascript-tips-helpful-natvie-method-tofixed/"}],"tags":[{"name":"angular","slug":"angular","link":"/tags/angular/"},{"name":"form","slug":"form","link":"/tags/form/"},{"name":"testing","slug":"testing","link":"/tags/testing/"},{"name":"frontend","slug":"frontend","link":"/tags/frontend/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"homebrew","slug":"homebrew","link":"/tags/homebrew/"},{"name":"macos","slug":"macos","link":"/tags/macos/"},{"name":"nx","slug":"nx","link":"/tags/nx/"},{"name":"scss","slug":"scss","link":"/tags/scss/"},{"name":"library","slug":"library","link":"/tags/library/"},{"name":"workflow","slug":"workflow","link":"/tags/workflow/"},{"name":"methodology","slug":"methodology","link":"/tags/methodology/"},{"name":"efficiency","slug":"efficiency","link":"/tags/efficiency/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"rxjs","slug":"rxjs","link":"/tags/rxjs/"},{"name":"design_patterns","slug":"design-patterns","link":"/tags/design-patterns/"},{"name":"物件導向","slug":"物件導向","link":"/tags/物件導向/"}],"categories":[{"name":"Web 前端","slug":"Web-前端","link":"/categories/Web-前端/"},{"name":"iThome2021鐵人賽","slug":"Web-前端/iThome2021鐵人賽","link":"/categories/Web-前端/iThome2021鐵人賽/"},{"name":"新聞","slug":"Web-前端/新聞","link":"/categories/Web-前端/新聞/"},{"name":"Angular 之深入解析","slug":"Web-前端/Angular-之深入解析","link":"/categories/Web-前端/Angular-之深入解析/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Nx","slug":"Web-前端/Nx","link":"/categories/Web-前端/Nx/"},{"name":"documentation","slug":"documentation","link":"/categories/documentation/"},{"name":"JavaScript","slug":"Web-前端/JavaScript","link":"/categories/Web-前端/JavaScript/"},{"name":"程式基礎學習","slug":"程式基礎學習","link":"/categories/程式基礎學習/"}]}