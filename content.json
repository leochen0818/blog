{"pages":[],"posts":[{"title":"我的 Nx 筆記 - 如何在你的 Application 裡，用很漂亮的方式引入 Library 的 SCSS","text":"最近在開始研究 Nx 這個非常好用的開發工具，當然也撞了不少牆…（鼻青臉腫中）。 今天主要要分享的是： 如何在你的 Application 裡，用很漂亮的方式引入 Library 裡的 SCSS 而這個方法是我在這個 issue 裡看到的，留言的人是 tcoz 。 在開始之前，請先準備 Nx 的專案，且裡面有一個 Application 名為 sample 、 一個 Library 名為 sample-lib ，然後在 sample-lib 裡準備一個 abc.scss 。 scss 的內容很簡單： 123h1 { color: red;} 接著把 sample 跑起來，應該會看到以下畫面： 然後先在 Nx 的 angular.json 裡，找到你的專案的 build 配置，大概長這樣： 1234567891011121314151617181920212223242526{ \"//\": \"...\", \"projects\": { \"sample\": { \"//\": \"...\", \"architect\": { \"build\": { \"builder\": \"@angular-devkit/build-angular:browser\", \"options\": { \"outputPath\": \"dist/apps/sample\", \"index\": \"apps/sample/src/index.html\", \"main\": \"apps/sample/src/main.ts\", \"polyfills\": \"apps/sample/src/polyfills.ts\", \"tsConfig\": \"apps/sample/tsconfig.app.json\", \"aot\": false, \"assets\": [\"apps/sample/src/favicon.ico\", \"apps/sample/src/assets\"], \"styles\": [\"apps/sample/src/styles.scss\"], \"scripts\": [] }, }, \"//\": \"...\", } } }, \"//\": \"...\",} 然後加上 stylePreprocessorOptions 跟 extractCss 的配置，像這樣： 12345678910111213141516171819202122232425{ \"//\": \"...\", \"projects\": { \"sample\": { \"//\": \"...\", \"architect\": { \"build\": { \"builder\": \"@angular-devkit/build-angular:browser\", \"options\": { \"//\": \"...\", \"stylePreprocessorOptions\": { \"includePaths\": [\"libs/sample-lib/src/lib/scss\"] }, \"extractCss\": true, \"//\": \"...\", }, }, \"//\": \"...\", } } }, \"//\": \"...\",} includePaths 裡的路徑就是要處理的 SCSS 的資料夾路徑\b。 如此一來，就可以到 sample 裡的 SCSS 裡 import （我在 sample 裡的 style.scss import ）： 1@import \"abc\"; 結果： 參考資料 Angular 官方文件","link":"/blog/2019/10/24/my-nx-note-impot-scss-from-library/"},{"title":"我的 Nx 筆記 - tsconfig.json 的坑","text":"我最近在研究 Nx 時遇到了一個坑，這個坑讓我卡了兩、三個小時，所以我將這件事情筆記下來，希望如果以後有人遇到類似的問題，這篇筆記多少可以幫得上忙。 問題描述在 Angular 專案裡我們經常會看到各種 tsconfig.json ，而這些 tsconfig.json 又繼承來繼承去的，雖然一般我們不會特別去動他們的設定，但當我們因為某些緣故需要去調整的時候，就要特別小心「覆蓋」的問題。 而我遇到的狀況是，我在使用 JSZip 這個套件時，遇到了下圖中的 Error ： 解決辦法是在 apps/app-name/tsconfig.app.json 的 compilerOptions 裡加上 path 的配置： 123456789101112{ \"//\": \"...\", \"compilerOptions\": { \"//\": \"...\", \"paths\": { \"jszip\": [ \"node_modules/jszip/dist/jszip.min.js\" ] } } \"//\": \"...\"} 加上之後， JSZip 的問題解決了，但變成下圖中的 Error ： 我百思不得其解，因為 ng serve 沒有問題，但 build 的時候就會說找不到，而我也試了很多方式都解不掉這個問題。 後來我想到，會不會是因為設定會被覆蓋的關係？！ 因為原本 libs 裡的 import 路徑會在專案根目錄的 tsconfig.json 裡設定，而 tsconfig.json 們會像下圖這樣繼承配置： apps/app-name/tsconfig.json\b 繼承 ./tsconfig.json 裡的配置 。 apps/app-name/tsconfig.app.json 再繼承 apps/app-name/tsconfig.json\b 裡的配置。 因此，當我們一開始在 apps/app-name/tsconfig.app.json 加上因應 JSZip 的 paths 配置時，就覆蓋掉原本在 ./tsconfig.json 裡的 paths 配置，造成找不到 libs 裡 export 的 module 的問題。 解決辦法解決這個問題的辦法基本上有兩個： 在 apps/app-name/tsconfig.app.json 的 paths 補上原本在 ./tsconfig.json 的 paths 配置。 將 JSZip 的配置從 apps/app-name/tsconfig.app.json 移到 ./tsconfig.json 裡。 相對來說，第二個方式絕對會比第一個方式好得多。 結論一般來說，其他的 tsconfig.json 都不太會需要去動，因此只要我們養成習慣，都只在修改在專案根目錄下的 tsconfig.json 的配置就不會有問題了。 參考連結 How to use paths in tsconfig.json? TypeScript - Module Resolution","link":"/blog/2019/10/31/my-nx-note-tsconfig/"},{"title":"Angular 之 Injector 探討","text":"關於 Angular 的 Injector ，雖然我之前在寫「Angular 深入淺出三十天」的系列文時，就有在基礎結構說明（四）這篇文章裡介紹過，不過今天我在跟朋友們聊到相關的話題時，除了好好的做了個實驗，並把程式碼保留下來之外，也忽然起了個念頭，覺得是該把這個問題寫成文章，讓剛學 Angular 或是對 Angular 的了解沒那麼深的朋友們可以比較容易理解、比較不會用錯（就我個人的經驗來看，沒有注意到這個部分的朋友們還滿多的）。 問題描述在 Angular 裡寫 Service 的時候，我們一般會用以下三種方式註冊它： 在該 Service 的 @Injectable() 裡加上 { providedIn: 'root' } 的 Metadata （ Angular 7+ 推薦寫法），抑或者在 AppModule 的 providers 裡註冊它（ Angular 6- 的寫法）。 在相關的功能模組的 providers 裡註冊它。 在某個 Component 的 providers 裡註冊它。 其實在 Angular 9 之後的版本，除了 providedIn: 'root' 之外，還多了 'platform' 與 'any' 這兩個選擇，不過此篇文章不討論這個部分。 這三種註冊方式其中的第一種與第三種，大家比較不會有問題，比較會有問題的是第二種，很多人可能會覺得，我使用起來明明就是同一個實體呀？怎麼官方說是不同實體呢？ 實驗開始為了釐清這個問題，我做了個實驗，程式碼在這裡：https://stackblitz.com/edit/angular-ivy-5fdo5y?file=src/app/app.component.html 在這個實驗裡，我用了四個 Module ─ AboutModule、ContactModule、HomeModule、WhateverModule 與兩個 Service ─ ASservice 與 BService 來模擬大部分會遇到的情況： AService 使用 providedIn: 'root' 註冊。 HomeModule、ContactModule、WhateverModule 都 import 到 AppModule 裡。 AboutModule 用 LazyLoading 的方式載入。 BService 則分別註冊在 ContactModule、HomeModule、AboutModule 的 providers 裡與 WhateverComponent 的 providers 裡。 結果： 有看懂嗎？ BService 在 HomeComponent 與 ContactComponet 裡是用同一個實體，這是因為他們都有被 import 到 AppModule 裡，這時 AppModule（上層 Module）會接手 ContactModule、HomeModule（子層 Module）的 injector，所以他們雖然有分別註冊 BService ，但實際上還是共用了同一個實體。 這部份其實官網文件有寫到： 網址在這：https://angular.io/guide/hierarchical-dependency-injection#moduleinjector 不過我這裡只有實驗一層的情況，如果 Module 一層一層的接下去，是不是也是一樣的狀況我就沒有特別做實驗了，大家可以自己玩看看。 至於 AboutComponent 跟 WhateverComponent 呢，很明顯都是使用不同的 BService 的實體，前者因為使用 LazyLoading 的關係，跟 AppModule 沒有直接關聯，後者則是因為是使用了第三種註冊方式的關係。 結論總而言之，官方之所以提供了不同的註冊方式給我們，就是希望我們可以在不同的情況下使用不同的註冊方式來解決我們的問題，只要能夠熟知這其中的差異，就可以寫出好維護又高品質的系統囉！","link":"/blog/2021/03/25/get-to-the-meet-of-angular-injector/"},{"title":"如何在 macOS 裡使用 Homebrew 來安裝與升級 Git","text":"在 macOS 裡，因 Git 是內建在系統當中的關係，所以在 macOS 裡使用 Git 非常方便，打開終端機就能使用了。 但可惜的是，隨著 Git 裡有著某些重大安全性問題被發現， Git 也隨之釋出新版本提供給大家更新， macOS 內建的 Git 版本就過於老舊了些。 我們可以在終端機中輸入以下指令來查看當前所使用的 Git 的版本： 12$ git versiongit version 2.15.1 (Apple Git-101) 所以後來許多人就推薦改為使用 Homebrew 來安裝與更新 Git ，方式可以參考以下連結： 如何以 Homebrew 取代 MacOS 內建 Git 並更新 不過隨著 macOS 的更新，系統的安全性也逐漸被 Apple 增加，所以筆者在使用 sudo mv /usr/bin/git /usr/bin/git-apple 這個指令時（ macOS 版本為： Catalina 10.15.1 ），遇到了第一個問題： operation not permitted 。 這時筆者 Google 到第一個解決方案： [Mac] iTerm2或Terminal在升級macOS Mojave之後使用指令時會出現”Operation not permitted” 不過這個方式在筆者的系統中沒有作用，依舊會遇到 operation not permitted 的問題。 而後筆者 Google 到第二個解決方案： Operation Not Permitted when on root - El Capitan (rootless disabled) 裡的綠勾勾回覆 筆者照做之後，再次使用 sudo mv /usr/bin/git /usr/bin/git-apple ，遇到了第二個問題： Read-only file system 。因此筆者又 Google 了一下，找到了以下解決方案： macOS 无法sudo创建文件夹返回Read-only file system问题解决 參照上述文章，筆者在終端機裡輸入以下指令： 1$ sudo mount -uw / 即可正常使用： 1$ sudo mv /usr/bin/git /usr/bin/git-apple 而後就能夠改為使用 Homebrew 安裝的 Git： 12$ git versiongit version 2.24.1 以上，希望有幫到大家。","link":"/blog/2019/12/12/how-to-use-git-with-homebrew-in-macos/"}],"tags":[{"name":"angular","slug":"angular","link":"/blog/tags/angular/"},{"name":"nx","slug":"nx","link":"/blog/tags/nx/"},{"name":"scss","slug":"scss","link":"/blog/tags/scss/"},{"name":"library","slug":"library","link":"/blog/tags/library/"},{"name":"typescript","slug":"typescript","link":"/blog/tags/typescript/"},{"name":"git","slug":"git","link":"/blog/tags/git/"},{"name":"homebrew","slug":"homebrew","link":"/blog/tags/homebrew/"},{"name":"macos","slug":"macos","link":"/blog/tags/macos/"}],"categories":[{"name":"Web 前端","slug":"Web-前端","link":"/blog/categories/Web-前端/"},{"name":"Git","slug":"Git","link":"/blog/categories/Git/"}]}